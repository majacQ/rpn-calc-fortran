var tipuesearch = {"pages":[{"title":" RPN calculator in Fortran ","text":"RPN calculator in Fortran Developer Info Michael Hirsch, Ph.D. SciVision, Inc.","tags":"home","loc":"index.html"},{"title":"bessel.f90 – RPN calculator in Fortran","text":"This file depends on sourcefile~~bessel.f90~~EfferentGraph sourcefile~bessel.f90 bessel.f90 sourcefile~k1.f k1.f sourcefile~bessel.f90->sourcefile~k1.f sourcefile~ribesl.f ribesl.f sourcefile~bessel.f90->sourcefile~ribesl.f sourcefile~rybesl.f rybesl.f sourcefile~bessel.f90->sourcefile~rybesl.f sourcefile~k0.f k0.f sourcefile~bessel.f90->sourcefile~k0.f sourcefile~rkbesl.f rkbesl.f sourcefile~bessel.f90->sourcefile~rkbesl.f sourcefile~i0.f i0.f sourcefile~bessel.f90->sourcefile~i0.f sourcefile~i1.f i1.f sourcefile~bessel.f90->sourcefile~i1.f sourcefile~rjbesl.f rjbesl.f sourcefile~bessel.f90->sourcefile~rjbesl.f Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~bessel.f90~~AfferentGraph sourcefile~bessel.f90 bessel.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules bessel Source Code bessel.f90 Source Code module bessel use assert , only : wp , isclose use rjb , only : rjbesl use rji , only : ribesl use rjk , only : rkbesl use rjy , only : rybesl use i0 , only : besi0 use i1 , only : besi1 use k0 , only : besk0 use k1 , only : besk1 implicit none private public :: jinc , besi0 , besi1 , besk0 , besk1 , ribesl , rjbesl , rkbesl , rybesl contains elemental real ( wp ) FUNCTION jinc ( X ) real ( wp ), INTENT ( IN ) :: X IF ( isclose ( x , 0._wp )) THEN jinc = 0.5_wp ELSE jinc = bessel_j1 ( X ) / X END IF END FUNCTION jinc end module bessel","tags":"","loc":"sourcefile/bessel.f90.html"},{"title":"calc.f90 – RPN calculator in Fortran","text":"This file depends on sourcefile~~calc.f90~~EfferentGraph sourcefile~calc.f90 calc.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~reg.f90 reg.f90 sourcefile~calc.f90->sourcefile~reg.f90 sourcefile~gamma.f90 gamma.f90 sourcefile~funcs.f90->sourcefile~gamma.f90 sourcefile~trig.f90 trig.f90 sourcefile~funcs.f90->sourcefile~trig.f90 sourcefile~rat.f90 rat.f90 sourcefile~funcs.f90->sourcefile~rat.f90 sourcefile~hyper.f90 hyper.F90 sourcefile~funcs.f90->sourcefile~hyper.f90 sourcefile~stats.f90 stats.f90 sourcefile~funcs.f90->sourcefile~stats.f90 sourcefile~bessel.f90 bessel.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~ui.f90->sourcefile~reg.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 sourcefile~eval.f90->sourcefile~reg.f90 sourcefile~help.f90 help.f90 sourcefile~eval.f90->sourcefile~help.f90 sourcefile~gamma.f90->sourcefile~rat.f90 sourcefile~gamma.f90->sourcefile~hyper.f90 sourcefile~rat.f90->sourcefile~reg.f90 sourcefile~hyper.f90->sourcefile~reg.f90 sourcefile~hyper.f90->sourcefile~rat.f90 sourcefile~stats.f90->sourcefile~reg.f90 sourcefile~stats.f90->sourcefile~rat.f90 sourcefile~k1.f k1.f sourcefile~bessel.f90->sourcefile~k1.f sourcefile~ribesl.f ribesl.f sourcefile~bessel.f90->sourcefile~ribesl.f sourcefile~rybesl.f rybesl.f sourcefile~bessel.f90->sourcefile~rybesl.f sourcefile~k0.f k0.f sourcefile~bessel.f90->sourcefile~k0.f sourcefile~rkbesl.f rkbesl.f sourcefile~bessel.f90->sourcefile~rkbesl.f sourcefile~i0.f i0.f sourcefile~bessel.f90->sourcefile~i0.f sourcefile~i1.f i1.f sourcefile~bessel.f90->sourcefile~i1.f sourcefile~rjbesl.f rjbesl.f sourcefile~bessel.f90->sourcefile~rjbesl.f var pansourcefilecalcf90EfferentGraph = svgPanZoom('#sourcefilecalcf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs RPN Source Code calc.f90 Source Code ! main program for Fortran 2018 RPN calculator !---- (historical notes) ----------- !  Programmer:   David G. Simpson !                NASA Goddard Space Flight Center !                Greenbelt, Maryland  20771 !  Date:         December 28, 2005 !----------------------------------- PROGRAM RPN use , intrinsic :: iso_fortran_env , only : stdout => output_unit , stdin => input_unit USE GLOBAL use funcs , only : isrational , isreal , iscomplex , toUpper use stackops , only : printx , push_stack use evals , only : eval IMPLICIT NONE real ( wp ), PARAMETER :: PI = 4._wp * atan ( 1._wp ) real ( wp ), PARAMETER :: TWOPI = 2 * pi INTEGER :: IDX , IERR , DEL , PTR , RN , RD real ( wp ) :: X COMPLEX ( wp ) :: CX CHARACTER ( 300 ) :: LINE , SUBSTR CHARACTER ( 100 ) :: NUMSTR LOGICAL :: NUM_FLAG = . false . print * , 'Fortran 2018  RPN Calculator, Version ' // VERSION !     Initialize data. call init_stack () DEL = IACHAR ( 'a' ) - IACHAR ( 'A' ) ! find ASCII position diff between 'A' and 'a' STACK = 0._wp ! clear the REAL stack REG = 0._wp ! clear the REAL registers LASTX = 0._wp ! clear the REAL LAST X register NN = 0._wp ! clear the REAL summation registers SUMX = 0._wp SUMX2 = 0._wp SUMY = 0._wp SUMY2 = 0._wp SUMXY = 0._wp CSTACK = ( 0._wp , 0._wp ) ! clear the COMPLEX stack CREG = ( 0._wp , 0._wp ) ! clear the COMPLEX registers CLASTX = ( 0._wp , 0._wp ) ! clear the COMPLEX LAST X register CNN = ( 0._wp , 0._wp ) ! clear the COMPLEX summation registers CSUMX = ( 0._wp , 0._wp ) CSUMX2 = ( 0._wp , 0._wp ) CSUMY = ( 0._wp , 0._wp ) CSUMY2 = ( 0._wp , 0._wp ) CSUMXY = ( 0._wp , 0._wp ) RNSTACK = 0 ; RDSTACK = 1 ! clear the RATIONAL stack RNREG = 0 ; RDREG = 1 ! clear the RATIONAL registers RNLASTX = 0 ; RDLASTX = 1 ! clear the RATIONAL LAST X register RNNN = 0 ; RDNN = 1 ! clear the RATIONAL summation registers RNSUMX = 0 ; RDSUMX = 1 RNSUMX2 = 0 ; RDSUMX2 = 1 RNSUMY = 0 ; RDSUMY = 1 RNSUMY2 = 0 ; RDSUMY2 = 1 RNSUMXY = 0 ; RDSUMXY = 1 ANGLE_MODE = INITIAL_ANGLE_MODE SELECT CASE ( ANGLE_MODE ) CASE ( 1 ) ! deg ANGLE_FACTOR = PI / 18 0._wp CASE ( 2 ) ! rad ANGLE_FACTOR = 1._wp CASE ( 3 ) ! grad ANGLE_FACTOR = PI / 20 0._wp CASE ( 4 ) ! rev ANGLE_FACTOR = TWOPI END SELECT DISP_MODE = INITIAL_DISP_MODE ! set modes DISP_DIGITS = INITIAL_DISP_DIGITS DOMAIN_MODE = INITIAL_DOMAIN_MODE BASE_MODE = INITIAL_BASE_MODE FRACTION_MODE = INITIAL_FRACTION_MODE FRACTOL = INITIAL_FRACTOL ! set decimal-to-fraction tolerance !     call random_init()   ! Fortran 2018 + the following line CALL RANDOM_SEED () ! init random number generator ! -----  Main loop. DO ! loop once for each input line WRITE ( stdout , '(A)' , ADVANCE = 'NO' ) '  ? ' READ ( stdin , '(A132)' , iostat = ierr ) LINE if ( ierr < 0 ) exit ! Ctrl D was pressed !     Convert the input line to all uppercase, removing leftmost blanks LINE = toUpper ( ADJUSTL ( LINE )) !     Search for QUIT 'Q' IF ( TRIM ( LINE ) == 'Q' ) exit PTR = 1 !     Loop for each element in the input line. DO IDX = INDEX ( LINE ( PTR :), ' ' ) + PTR - 1 ! look for the next space.. IF ( IDX . EQ . 0 ) IDX = LEN ( LINE ( PTR :)) ! ..or end of line SUBSTR = LINE ( PTR : IDX - 1 ) ! get the current substring SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) NUM_FLAG = ISREAL ( SUBSTR , X ) ! convert to a real number, if possible CASE ( 2 ) NUM_FLAG = ISCOMPLEX ( SUBSTR , CX ) ! convert to a complex number, if possible CASE ( 3 ) NUM_FLAG = ISRATIONAL ( SUBSTR , RN , RD ) ! convert to a rational number, if possible END SELECT IF ( NUM_FLAG ) THEN ! if a number, then put it on the stack SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( X ) ! push real number onto real stack CASE ( 2 ) CALL push_stack ( CX ) ! push complex number onto complex stack CASE ( 3 ) CALL push_stack ( RN , RD ) ! push rational number onto rational stack END SELECT ELSE ! else it's an operator CALL EVAL ( SUBSTR ) ! evaluate operator END IF PTR = IDX + 1 ! update line pointer IF ( LEN_TRIM ( LINE ( PTR :)) . EQ . 0 ) EXIT ! exit if at end of line END DO !     Print X register. SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PRINTX ( STACK ( 1 ), NUMSTR ) ! format REAL X CASE ( 2 ) CALL PRINTX ( CSTACK ( 1 ), NUMSTR ) ! format COMPLEX X CASE ( 3 ) CALL PRINTX ( RNSTACK ( 1 ), RDSTACK ( 1 ), NUMSTR ) ! format RATIONAL X END SELECT print '(3X,A)' , TRIM ( NUMSTR ) ! print X END DO ! -- end program by printing last value (helping automatic self test cases) print * , new_line ( '' ) SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PRINTX ( STACK ( 1 ), NUMSTR ) CASE ( 2 ) CALL PRINTX ( CSTACK ( 1 ), NUMSTR ) CASE ( 3 ) CALL PRINTX ( RNSTACK ( 1 ), RDSTACK ( 1 ), NUMSTR ) END SELECT print '(3X,A)' , TRIM ( NUMSTR ) END PROGRAM RPN","tags":"","loc":"sourcefile/calc.f90.html"},{"title":"eval.f90 – RPN calculator in Fortran","text":"This file depends on sourcefile~~eval.f90~~EfferentGraph sourcefile~eval.f90 eval.f90 sourcefile~ui.f90 ui.f90 sourcefile~eval.f90->sourcefile~ui.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~reg.f90 reg.f90 sourcefile~eval.f90->sourcefile~reg.f90 sourcefile~help.f90 help.f90 sourcefile~eval.f90->sourcefile~help.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~ui.f90->sourcefile~reg.f90 sourcefile~gamma.f90 gamma.f90 sourcefile~funcs.f90->sourcefile~gamma.f90 sourcefile~trig.f90 trig.f90 sourcefile~funcs.f90->sourcefile~trig.f90 sourcefile~rat.f90 rat.f90 sourcefile~funcs.f90->sourcefile~rat.f90 sourcefile~hyper.f90 hyper.F90 sourcefile~funcs.f90->sourcefile~hyper.f90 sourcefile~stats.f90 stats.f90 sourcefile~funcs.f90->sourcefile~stats.f90 sourcefile~bessel.f90 bessel.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~gamma.f90->sourcefile~rat.f90 sourcefile~gamma.f90->sourcefile~hyper.f90 sourcefile~rat.f90->sourcefile~reg.f90 sourcefile~hyper.f90->sourcefile~reg.f90 sourcefile~hyper.f90->sourcefile~rat.f90 sourcefile~stats.f90->sourcefile~reg.f90 sourcefile~stats.f90->sourcefile~rat.f90 sourcefile~k1.f k1.f sourcefile~bessel.f90->sourcefile~k1.f sourcefile~ribesl.f ribesl.f sourcefile~bessel.f90->sourcefile~ribesl.f sourcefile~rybesl.f rybesl.f sourcefile~bessel.f90->sourcefile~rybesl.f sourcefile~k0.f k0.f sourcefile~bessel.f90->sourcefile~k0.f sourcefile~rkbesl.f rkbesl.f sourcefile~bessel.f90->sourcefile~rkbesl.f sourcefile~i0.f i0.f sourcefile~bessel.f90->sourcefile~i0.f sourcefile~i1.f i1.f sourcefile~bessel.f90->sourcefile~i1.f sourcefile~rjbesl.f rjbesl.f sourcefile~bessel.f90->sourcefile~rjbesl.f Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~eval.f90~~AfferentGraph sourcefile~eval.f90 eval.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~eval.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules evals Source Code eval.f90 Source Code module evals use global use funcs use stackops use assert , only : wp , isclose use help , only : print_help implicit none private complex ( wp ), parameter , private :: C0 = ( 0._wp , 0._wp ) public :: eval contains !*********************************************************************************************************************************** !  EVAL ! !  Evaluate a operation. !*********************************************************************************************************************************** recursive SUBROUTINE EVAL ( STR ) CHARACTER ( * ), INTENT ( IN ) :: STR real ( wp ), PARAMETER :: PI = 4._wp * atan ( 1._wp ) real ( wp ), PARAMETER :: EULER = 0.5772156649_wp real ( wp ), PARAMETER :: GOLDEN = 1.618033988745_wp COMPLEX ( wp ), PARAMETER :: II = ( 0._wp , 1._wp ) real ( wp ), PARAMETER :: KG_PER_LB = 0.45359237D0 real ( wp ), PARAMETER :: CM_PER_IN = 2.54_wp real ( wp ), PARAMETER :: L_PER_GAL = 3.785411784D0 real ( wp ), PARAMETER :: A0 = 0.5291772108D-10 ! m real ( wp ), PARAMETER :: AMU = 1.660539040e-27_wp ! kg real ( wp ), PARAMETER :: AU = 1.49597870D11 ! m real ( wp ), PARAMETER :: C = 29979245 8.0D0 ! m/s real ( wp ), PARAMETER :: ECHG = 1.6021766e-19_wp ! C real ( wp ), PARAMETER :: EPS0 = 8.8541878176203898505D-12 ! F/m real ( wp ), PARAMETER :: G = 9.80665D0 ! m/s&#94;2 real ( wp ), PARAMETER :: GRAV = 6.6742D-11 ! m&#94;3/kg s&#94;2 real ( wp ), PARAMETER :: H = 6.6260693D-34 ! J s real ( wp ), PARAMETER :: HBAR = 1.05457168D-34 ! J s real ( wp ), PARAMETER :: KB = 1.3806505D-23 ! J/K real ( wp ), PARAMETER :: ME = 9.1093826D-31 ! kg real ( wp ), PARAMETER :: MN = 1.67492728D-27 ! kg real ( wp ), PARAMETER :: MP = 1.67262171D-27 ! kg real ( wp ), PARAMETER :: MU0 = 1 2.5663706143591729539D-7 ! N/A&#94;2 real ( wp ), PARAMETER :: MUB = 92 7.400949D-26 ! A m&#94;2 real ( wp ), PARAMETER :: MUN = 5.05078343D-27 ! A m&#94;2 real ( wp ), PARAMETER :: NA = 6.0221415D23 ! mol&#94;-1 real ( wp ), PARAMETER :: REARTH = 637814 0.0D0 ! m real ( wp ), PARAMETER :: RGAS = 8.314472D0 ! J/mol K real ( wp ), PARAMETER :: STEFAN = 5.670400D-8 ! W/m&#94;2 K&#94;4 INTEGER :: I , ITMP , ITMP2 , NUM , DEN , NUM2 , DEN2 , NUM3 , DEN3 , NUM4 , DEN4 , & NUMM , DENM , NUMB , DENB real ( wp ) :: TMP , TMP2 , TMP3 , TMPM , TMPB , TMPR COMPLEX ( wp ) :: CTMP , CTMPM , CTMPB , CTMPR CHARACTER ( LEN = 2 ) :: REGNAME INTEGER :: DT ( 8 ) INTEGER :: YEAR , MONTH , DAY , HOUR , MINUTE , SECOND , NB , NCALC CHARACTER ( LEN = 100 ) :: NUMSTR CHARACTER ( LEN = 10 ) :: TIME , DATE , ZONE real ( wp ), ALLOCATABLE , DIMENSION (:) :: BES_B IF ( LEN_TRIM ( STR ) == 0 ) return select case ( str ) case ( 'HELP' ) call eval ( 'VER' ) call eval ( 'MODES' ) call eval ( 'PS' ) call eval ( 'PR' ) call print_help () case ( '+' ) ! + call add ( domain_mode ) case ( '-' ) ! - call subtract ( domain_mode ) case ( '*' ) ! * call multiply ( domain_mode ) case ( '/' ) ! / call divide ( domain_mode ) case ( '&#94;' ) ! &#94; call power ( domain_mode ) case ( achar ( 92 )) ! for PGI/Flang     !('\\')                                                  ! \\ SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( isclose ( stack ( 1 ), 0._wp )) THEN write ( stderr , * ) '  Divide Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = 1._wp / STACK ( 1 ) END IF CASE ( 2 ) IF ( isclose ( CSTACK ( 1 ), C0 )) THEN write ( stderr , * ) '  Divide Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ( 1.0 , 0.0 ) / CSTACK ( 1 ) END IF CASE ( 3 ) CALL RDIV ( 1 , 1 , RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = DEN END SELECT case ( '%' ) ! % SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) * 0.01_wp * STACK ( 1 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 2 ) * 0.01_wp * CSTACK ( 1 ) CASE ( 3 ) NUM = RNSTACK ( 1 ) DEN = RDSTACK ( 1 ) NUM2 = RNSTACK ( 2 ) DEN2 = RDSTACK ( 2 ) CALL RMUL ( NUM2 , DEN2 , NUM , DEN , ITMP , ITMP2 ) CALL RMUL ( ITMP , ITMP2 , 1 , 100 , NUM , DEN ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = DEN END SELECT case ( '%CHG' ) ! %CHG SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( isclose ( STACK ( 2 ), 0._wp )) THEN write ( stderr , * ) '  Divide Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = 10 0._wp * ( STACK ( 1 ) - STACK ( 2 )) / STACK ( 2 ) END IF CASE ( 2 ) IF ( isclose ( CSTACK ( 2 ), c0 )) THEN write ( stderr , * ) '  Divide Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = 10 0._wp * ( CSTACK ( 1 ) - CSTACK ( 2 )) / CSTACK ( 2 ) END IF CASE ( 3 ) NUM = RNSTACK ( 1 ) DEN = RDSTACK ( 1 ) NUM2 = RNSTACK ( 2 ) DEN2 = RDSTACK ( 2 ) CALL RSUB ( NUM , DEN , NUM2 , DEN2 , ITMP , ITMP2 ) CALL RDIV ( ITMP , ITMP2 , NUM2 , DEN2 , NUM , DEN ) CALL RMUL ( NUM , DEN , 100 , 1 , NUM2 , DEN2 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM2 RDSTACK ( 1 ) = DEN2 END SELECT case ( '!' ) ! ! SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ISINT ( STACK ( 1 )). AND .( STACK ( 1 ) < 0._wp )) THEN write ( stderr , * ) '  Factorial Error' return endif LASTX = STACK ( 1 ) STACK ( 1 ) = gamma ( STACK ( 1 ) + 1._wp ) CASE ( 2 ) IF ( isclose ( CSTACK ( 1 ), ( - 1._wp , 0._wp ))) THEN write ( stderr , * ) '  Factorial Error' return endif CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CGAMMA ( CSTACK ( 1 ) + ( 1._wp , 0._wp )) CASE ( 3 ) IF (( RDSTACK ( 1 ) == 1 ). AND .( RNSTACK ( 1 ) < 0 )) THEN write ( stderr , * ) '  Factorial Error' return endif IF ( RDSTACK ( 1 ) == 1 ) THEN ITMP = RNSTACK ( 1 ) IF ( ITMP < 0 ) THEN write ( stderr , * ) '  Factorial Error' return endif ITMP2 = 1 DO I = 2 , ITMP ITMP2 = ITMP2 * I END DO RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = ITMP2 RDSTACK ( 1 ) = 1 ELSE CALL SWITCH_RAT_TO_REAL IF ( ISINT ( STACK ( 1 )). AND .( STACK ( 1 ) < 0.0D0 )) THEN write ( stderr , * ) '  Factorial Error' return endif LASTX = STACK ( 1 ) STACK ( 1 ) = gamma ( STACK ( 1 ) + 1._wp ) END IF END SELECT case ( '!!' ) ! !! SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) < 0._wp ) THEN write ( stderr , * ) '  !! Error' ELSE IF ( ISFRAC ( STACK ( 1 ))) THEN write ( stderr , * ) '  !! Error' ELSE IF ( NINT ( STACK ( 1 )) == 0 ) THEN LASTX = STACK ( 1 ) STACK ( 1 ) = 1._wp ELSE LASTX = STACK ( 1 ) ITMP = NINT ( STACK ( 1 )) STACK ( 1 ) = 1._wp DO STACK ( 1 ) = STACK ( 1 ) * ITMP ITMP = ITMP - 2 IF ( ITMP <= 1 ) EXIT END DO END IF CASE ( 2 ) IF ( real ( CSTACK ( 1 ), wp ) < 0._wp ) THEN write ( stderr , * ) '  !! Error' ELSE IF (. not . isclose ( AIMAG ( CSTACK ( 1 )), 0._wp )) THEN write ( stderr , * ) '  !! Error' ELSE IF ( ISFRAC ( real ( CSTACK ( 1 ), wp ))) THEN write ( stderr , * ) '  !! Error' ELSE IF ( NINT ( real ( CSTACK ( 1 ), wp )) == 0 ) THEN CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ( 1._wp , 0._wp ) ELSE CLASTX = CSTACK ( 1 ) ITMP = NINT ( real ( CSTACK ( 1 ), wp )) TMP = 1._wp DO TMP = TMP * ITMP ITMP = ITMP - 2 IF ( ITMP <= 1 ) EXIT END DO CSTACK ( 1 ) = CMPLX ( TMP , kind = wp ) END IF CASE ( 3 ) IF ( RNSTACK ( 1 ) < 0 ) THEN write ( stderr , * ) '  !! Error' ELSE IF ( RDSTACK ( 1 ) /= 1 ) THEN write ( stderr , * ) '  !! Error' ELSE IF ( RNSTACK ( 1 ) == 0 ) THEN RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = 1 RDSTACK ( 1 ) = 1 ELSE RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) ITMP = RNSTACK ( 1 ) RNSTACK ( 1 ) = 1 RDSTACK ( 1 ) = 1 DO RNSTACK ( 1 ) = RNSTACK ( 1 ) * ITMP ITMP = ITMP - 2 IF ( ITMP <= 1 ) EXIT END DO END IF END SELECT case ( '10X' ) ! 10X SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = 1 0._wp ** ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = 1 0._wp ** ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = 1 0._wp ** ( STACK ( 1 )) END SELECT case ( '2PI' ) ! 2PI SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( 2 * pi ) CASE ( 2 ) CALL PUSH_STACK ( CMPLX ( 2 * pi , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( 2 * pi ) END SELECT case ( '2PII' ) ! 2PII SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) write ( stderr , * ) ' 2PIi not available in REAL mode' CASE ( 2 ) CALL PUSH_STACK ( CMPLX ( 0._wp , 2 * pi , wp )) CASE ( 3 ) write ( stderr , * ) ' 2PIi not available in RATIONAL mode' END SELECT case ( '2X' ) ! 2X SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = 2.0D0 ** ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = 2.0D0 ** ( STACK ( 1 )) END SELECT case ( 'A0' ) ! A0 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CASE ( 2 ) CALL push_stack ( CMPLX ( A0 , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( A0 ) END SELECT case ( 'ABS' ) ! ABS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = ABS ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( ABS ( CSTACK ( 1 )), kind = wp ) CASE ( 3 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = ABS ( RNSTACK ( 1 )) RDSTACK ( 1 ) = ABS ( RDSTACK ( 1 )) END SELECT case ( 'ACOS' ) ! ACOS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ABS ( STACK ( 1 )) > 1._wp ) THEN write ( stderr , * ) '  ACOS Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ACOS ( STACK ( 1 )) / ANGLE_FACTOR END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = acos ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) IF ( ABS ( RNSTACK ( 1 )) > ABS ( RDSTACK ( 1 ))) THEN write ( stderr , * ) '  ACOS Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ACOS ( STACK ( 1 )) / ANGLE_FACTOR END IF END SELECT case ( 'ACOSH' ) ! ACOSH call hacos ( domain_mode ) case ( 'ACOT' ) ! ACOT SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = ACOT ( STACK ( 1 )) / ANGLE_FACTOR CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ACOT ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ACOT ( STACK ( 1 )) / ANGLE_FACTOR END SELECT case ( 'ACOT2' ) ! ACOT2 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = ACOT2 ( STACK ( 2 ), STACK ( 1 )) / ANGLE_FACTOR CALL DROP_STACK ( 2 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ACOT ( CSTACK ( 2 ) / CSTACK ( 1 )) / ANGLE_FACTOR CALL CDROP_STACK ( 2 ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ACOT2 ( STACK ( 2 ), STACK ( 1 )) / ANGLE_FACTOR CALL DROP_STACK ( 2 ) END SELECT case ( 'ACOTH' ) ! ACOTH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( isclose ( stack ( 1 ), 0._wp )) THEN write ( stderr , * ) '  ACOTH Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ACOTH ( STACK ( 1 )) END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = acoth ( CSTACK ( 1 )) CASE ( 3 ) IF ( RNSTACK ( 1 ) == 0 ) THEN write ( stderr , * ) '  ACOTH Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ACOTH ( STACK ( 1 )) END IF END SELECT case ( 'ACOVERS' ) ! ACOVERS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ABS ( 1._wp - STACK ( 1 )) > 1._wp ) THEN write ( stderr , * ) '  ACOVERS Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ACOVERS ( STACK ( 1 )) / ANGLE_FACTOR END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CACOVERS ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) IF ( ABS ( RNSTACK ( 1 )) < 0 ) THEN write ( stderr , * ) '  ACOVERS Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ACOVERS ( STACK ( 1 )) / ANGLE_FACTOR END IF END SELECT case ( 'ACRD' ) ! ACRD SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ABS ( STACK ( 1 )) > 2.0D0 ) THEN write ( stderr , * ) '  ACRD Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ACRD ( STACK ( 1 )) / ANGLE_FACTOR END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CACRD ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) IF ( ABS ( RNSTACK ( 1 )) > 2 * ABS ( RDSTACK ( 1 ))) THEN write ( stderr , * ) '  ACRD Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ACRD ( STACK ( 1 )) / ANGLE_FACTOR END IF END SELECT case ( 'ACSC' ) ! ACSC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ABS ( STACK ( 1 )) < 1._wp ) THEN write ( stderr , * ) '  ACSC Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ACSC ( STACK ( 1 )) / ANGLE_FACTOR END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ACSC ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) IF ( ABS ( RNSTACK ( 1 )) < ABS ( RDSTACK ( 1 ))) THEN write ( stderr , * ) '  ACSC Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ACSC ( STACK ( 1 )) / ANGLE_FACTOR END IF END SELECT case ( 'ACSCH' ) ! ACSCH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( isclose ( stack ( 1 ), 0._wp )) THEN write ( stderr , * ) '  ACSCH Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ACSCH ( STACK ( 1 )) END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ACSCH ( CSTACK ( 1 )) CASE ( 3 ) IF ( RNSTACK ( 1 ) == 0 ) THEN write ( stderr , * ) '  ACSCH Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ACSCH ( STACK ( 1 )) END IF END SELECT case ( 'AEXSEC' ) ! AEXSEC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ABS ( STACK ( 1 ) + 1._wp ) < 1._wp ) THEN write ( stderr , * ) '  AEXSEC Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = AEXSEC ( STACK ( 1 )) / ANGLE_FACTOR END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CAEXSEC ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) IF ( ABS ( RNSTACK ( 1 )) < 0 ) THEN write ( stderr , * ) '  AEXSEC Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = AEXSEC ( STACK ( 1 )) / ANGLE_FACTOR END IF END SELECT case ( 'AHAV' ) ! AHAV SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF (( STACK ( 1 ) < 0.0D0 ). OR .( STACK ( 1 ) > 1._wp )) THEN write ( stderr , * ) '  AHAV Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = AHAV ( STACK ( 1 )) / ANGLE_FACTOR END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = AHAV ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) IF (( RNSTACK ( 1 ) < 0 ). OR .( RNSTACK ( 1 ) > RDSTACK ( 1 ))) THEN write ( stderr , * ) '  AHAV Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = AHAV ( STACK ( 1 )) / ANGLE_FACTOR END IF END SELECT case ( 'ALL' ) ! ALL DISP_MODE = 4 case ( 'AMU' ) ! AMU SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( AMU ) CASE ( 2 ) CALL push_stack ( CMPLX ( AMU , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( AMU ) END SELECT case ( 'AND' ) ! AND SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = IAND ( INT ( STACK ( 2 )), INT ( STACK ( 1 ))) CALL DROP_STACK ( 2 ) CASE ( 2 ) TMP = IAND ( INT ( real ( CSTACK ( 2 ), wp )), INT ( real ( CSTACK ( 1 ), wp ))) TMP2 = IAND ( INT ( AIMAG ( CSTACK ( 2 ))), INT ( AIMAG ( CSTACK ( 1 )))) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , TMP2 , wp ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) ITMP = RNSTACK ( 1 ) / RDSTACK ( 1 ) ITMP2 = RNSTACK ( 2 ) / RDSTACK ( 2 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = IAND ( ITMP2 , ITMP ) RDSTACK ( 1 ) = 1 CALL RDROP_STACK ( 2 ) END SELECT case ( 'ARG' ) ! ARG SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = 0._wp CASE ( 2 ) TMP = ATAN2 ( AIMAG ( CSTACK ( 1 )), real ( CSTACK ( 1 ), wp )) / ANGLE_FACTOR CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , kind = wp ) CASE ( 3 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = 0 RDSTACK ( 1 ) = 1 END SELECT case ( 'ASEC' ) ! ASEC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ABS ( STACK ( 1 )) < 1._wp ) THEN write ( stderr , * ) '  ASEC Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ASEC ( STACK ( 1 )) / ANGLE_FACTOR END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ASEC ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) IF ( ABS ( RNSTACK ( 1 )) < ABS ( RDSTACK ( 1 ))) THEN write ( stderr , * ) '  ASEC Error' ELSE CALL SWITCH_RAT_TO_REAL RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) STACK ( 1 ) = ASEC ( STACK ( 1 )) / ANGLE_FACTOR END IF END SELECT case ( 'ASECH' ) ! ASECH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF (( STACK ( 1 ) <= 0.0D0 ). OR .( STACK ( 1 ) > 1._wp )) THEN write ( stderr , * ) '  ASECH Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ASECH ( STACK ( 1 )) END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ASECH ( CSTACK ( 1 )) CASE ( 3 ) IF (( RNSTACK ( 1 ) <= 0 ). OR .( RNSTACK ( 1 ) > RDSTACK ( 1 ))) THEN write ( stderr , * ) '  ASECH Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ASECH ( STACK ( 1 )) END IF END SELECT case ( 'ASIN' ) ! ASIN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ABS ( STACK ( 1 )) > 1._wp ) THEN write ( stderr , * ) '  ASIN Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ASIN ( STACK ( 1 )) / ANGLE_FACTOR END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ASIN ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) IF ( ABS ( RNSTACK ( 1 )) > ABS ( RDSTACK ( 1 ))) THEN write ( stderr , * ) '  ASIN Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ASIN ( STACK ( 1 )) / ANGLE_FACTOR END IF END SELECT case ( 'ASINH' ) ! ASINH call hasin ( domain_mode ) case ( 'ATAN' ) ! ATAN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = ATAN ( STACK ( 1 )) / ANGLE_FACTOR CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ATAN ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ATAN ( STACK ( 1 )) / ANGLE_FACTOR END SELECT case ( 'ATAN2' ) ! ATAN2 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = ATAN2 ( STACK ( 2 ), STACK ( 1 )) / ANGLE_FACTOR CALL DROP_STACK ( 2 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ATAN ( CSTACK ( 2 ) / CSTACK ( 1 )) / ANGLE_FACTOR CALL CDROP_STACK ( 2 ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ATAN2 ( STACK ( 2 ), STACK ( 1 )) / ANGLE_FACTOR CALL DROP_STACK ( 2 ) END SELECT case ( 'ATANH' ) ! ATANH call hatan ( domain_mode ) case ( 'AU' ) ! AU SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( AU ) CASE ( 2 ) CALL push_stack ( CMPLX ( AU , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( AU ) END SELECT case ( 'AVERS' ) ! AVERS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ABS ( 1._wp - STACK ( 1 )) > 1._wp ) THEN write ( stderr , * ) '  AVERS Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = AVERS ( STACK ( 1 )) / ANGLE_FACTOR END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CAVERS ( CSTACK ( 1 )) / ANGLE_FACTOR CASE ( 3 ) IF ( ABS ( RNSTACK ( 1 )) < 0 ) THEN write ( stderr , * ) '  AVERS Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = AVERS ( STACK ( 1 )) / ANGLE_FACTOR END IF END SELECT case ( 'BESSELJ0' ) ! BESSELJ0 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = bessel_J0 ( STACK ( 1 )) CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELJ0 not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = bessel_j0 ( STACK ( 1 )) END SELECT case ( 'BESSELJ1' ) associate ( x => stack ( 1 )) SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = x x = bessel_j1 ( x ) CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELJ1 not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = x x = bessel_j1 ( x ) END SELECT end associate case ( 'BESSELJ1P' ) associate ( x => stack ( 1 )) SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = x x = bessel_j0 ( x ) - 1 / x * bessel_j1 ( x ) CASE ( 2 ) write ( stderr , * ) \" Error:  BESSELJ0' not available in COMPLEX mode.\" CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = x x = bessel_j0 ( x ) - 1 / x * bessel_j1 ( x ) END SELECT end associate case ( 'BESSELJ' ) SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) call bsj () CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELJ not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL call bsj () END SELECT case ( 'BESSELY0' ) ! BESSELY0 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) call bsy0 () CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELY0 not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL call bsy0 () END SELECT case ( 'BESSELY1' ) ! BESSELY1 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  BESSELY1 Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = bessel_y1 ( STACK ( 1 )) END IF CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELY1 not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  BESSELY1 Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = bessel_y1 ( STACK ( 1 )) END IF END SELECT case ( 'BESSELY' ) ! BESSELY SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF (( STACK ( 1 ) < 0.0D0 ) . OR . ( STACK ( 2 ) < 0.0D0 )) THEN write ( stderr , * ) '  BESSELY Error 1' ELSE NB = INT ( STACK ( 2 )) + 1 ALLOCATE ( BES_B ( NB )) CALL RYBESL ( X = STACK ( 1 ), ALPHA = FRAC ( STACK ( 2 )), NB = NB , BY = BES_B , NCALC = NCALC ) IF ( NCALC < 0 ) THEN write ( stderr , * ) '  BESSELY Error 2' ELSE IF ( NCALC /= NB ) THEN write ( stderr , * ) '  BESSELY Error 3' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BES_B ( NB ) CALL DROP_STACK ( 2 ) END IF DEALLOCATE ( BES_B ) END IF CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELY not available ' // & 'in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL IF (( STACK ( 1 ) < 0.0D0 ) . OR . ( STACK ( 2 ) < 0.0D0 )) THEN write ( stderr , * ) '  BESSELY Error 1' ELSE NB = INT ( STACK ( 2 )) + 1 ALLOCATE ( BES_B ( NB )) CALL RYBESL ( X = STACK ( 1 ), ALPHA = FRAC ( STACK ( 2 )), NB = NB , BY = BES_B , NCALC = NCALC ) IF ( NCALC < 0 ) THEN write ( stderr , * ) '  BESSELY Error 2' ELSE IF ( NCALC /= NB ) THEN write ( stderr , * ) '  BESSELY Error 3' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BES_B ( NB ) CALL DROP_STACK ( 2 ) END IF DEALLOCATE ( BES_B ) END IF END SELECT case ( 'BESSELI0' ) ! BESSELI0 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = BESI0 ( STACK ( 1 )) CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELI0 not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = BESI0 ( STACK ( 1 )) END SELECT case ( 'BESSELI1' ) ! BESSELI1 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = BESI1 ( STACK ( 1 )) CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELI1 not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = BESI1 ( STACK ( 1 )) END SELECT case ( 'BESSELI' ) ! BESSELI SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF (( STACK ( 1 ) < 0.0D0 ) . OR . ( STACK ( 2 ) < 0.0D0 )) THEN write ( stderr , * ) '  BESSELI Error 1' ELSE NB = INT ( STACK ( 2 )) + 1 ALLOCATE ( BES_B ( NB )) CALL RIBESL ( X = STACK ( 1 ), ALPHA = FRAC ( STACK ( 2 )), NB = NB , IZE = 1 , B = BES_B , NCALC = NCALC ) IF ( NCALC < 0 ) THEN write ( stderr , * ) '  BESSELI Error 2' ELSE IF ( NCALC /= NB ) THEN write ( stderr , * ) '  BESSELI Error 3' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BES_B ( NB ) CALL DROP_STACK ( 2 ) END IF DEALLOCATE ( BES_B ) END IF CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELI not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL IF (( STACK ( 1 ) < 0.0D0 ) . OR . ( STACK ( 2 ) < 0.0D0 )) THEN write ( stderr , * ) '  BESSELI Error 1' ELSE NB = INT ( STACK ( 2 )) + 1 ALLOCATE ( BES_B ( NB )) CALL RIBESL ( X = STACK ( 1 ), ALPHA = FRAC ( STACK ( 2 )), NB = NB , IZE = 1 , B = BES_B , NCALC = NCALC ) IF ( NCALC < 0 ) THEN write ( stderr , * ) '  BESSELI Error 2' ELSE IF ( NCALC /= NB ) THEN write ( stderr , * ) '  BESSELI Error 3' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BES_B ( NB ) CALL DROP_STACK ( 2 ) END IF DEALLOCATE ( BES_B ) END IF END SELECT case ( 'BESSELK0' ) ! BESSELK0 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  BESSELK0 Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BESK0 ( STACK ( 1 )) END IF CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELK0 not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  BESSELK0 Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BESK0 ( STACK ( 1 )) END IF END SELECT case ( 'BESSELK1' ) ! BESSELK1 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  BESSELK1 Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BESK1 ( STACK ( 1 )) END IF CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELK1 not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  BESSELK1 Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BESK1 ( STACK ( 1 )) END IF END SELECT case ( 'BESSELK' ) ! BESSELK SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF (( STACK ( 1 ) < 0.0D0 ) . OR . ( STACK ( 2 ) < 0.0D0 )) THEN write ( stderr , * ) '  BESSELK Error 1' ELSE NB = INT ( STACK ( 2 )) + 1 ALLOCATE ( BES_B ( NB )) CALL RKBESL ( X = STACK ( 1 ), ALPHA = FRAC ( STACK ( 2 )), NB = NB , IZE = 1 , BK = BES_B , NCALC = NCALC ) IF ( NCALC < - 1 ) THEN write ( stderr , * ) '  BESSELK Error 2' ELSE IF ( NCALC == - 1 ) THEN write ( stderr , * ) '  BESSELK Error 3' ELSE IF ( NCALC /= NB ) THEN write ( stderr , * ) '  BESSELK Error 4' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BES_B ( NB ) CALL DROP_STACK ( 2 ) END IF DEALLOCATE ( BES_B ) END IF CASE ( 2 ) write ( stderr , * ) '  Error:  BESSELK not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL IF (( STACK ( 1 ) < 0.0D0 ) . OR . ( STACK ( 2 ) < 0.0D0 )) THEN write ( stderr , * ) '  BESSELK Error 1' ELSE NB = INT ( STACK ( 2 )) + 1 ALLOCATE ( BES_B ( NB )) CALL RKBESL ( X = STACK ( 1 ), ALPHA = FRAC ( STACK ( 2 )), NB = NB , IZE = 1 , BK = BES_B , NCALC = NCALC ) IF ( NCALC < - 1 ) THEN write ( stderr , * ) '  BESSELK Error 2' ELSE IF ( NCALC == - 1 ) THEN write ( stderr , * ) '  BESSELK Error 3' ELSE IF ( NCALC /= NB ) THEN write ( stderr , * ) '  BESSELK Error 4' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BES_B ( NB ) CALL DROP_STACK ( 2 ) END IF DEALLOCATE ( BES_B ) END IF END SELECT case ( 'BETA' ) ! BETA SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF (( ISINT ( STACK ( 1 )). AND .( STACK ( 1 ) <= 0.0D0 )) . OR . & ( ISINT ( STACK ( 2 )). AND .( STACK ( 2 ) <= 0.0D0 ))) THEN write ( stderr , * ) '  BETA Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BETA ( STACK ( 1 ), STACK ( 2 )) CALL DROP_STACK ( 2 ) END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CBETA ( CSTACK ( 1 ), CSTACK ( 2 )) CALL CDROP_STACK ( 2 ) CASE ( 3 ) IF ((( RDSTACK ( 1 ) == 1 ). AND .( RNSTACK ( 1 ) <= 0 )) . OR . & (( RDSTACK ( 2 ) == 1 ). AND .( RNSTACK ( 2 ) <= 0 ))) THEN write ( stderr , * ) '  BETA Error' ELSE IF (( RDSTACK ( 1 ) == 1 ) . AND . ( RDSTACK ( 2 ) == 1 )) THEN ITMP = RNSTACK ( 1 ) IF ( ITMP <= 0 ) THEN write ( stderr , * ) '  BETA Error' ELSE CALL RBETA ( RNSTACK ( 1 ), RNSTACK ( 2 ), ITMP , ITMP2 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = ITMP RDSTACK ( 1 ) = ITMP2 CALL RDROP_STACK ( 2 ) END IF ELSE CALL SWITCH_RAT_TO_REAL IF (( ISINT ( STACK ( 1 )). AND .( STACK ( 1 ) <= 0.0D0 )) . OR . & ( ISINT ( STACK ( 2 )). AND .( STACK ( 2 ) <= 0.0D0 ))) THEN write ( stderr , * ) '  BETA Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = BETA ( STACK ( 1 ), STACK ( 2 )) CALL DROP_STACK ( 2 ) END IF END IF END IF END SELECT case ( 'BIN' ) ! BIN BASE_MODE = 2 case ( 'C' ) ! C SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( C ) CASE ( 2 ) CALL push_stack ( CMPLX ( C , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( C ) END SELECT case ( 'C>F' ) ! C>F SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = ( 9.0D0 / 5.0D0 ) * STACK ( 1 ) + 3 2.0D0 CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ( 9.0D0 / 5.0D0 ) * CSTACK ( 1 ) + 3 2.0D0 CASE ( 3 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) CALL RMUL ( 9 , 5 , RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) CALL RADD ( NUM , DEN , 32 , 1 , NUM2 , DEN2 ) RNSTACK ( 1 ) = NUM2 RDSTACK ( 1 ) = DEN2 END SELECT case ( 'CBRT' ) ! CBRT SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = CUBEROOT ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CUBEROOT ( CSTACK ( 1 )) CASE ( 3 ) TMP = CUBEROOT ( real ( RNSTACK ( 1 ), wp )) TMP2 = CUBEROOT ( real ( RDSTACK ( 1 ), wp )) IF ( ISFRAC ( TMP ). OR . ISFRAC ( TMP2 )) THEN CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = CUBEROOT ( STACK ( 1 )) ELSE RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NINT ( CUBEROOT ( real ( RNSTACK ( 1 ), wp ))) RDSTACK ( 1 ) = NINT ( CUBEROOT ( real ( RDSTACK ( 1 ), wp ))) END IF END SELECT case ( 'CHS' ) ! CHS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) STACK ( 1 ) = - STACK ( 1 ) CASE ( 2 ) CSTACK ( 1 ) = - CSTACK ( 1 ) CASE ( 3 ) RNSTACK ( 1 ) = - RNSTACK ( 1 ) END SELECT case ( 'CLALL' ) ! CLALL SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) STACK = 0._wp REG = 0._wp NN = 0._wp SUMX = 0._wp SUMX2 = 0._wp SUMY = 0._wp SUMY2 = 0._wp SUMXY = 0._wp CASE ( 2 ) CSTACK = ( 0._wp , 0._wp ) CREG = ( 0._wp , 0._wp ) CNN = ( 0._wp , 0._wp ) CSUMX = ( 0._wp , 0._wp ) CSUMX2 = ( 0._wp , 0._wp ) CSUMY = ( 0._wp , 0._wp ) CSUMY2 = ( 0._wp , 0._wp ) CSUMXY = ( 0._wp , 0._wp ) CASE ( 3 ) RNSTACK = 0 ; RDSTACK = 1 RNREG = 0 ; RDREG = 1 RNNN = 0 ; RDNN = 1 RNSUMX = 0 ; RDSUMX = 1 RNSUMX2 = 0 ; RDSUMX2 = 1 RNSUMY = 0 ; RDSUMY = 1 RNSUMY2 = 0 ; RDSUMY2 = 1 RNSUMXY = 0 ; RDSUMXY = 1 END SELECT case ( 'CLREG' ) ! CLREG SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) REG = 0._wp CASE ( 2 ) CREG = ( 0._wp , 0._wp ) CASE ( 3 ) RNREG = 0 ; RDREG = 1 END SELECT case ( 'CLS' ) ! CLS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) NN = 0._wp SUMX = 0._wp SUMX2 = 0._wp SUMY = 0._wp SUMY2 = 0._wp SUMXY = 0._wp CASE ( 2 ) CNN = ( 0._wp , 0._wp ) CSUMX = ( 0._wp , 0._wp ) CSUMX2 = ( 0._wp , 0._wp ) CSUMY = ( 0._wp , 0._wp ) CSUMY2 = ( 0._wp , 0._wp ) CSUMXY = ( 0._wp , 0._wp ) CASE ( 3 ) RNNN = 0 ; RDNN = 1 RNSUMX = 0 ; RDSUMX = 1 RNSUMX2 = 0 ; RDSUMX2 = 1 RNSUMY = 0 ; RDSUMY = 1 RNSUMY2 = 0 ; RDSUMY2 = 1 RNSUMXY = 0 ; RDSUMXY = 1 END SELECT case ( 'CLSTK' ) ! CLSTK SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) STACK = 0._wp CASE ( 2 ) CSTACK = ( 0._wp , 0._wp ) CASE ( 3 ) RNSTACK = 0 ; RDSTACK = 1 END SELECT case ( 'CLX' ) ! CLX SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) STACK ( 1 ) = 0._wp CASE ( 2 ) CSTACK ( 1 ) = ( 0._wp , 0._wp ) CASE ( 3 ) RNSTACK ( 1 ) = 0 ; RDSTACK ( 1 ) = 1 END SELECT case ( 'CM>IN' ) ! CM>IN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) STACK ( 1 ) = STACK ( 1 ) / CM_PER_IN CASE ( 2 ) CSTACK ( 1 ) = CSTACK ( 1 ) / CM_PER_IN CASE ( 3 ) CALL SWITCH_RAT_TO_REAL STACK ( 1 ) = STACK ( 1 ) / CM_PER_IN END SELECT case ( 'CNR' ) ! CNR SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ISFRAC ( STACK ( 1 )) . OR . ISFRAC ( STACK ( 2 ))) THEN write ( stderr , * ) '  CNR Error' ELSE IF (( STACK ( 1 ) < 0.0D0 ) . OR . ( STACK ( 2 ) < 0.0D0 )) THEN write ( stderr , * ) '  CNR Error' ELSE IF ( STACK ( 2 ) < STACK ( 1 )) THEN write ( stderr , * ) '  CNR Error' ELSE ITMP = NINT ( STACK ( 1 )) ITMP2 = NINT ( STACK ( 2 )) LASTX = STACK ( 1 ) STACK ( 1 ) = CNR ( ITMP2 , ITMP ) CALL DROP_STACK ( 2 ) END IF CASE ( 2 ) IF ( ISFRAC ( real ( CSTACK ( 1 ), wp )) . OR . ISFRAC ( real ( CSTACK ( 2 ), wp ))) THEN write ( stderr , * ) '  CNR Error' ELSE IF ( real ( CSTACK ( 1 ), wp ) < 0.0D0 ) THEN write ( stderr , * ) '  CNR Error' ELSE IF ( real ( CSTACK ( 2 ), wp ) < 0.0D0 ) THEN write ( stderr , * ) '  CNR Error' ELSE IF (. not . isclose ( AIMAG ( CSTACK ( 1 )), 0._wp )) THEN write ( stderr , * ) '  CNR Error' ELSE IF (. not . isclose ( AIMAG ( CSTACK ( 2 )), 0._wp )) THEN write ( stderr , * ) '  CNR Error' ELSE IF ( real ( CSTACK ( 2 ), wp ) < real ( CSTACK ( 1 ), wp )) THEN write ( stderr , * ) '  CNR Error' ELSE ITMP = NINT ( real ( CSTACK ( 1 ), wp )) ITMP2 = NINT ( real ( CSTACK ( 2 ), wp )) TMP = CNR ( ITMP2 , ITMP ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , kind = wp ) CALL CDROP_STACK ( 2 ) END IF CASE ( 3 ) IF (( RDSTACK ( 1 ) /= 1 ). OR .( RDSTACK ( 2 ) /= 1 )) THEN write ( stderr , * ) '  CNR Error' ELSE IF (( RNSTACK ( 1 ) < 0 ) . OR . ( RNSTACK ( 2 ) < 0 )) THEN write ( stderr , * ) '  CNR Error' ELSE IF ( RNSTACK ( 2 ) < RNSTACK ( 1 )) THEN write ( stderr , * ) '  CNR Error' ELSE RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = int ( CNR ( RNSTACK ( 2 ), RNSTACK ( 1 ))) CALL RDROP_STACK ( 2 ) END IF END SELECT case ( 'COMPLEX' ) DOMAIN_MODE = 2 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CSTACK = CMPLX ( STACK , kind = wp ) CREG = CMPLX ( REG , kind = wp ) CLASTX = CMPLX ( LASTX , kind = wp ) CNN = CMPLX ( NN , kind = wp ) CSUMX = CMPLX ( SUMX , kind = wp ) CSUMX2 = CMPLX ( SUMX2 , kind = wp ) CSUMY = CMPLX ( SUMY , kind = wp ) CSUMY2 = CMPLX ( SUMY2 , kind = wp ) CSUMXY = CMPLX ( SUMXY , kind = wp ) CASE ( 3 ) CSTACK = CMPLX ( real ( RNSTACK , wp ) / real ( RDSTACK , wp ), kind = wp ) CREG = CMPLX ( real ( RNREG , wp ) / real ( RDREG , wp ), kind = wp ) CLASTX = CMPLX ( real ( RNLASTX , wp ) / real ( RDLASTX , wp ), kind = wp ) CNN = CMPLX ( real ( RNNN , wp ) / real ( RDNN , wp ), kind = wp ) CSUMX = CMPLX ( real ( RNSUMX , wp ) / real ( RDSUMX , wp ), kind = wp ) CSUMX2 = CMPLX ( real ( RNSUMX2 , wp ) / real ( RDSUMX2 , wp ), kind = wp ) CSUMY = CMPLX ( real ( RNSUMY , wp ) / real ( RDSUMY , wp ), kind = wp ) CSUMY2 = CMPLX ( real ( RNSUMY2 , wp ) / real ( RDSUMY2 , wp ), kind = wp ) CSUMXY = CMPLX ( real ( RNSUMXY , wp ) / real ( RDSUMXY , wp ), kind = wp ) END SELECT case ( 'CONJ' ) ! CONJ SELECT CASE ( DOMAIN_MODE ) CASE ( 2 ) CSTACK ( 1 ) = CONJG ( CSTACK ( 1 )) END SELECT case ( 'COS' ) ! COS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = COS ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = COS ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = COS ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'COSH' ) ! COSH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = COSH ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = COSH ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = COSH ( STACK ( 1 )) END SELECT case ( 'COT' ) ! COT SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = COT ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = COT ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = COT ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'COTH' ) ! COTH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = COTH ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = COTH ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = COTH ( STACK ( 1 )) END SELECT case ( 'COVERS' ) ! COVERS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = COVERS ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CCOVERS ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = COVERS ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'CRD' ) ! CRD SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = CRD ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CRD ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = CRD ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'CSC' ) ! CSC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = CSC ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSC ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = CSC ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'CSCH' ) ! CSCH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = CSCH ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSCH ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = CSCH ( STACK ( 1 )) END SELECT case ( 'CUBE' ) ! CUBE SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) ** 3 CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 1 ) ** 3 CASE ( 3 ) NUM = RNSTACK ( 1 ) DEN = RDSTACK ( 1 ) CALL RMUL ( NUM , DEN , NUM , DEN , NUM2 , DEN2 ) CALL RMUL ( NUM , DEN , NUM2 , DEN2 , NUM , DEN ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = DEN END SELECT case ( 'D>F' ) ! D>F SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) CALL DEC_TO_FRAC ( STACK ( 1 ), NUM , DEN , FRACTOL ) CALL DROP_STACK ( 1 ) CALL PUSH_STACK ( real ( NUM , wp )) CALL PUSH_STACK ( real ( DEN , wp )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CALL DEC_TO_FRAC ( real ( CSTACK ( 1 ), wp ), NUM , DEN , FRACTOL ) CALL DEC_TO_FRAC ( AIMAG ( CSTACK ( 1 )), NUM2 , DEN2 , FRACTOL ) CALL CDROP_STACK ( 1 ) CALL push_stack ( CMPLX ( real ( NUM , wp ), real ( NUM2 , wp ), wp )) CALL push_stack ( CMPLX ( real ( DEN , wp ), real ( DEN2 , wp ), wp )) END SELECT case ( 'D>R' ) ! D>R SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * PI / 18 0.0D0 CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 1 ) * PI / 18 0.0D0 CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * PI / 18 0.0D0 END SELECT case ( 'DEC' ) ! DEC BASE_MODE = 10 case ( 'DEFAULT' ) ! DEFAULT ANGLE_MODE = INITIAL_ANGLE_MODE SELECT CASE ( ANGLE_MODE ) CASE ( 1 ) ANGLE_FACTOR = PI / 18 0.0D0 CASE ( 2 ) ANGLE_FACTOR = 1._wp CASE ( 3 ) ANGLE_FACTOR = PI / 20 0.0D0 CASE ( 4 ) ANGLE_FACTOR = 2 * pi END SELECT DISP_MODE = INITIAL_DISP_MODE DISP_DIGITS = INITIAL_DISP_DIGITS DOMAIN_MODE = INITIAL_DOMAIN_MODE BASE_MODE = INITIAL_BASE_MODE FRACTION_MODE = INITIAL_FRACTION_MODE case ( 'DEG' ) ! DEG ANGLE_MODE = 1 ANGLE_FACTOR = PI / 18 0.0D0 case ( 'DIGAMMA' ) ! DIGAMMA SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = PSI ( STACK ( 1 )) CASE ( 2 ) write ( stderr , * ) ' DIGAMMA function not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = PSI ( STACK ( 1 )) END SELECT case ( 'DUP' ) ! DUP SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( STACK ( 1 )) CASE ( 2 ) CALL push_stack ( CSTACK ( 1 )) CASE ( 3 ) CALL push_stack ( RNSTACK ( 1 ), RDSTACK ( 1 )) END SELECT case ( 'ECHG' ) ! ECHG SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( ECHG ) CASE ( 2 ) CALL push_stack ( CMPLX ( ECHG , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( ECHG ) END SELECT case ( 'EPS0' ) ! EPS0 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( EPS0 ) CASE ( 2 ) CALL push_stack ( CMPLX ( EPS0 , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( EPS0 ) END SELECT case ( 'ERF' ) ! ERF SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = erf ( STACK ( 1 )) CASE ( 2 ) write ( stderr , * ) ' ERF function not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = erf ( STACK ( 1 )) END SELECT case ( 'ERFC' ) ! ERFC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = erfc ( STACK ( 1 )) CASE ( 2 ) write ( stderr , * ) ' ERFC function not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = erfc ( STACK ( 1 )) END SELECT case ( 'EULER' ) ! EULER SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( EULER ) CASE ( 2 ) CALL push_stack ( CMPLX ( EULER , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( EULER ) END SELECT case ( 'EXP' ) ! EXP SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = EXP ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = EXP ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = EXP ( STACK ( 1 )) END SELECT case ( 'EXSEC' ) ! EXSEC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = EXSEC ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CEXSEC ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = EXSEC ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'F>C' ) ! F>C SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = ( 5.0D0 / 9.0D0 ) * ( STACK ( 1 ) - 3 2.0D0 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ( 5.0D0 / 9.0D0 ) * ( CSTACK ( 1 ) - 3 2.0D0 ) CASE ( 3 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) CALL RSUB ( RNSTACK ( 1 ), RDSTACK ( 1 ), 32 , 1 , NUM , DEN ) CALL RMUL ( 5 , 9 , NUM , DEN , NUM2 , DEN2 ) RNSTACK ( 1 ) = NUM2 RDSTACK ( 1 ) = DEN2 END SELECT case ( 'FRAC' ) ! FRAC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = FRAC ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = FRAC ( CSTACK ( 1 )) CASE ( 3 ) CALL RFRAC ( RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = DEN END SELECT case ( 'FRACTOL' ) ! FRACTOL SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) FRACTOL = STACK ( 1 ) CALL DROP_STACK ( 1 ) CASE ( 2 ) FRACTOL = real ( CSTACK ( 1 ), wp ) CALL CDROP_STACK ( 1 ) CASE ( 3 ) FRACTOL = real ( RNSTACK ( 1 ), wp ) / real ( RDSTACK ( 1 ), wp ) CALL RDROP_STACK ( 1 ) END SELECT case ( 'G' ) ! G SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( G ) CASE ( 2 ) CALL push_stack ( CMPLX ( G , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( G ) END SELECT case ( 'GAL>L' ) ! GAL>L SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * L_PER_GAL CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 1 ) * L_PER_GAL CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * L_PER_GAL END SELECT case ( 'GAMMA' ) ! GAMMA SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ISINT ( STACK ( 1 )). AND .( STACK ( 1 ) <= 0._wp )) THEN write ( stderr , * ) '  GAMMA Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = gamma ( STACK ( 1 )) END IF CASE ( 2 ) IF ( isclose ( cstack ( 1 ), C0 )) THEN write ( stderr , * ) '  GAMMA Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CGAMMA ( CSTACK ( 1 )) END IF CASE ( 3 ) IF (( RDSTACK ( 1 ) == 1 ). AND .( RNSTACK ( 1 ) <= 0 )) THEN write ( stderr , * ) '  GAMMA Error' ELSE IF ( RDSTACK ( 1 ) == 1 ) THEN ITMP = RNSTACK ( 1 ) IF ( ITMP <= 0 ) THEN write ( stderr , * ) '  GAMMA Error' ELSE ITMP2 = 1 DO I = 2 , ITMP - 1 ITMP2 = ITMP2 * I END DO RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = ITMP2 RDSTACK ( 1 ) = 1 END IF ELSE CALL SWITCH_RAT_TO_REAL IF ( ISINT ( STACK ( 1 )). AND .( STACK ( 1 ) <= 0._wp )) THEN write ( stderr , * ) '  GAMMA Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = gamma ( STACK ( 1 )) END IF END IF END IF END SELECT case ( 'GCD' ) ! GCD SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ISFRAC ( STACK ( 1 )). OR . ISFRAC ( STACK ( 2 ))) THEN write ( stderr , * ) '  GCD Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = GCD ( NINT ( STACK ( 2 )), NINT ( STACK ( 1 ))) CALL DROP_STACK ( 2 ) END IF CASE ( 2 ) IF ( ISFRAC ( real ( CSTACK ( 1 ), wp )). OR . ISFRAC ( real ( CSTACK ( 2 ), wp )). OR . & . not . isclose ( AIMAG ( CSTACK ( 1 )), 0._wp ). OR .. not . isclose ( AIMAG ( CSTACK ( 2 )), 0._wp )) THEN write ( stderr , * ) '  GCD Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = GCD ( NINT ( real ( CSTACK ( 2 ), wp )), NINT ( real ( CSTACK ( 1 ), wp ))) CALL CDROP_STACK ( 2 ) END IF CASE ( 3 ) IF (( RDSTACK ( 1 ) /= 1 ). OR .( RDSTACK ( 2 ) /= 1 )) THEN write ( stderr , * ) '  GCD Error' ELSE RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 2 ) RNSTACK ( 1 ) = GCD ( RNSTACK ( 2 ), RNSTACK ( 1 )) RDSTACK ( 1 ) = 1 CALL RDROP_STACK ( 2 ) END IF END SELECT case ( 'GOLDEN' ) ! GOLDEN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( GOLDEN ) CASE ( 2 ) CALL push_stack ( CMPLX ( GOLDEN , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( GOLDEN ) END SELECT case ( 'GRAD' ) ! GRAD ANGLE_MODE = 3 ANGLE_FACTOR = PI / 20 0.0D0 case ( 'GRAV' ) ! GRAV SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( GRAV ) CASE ( 2 ) CALL push_stack ( CMPLX ( GRAV , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( GRAV ) END SELECT case ( 'H' ) ! H SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( H ) CASE ( 2 ) CALL push_stack ( CMPLX ( H , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( H ) END SELECT case ( 'H>HMS' ) ! H>HMS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL H2HMSD ( STACK ( 1 ), ITMP , ITMP2 , TMP ) LASTX = STACK ( 1 ) STACK ( 1 ) = real ( itmp , wp ) + 1.0D-2 * ITMP2 + 1.0D-4 * TMP CASE ( 2 ) IF (. not . isclose ( AIMAG ( CSTACK ( 1 )), 0._wp )) THEN write ( stderr , * ) '  H>HMS Error' ELSE CALL H2HMSD ( real ( CSTACK ( 1 ), wp ), ITMP , ITMP2 , TMP ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( real ( itmp , wp ) + 1.0D-2 * ITMP2 + 1.0D-4 * TMP , 0._wp , 8 ) END IF CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL H2HMSD ( STACK ( 1 ), ITMP , ITMP2 , TMP ) LASTX = STACK ( 1 ) STACK ( 1 ) = real ( itmp , wp ) + 1.0D-2 * ITMP2 + 1.0D-4 * TMP END SELECT case ( 'HBAR' ) ! HBAR SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( HBAR ) CASE ( 2 ) CALL push_stack ( CMPLX ( HBAR , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( HBAR ) END SELECT case ( 'HEX' ) ! HEX BASE_MODE = 16 case ( 'HMS>H' ) ! HMS>H SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) ITMP = INT ( STACK ( 1 )) ITMP2 = INT ( FRAC ( STACK ( 1 )) * 1.0D2 ) TMP = ( STACK ( 1 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP2 ) LASTX = STACK ( 1 ) STACK ( 1 ) = TMP2 CASE ( 2 ) IF (. not . isclose ( AIMAG ( CSTACK ( 1 )), 0._wp )) THEN write ( stderr , * ) '  HMS>H Error' ELSE ITMP = INT ( real ( CSTACK ( 1 ), wp )) ITMP2 = INT ( FRAC ( real ( CSTACK ( 1 ), wp )) * 1.0D2 ) TMP = ( real ( CSTACK ( 1 ), wp ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP2 , kind = wp ) END IF CASE ( 3 ) CALL SWITCH_RAT_TO_REAL ITMP = INT ( STACK ( 1 )) ITMP2 = INT ( FRAC ( STACK ( 1 )) * 1.0D2 ) TMP = ( STACK ( 1 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP2 ) LASTX = STACK ( 1 ) STACK ( 1 ) = TMP2 END SELECT case ( 'HMS+' ) ! HMS+ SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) ITMP = INT ( STACK ( 1 )) ITMP2 = INT ( FRAC ( STACK ( 1 )) * 1.0D2 ) TMP = ( STACK ( 1 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP2 ) ITMP = INT ( STACK ( 2 )) ITMP2 = INT ( FRAC ( STACK ( 2 )) * 1.0D2 ) TMP = ( STACK ( 2 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP3 ) CALL H2HMSD ( TMP2 + TMP3 , ITMP , ITMP2 , TMP ) LASTX = STACK ( 1 ) STACK ( 1 ) = real ( itmp , wp ) + 1.0D-2 * ITMP2 + 1.0D-4 * TMP CALL DROP_STACK ( 2 ) CASE ( 2 ) IF (. not . isclose ( AIMAG ( CSTACK ( 1 )), 0._wp )) THEN write ( stderr , * ) '  HMS+ Error' ELSE ITMP = INT ( CSTACK ( 1 )) ITMP2 = INT ( FRAC ( CSTACK ( 1 )) * 1.0e2_wp ) TMP = ( real ( CSTACK ( 1 ), wp ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP2 ) ITMP = INT ( CSTACK ( 2 )) ITMP2 = INT ( FRAC ( CSTACK ( 2 )) * 1.0e2_wp ) TMP = ( real ( CSTACK ( 2 ), wp ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP3 ) CALL H2HMSD ( TMP2 + TMP3 , ITMP , ITMP2 , TMP ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = real ( itmp , wp ) + 1.0D-2 * ITMP2 + 1.0D-4 * TMP CALL CDROP_STACK ( 2 ) END IF CASE ( 3 ) CALL SWITCH_RAT_TO_REAL ITMP = INT ( STACK ( 1 )) ITMP2 = INT ( FRAC ( STACK ( 1 )) * 1.0D2 ) TMP = ( STACK ( 1 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP2 ) ITMP = INT ( STACK ( 2 )) ITMP2 = INT ( FRAC ( STACK ( 2 )) * 1.0D2 ) TMP = ( STACK ( 2 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP3 ) CALL H2HMSD ( TMP2 + TMP3 , ITMP , ITMP2 , TMP ) LASTX = STACK ( 1 ) STACK ( 1 ) = real ( itmp , wp ) + 1.0D-2 * ITMP2 + 1.0D-4 * TMP CALL DROP_STACK ( 2 ) END SELECT case ( 'HMS-' ) ! HMS- SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) ITMP = INT ( STACK ( 1 )) ITMP2 = INT ( FRAC ( STACK ( 1 )) * 1.0D2 ) TMP = ( STACK ( 1 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP2 ) ITMP = INT ( STACK ( 2 )) ITMP2 = INT ( FRAC ( STACK ( 2 )) * 1.0D2 ) TMP = ( STACK ( 2 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP3 ) CALL H2HMSD ( TMP3 - TMP2 , ITMP , ITMP2 , TMP ) LASTX = STACK ( 1 ) STACK ( 1 ) = real ( itmp , wp ) + 1.0D-2 * ITMP2 + 1.0D-4 * TMP CALL DROP_STACK ( 2 ) CASE ( 2 ) IF (. not . isclose ( AIMAG ( CSTACK ( 1 )), 0._wp )) THEN write ( stderr , * ) '  HMS- Error' ELSE ITMP = INT ( CSTACK ( 1 )) ITMP2 = INT ( FRAC ( CSTACK ( 1 )) * 1.0D2 ) TMP = ( real ( CSTACK ( 1 ), wp ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP2 ) ITMP = INT ( CSTACK ( 2 )) ITMP2 = INT ( FRAC ( CSTACK ( 2 )) * 1.0D2 ) TMP = ( real ( CSTACK ( 2 ), wp ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP3 ) CALL H2HMSD ( TMP3 - TMP2 , ITMP , ITMP2 , TMP ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = real ( itmp , wp ) + 1.0D-2 * ITMP2 + 1.0D-4 * TMP CALL CDROP_STACK ( 2 ) END IF CASE ( 3 ) CALL SWITCH_RAT_TO_REAL ITMP = INT ( STACK ( 1 )) ITMP2 = INT ( FRAC ( STACK ( 1 )) * 1.0D2 ) TMP = ( STACK ( 1 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP2 ) ITMP = INT ( STACK ( 2 )) ITMP2 = INT ( FRAC ( STACK ( 2 )) * 1.0D2 ) TMP = ( STACK ( 2 ) - ITMP - ITMP2 * 1.0D-2 ) * 1.0D4 CALL HMS2H ( ITMP , ITMP2 , TMP , TMP3 ) CALL H2HMSD ( TMP3 - TMP2 , ITMP , ITMP2 , TMP ) LASTX = STACK ( 1 ) STACK ( 1 ) = real ( itmp , wp ) + 1.0D-2 * ITMP2 + 1.0D-4 * TMP CALL DROP_STACK ( 2 ) END SELECT case ( 'HAV' ) SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = HAV ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = HAV ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = HAV ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'HYPOT' ) SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = hypot ( STACK ( 1 ), STACK ( 2 )) CALL DROP_STACK ( 2 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = SQRT ( CSTACK ( 1 ) ** 2 + CSTACK ( 2 ) ** 2 ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) NUM = RNSTACK ( 1 ) DEN = RDSTACK ( 1 ) NUM2 = RNSTACK ( 2 ) DEN2 = RDSTACK ( 2 ) CALL RMUL ( NUM , DEN , NUM , DEN , NUM3 , DEN3 ) CALL RMUL ( NUM2 , DEN2 , NUM2 , DEN2 , NUM4 , DEN4 ) CALL RADD ( NUM3 , DEN3 , NUM4 , DEN4 , NUM , DEN ) TMP = SQRT ( real ( NUM , wp )) TMP2 = SQRT ( real ( DEN , wp )) IF ( ISFRAC ( TMP ). OR . ISFRAC ( TMP2 )) THEN CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = SQRT ( STACK ( 1 ) ** 2 + STACK ( 2 ) ** 2 ) CALL DROP_STACK ( 2 ) ELSE RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NINT ( SQRT ( real ( NUM , wp ))) RDSTACK ( 1 ) = NINT ( SQRT ( real ( DEN , wp ))) CALL RDROP_STACK ( 2 ) END IF END SELECT case ( 'HYPOT3' ) ! HYPOT3 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = SQRT ( STACK ( 1 ) ** 2 + STACK ( 2 ) ** 2 + STACK ( 3 ) ** 2 ) CALL DROP_STACK ( 3 ) CALL DROP_STACK ( 2 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = SQRT ( CSTACK ( 1 ) ** 2 + CSTACK ( 2 ) ** 2 + CSTACK ( 3 ) ** 2 ) CALL CDROP_STACK ( 3 ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = SQRT ( STACK ( 1 ) ** 2 + STACK ( 2 ) ** 2 + STACK ( 3 ) ** 2 ) CALL DROP_STACK ( 3 ) CALL DROP_STACK ( 2 ) END SELECT case ( 'I' ) ! I SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) write ( stderr , * ) ' i not available in REAL mode' CASE ( 2 ) CALL push_stack ( II ) CASE ( 3 ) write ( stderr , * ) ' i not available in RATIONAL mode' END SELECT case ( 'IM' ) ! IM SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = 0._wp CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( AIMAG ( CSTACK ( 1 )), kind = wp ) CASE ( 3 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = 0 RDSTACK ( 1 ) = 1 END SELECT case ( 'IMPROPER' ) ! IMPROPER FRACTION_MODE = 1 case ( 'IN>CM' ) ! IN>CM SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * CM_PER_IN CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 1 ) * CM_PER_IN CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * CM_PER_IN END SELECT case ( 'INT' ) ! INT SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = AINT ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CINT ( CSTACK ( 1 )) CASE ( 3 ) NUM = RINT ( RNSTACK ( 1 ), RDSTACK ( 1 )) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = 1 END SELECT case ( 'INT/' ) ! INT/ SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( isclose ( stack ( 1 ), 0._wp )) THEN write ( stderr , * ) '  INT/ Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = AINT ( STACK ( 2 ) / STACK ( 1 )) CALL DROP_STACK ( 2 ) END IF CASE ( 2 ) IF ( isclose ( cstack ( 1 ), C0 )) THEN write ( stderr , * ) '  INT/ Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CINT ( CSTACK ( 2 ) / CSTACK ( 1 )) CALL CDROP_STACK ( 2 ) END IF CASE ( 3 ) IF ( RNSTACK ( 1 ) == 0 ) THEN write ( stderr , * ) '  INT/ Error' ELSE RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = RNSTACK ( 1 ) / RDSTACK ( 1 ) RDSTACK ( 1 ) = 1 CALL RDROP_STACK ( 2 ) END IF END SELECT case ( 'KB' ) ! KB SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( KB ) CASE ( 2 ) CALL push_stack ( CMPLX ( KB , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( KB ) END SELECT case ( 'KEPLER' ) ! KEPLER SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = KEPLER ( STACK ( 2 ) * ANGLE_FACTOR , STACK ( 1 )) / ANGLE_FACTOR CASE ( 2 ) TMP = KEPLER ( real ( CSTACK ( 2 ), wp ) * ANGLE_FACTOR , real ( CSTACK ( 1 ), wp )) / & ANGLE_FACTOR CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , kind = wp ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = KEPLER ( STACK ( 2 ) * ANGLE_FACTOR , STACK ( 1 )) / ANGLE_FACTOR END SELECT case ( 'KG>LB' ) ! KG>LB SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) / KG_PER_LB CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 1 ) / KG_PER_LB CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) / KG_PER_LB END SELECT case ( 'JINC' ) SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = jinc ( STACK ( 1 )) CASE ( 2 ) write ( stderr , * ) '  Error:  JINC not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = jinc ( STACK ( 1 )) END SELECT case ( 'L>GAL' ) ! L>GAL SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) / L_PER_GAL CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 1 ) / L_PER_GAL CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) / L_PER_GAL END SELECT case ( 'LASTX' ) ! LASTX SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( LASTX ) CASE ( 2 ) CALL push_stack ( CLASTX ) CASE ( 3 ) CALL push_stack ( RNLASTX , RDLASTX ) END SELECT case ( 'LB>KG' ) ! LB>KG SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * KG_PER_LB CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 1 ) * KG_PER_LB CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * KG_PER_LB END SELECT case ( 'LCM' ) ! LCM SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ISFRAC ( STACK ( 1 )). OR . ISFRAC ( STACK ( 2 ))) THEN write ( stderr , * ) '  LCM Error' ELSE IF ( isclose ( STACK ( 1 ), 0._wp ). AND . isclose ( STACK ( 2 ), 0._wp )) THEN write ( stderr , * ) '  LCM Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = LCM ( NINT ( STACK ( 2 )), NINT ( STACK ( 1 ))) CALL DROP_STACK ( 2 ) END IF CASE ( 2 ) IF ( ISFRAC ( real ( CSTACK ( 1 ), wp )). OR . ISFRAC ( real ( CSTACK ( 2 ), wp )). OR . & . not . isclose ( AIMAG ( CSTACK ( 1 )), 0._wp ). OR .. not . isclose ( AIMAG ( CSTACK ( 2 )), 0._wp )) THEN write ( stderr , * ) '  LCM Error' ELSEIF ( isclose ( cstack ( 1 ), C0 ) . AND . isclose ( cstack ( 2 ), C0 )) THEN write ( stderr , * ) '  LCM Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = LCM ( NINT ( real ( CSTACK ( 2 ), wp )), NINT ( real ( CSTACK ( 1 ), wp ))) CALL CDROP_STACK ( 2 ) END IF CASE ( 3 ) IF (( RDSTACK ( 1 ) /= 1 ). OR .( RDSTACK ( 2 ) /= 1 )) THEN write ( stderr , * ) '  LCM Error' ELSE IF (( RNSTACK ( 1 ) == 0 ). AND .( RNSTACK ( 2 ) == 0 )) THEN write ( stderr , * ) '  LCM Error' ELSE RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 2 ) RNSTACK ( 1 ) = LCM ( RNSTACK ( 2 ), RNSTACK ( 1 )) RDSTACK ( 1 ) = 1 CALL RDROP_STACK ( 2 ) END IF END SELECT case ( 'LN' ) ! LN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  LN Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = LOG ( STACK ( 1 )) END IF CASE ( 2 ) IF ( isclose ( cstack ( 1 ), C0 )) THEN write ( stderr , * ) '  LN Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = LOG ( CSTACK ( 1 )) END IF CASE ( 3 ) CALL SWITCH_RAT_TO_REAL IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  LN Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = LOG ( STACK ( 1 )) END IF END SELECT case ( 'LOG' ) ! LOG SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  LOG Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = LOG10 ( STACK ( 1 )) END IF CASE ( 2 ) IF ( isclose ( cstack ( 1 ), C0 )) THEN write ( stderr , * ) '  LOG Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CLOG10 ( CSTACK ( 1 )) END IF CASE ( 3 ) CALL SWITCH_RAT_TO_REAL IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  LOG Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = LOG10 ( STACK ( 1 )) END IF END SELECT case ( 'LOG2' ) ! LOG2 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  LOG2 Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = LOG ( STACK ( 1 )) / log ( 2._wp ) END IF CASE ( 2 ) IF ( isclose ( cstack ( 1 ), C0 )) THEN write ( stderr , * ) '  LOG2 Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = LOG ( CSTACK ( 1 )) / log ( 2._wp ) END IF CASE ( 3 ) CALL SWITCH_RAT_TO_REAL IF ( STACK ( 1 ) <= 0._wp ) THEN write ( stderr , * ) '  LOG2 Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = LOG ( STACK ( 1 )) / log ( 2._wp ) END IF END SELECT case ( 'LR' ) ! LR SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( NN <= 1._wp ) THEN write ( stderr , * ) '  LR Error' ELSE CALL LINREG ( TMPM , TMPB , TMPR ) CALL PUSH_STACK ( TMPM ) CALL PUSH_STACK ( TMPB ) END IF CASE ( 2 ) IF ( real ( CNN , wp ) <= 1._wp ) THEN write ( stderr , * ) '  LR Error' ELSE CALL CLINREG ( CTMPM , CTMPB , CTMPR ) CALL push_stack ( CTMPM ) CALL push_stack ( CTMPB ) END IF CASE ( 3 ) IF ( RNNN <= 1 ) THEN write ( stderr , * ) '  LR Error' ELSE CALL RLINREG ( NUMM , DENM , NUMB , DENB , TMPR ) CALL push_stack ( NUMM , DENM ) CALL push_stack ( NUMB , DENB ) END IF END SELECT case ( 'ME' ) ! ME SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( ME ) CASE ( 2 ) CALL push_stack ( CMPLX ( ME , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( ME ) END SELECT case ( 'MIXED' ) ! MIXED FRACTION_MODE = 2 case ( 'MN' ) ! MN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( MN ) CASE ( 2 ) CALL push_stack ( CMPLX ( MN , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( MN ) END SELECT case ( 'MOD' ) ! MOD SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( isclose ( stack ( 1 ), 0._wp )) THEN write ( stderr , * ) '  MOD Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = MOD ( STACK ( 2 ), STACK ( 1 )) CALL DROP_STACK ( 2 ) END IF CASE ( 2 ) IF ( isclose ( cstack ( 1 ), C0 )) THEN write ( stderr , * ) '  MOD Error' ELSE CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMOD ( CSTACK ( 2 ), CSTACK ( 1 )) CALL CDROP_STACK ( 2 ) END IF CASE ( 3 ) IF ( RNSTACK ( 1 ) == 0 ) THEN write ( stderr , * ) '  MOD Error' ELSE NUM = RNSTACK ( 1 ) DEN = RDSTACK ( 1 ) NUM2 = RNSTACK ( 2 ) DEN2 = RDSTACK ( 2 ) CALL RMOD ( NUM2 , DEN2 , NUM , DEN , ITMP , ITMP2 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = ITMP RDSTACK ( 1 ) = ITMP2 CALL RDROP_STACK ( 2 ) END IF END SELECT case ( 'MODES' ) ! MODES WRITE ( UNIT =* , FMT = '()' ) SELECT CASE ( ANGLE_MODE ) CASE ( 1 ) print * , '  Angles:     DEG' CASE ( 2 ) print * , '  Angles:     RAD' CASE ( 3 ) print * , '  Angles:     GRAD' CASE ( 4 ) print * , '  Angles:     REV' END SELECT SELECT CASE ( DISP_MODE ) CASE ( 1 ) print '(A,I0)' , '  Display:    FIX ' , DISP_DIGITS CASE ( 2 ) print '(A,I0)' , '  Display:    SCI ' , DISP_DIGITS CASE ( 3 ) print '(A,I0)' , '  Display:    ENG ' , DISP_DIGITS CASE ( 4 ) print * , '  Display:    ALL ' END SELECT SELECT CASE ( BASE_MODE ) CASE ( 2 ) print * , '  Base:       BIN' CASE ( 8 ) print * , '  Base:       OCT' CASE ( 10 ) print * , '  Base:       DEC' CASE ( 16 ) print * , '  Base:       HEX' END SELECT SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) print * , '  Domain:     REAL' CASE ( 2 ) print * , '  Domain:     COMPLEX' CASE ( 3 ) print * , '  Domain:     RATIONAL' END SELECT SELECT CASE ( FRACTION_MODE ) CASE ( 1 ) print * , '  Fractions:  IMPROPER' CASE ( 2 ) print * , '  Fractions:  MIXED' END SELECT print * , ' ' case ( 'MP' ) ! MP SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( MP ) CASE ( 2 ) CALL push_stack ( CMPLX ( MP , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( MP ) END SELECT case ( 'MU0' ) ! MU0 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( MU0 ) CASE ( 2 ) CALL push_stack ( CMPLX ( MU0 , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( MU0 ) END SELECT case ( 'MUB' ) ! MUB SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( MUB ) CASE ( 2 ) CALL push_stack ( CMPLX ( MUB , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( MUB ) END SELECT case ( 'MUN' ) ! MUN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( MUN ) CASE ( 2 ) CALL push_stack ( CMPLX ( MUN , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( MUN ) END SELECT case ( 'N' ) ! N SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( NN ) CASE ( 2 ) CALL push_stack ( CNN ) CASE ( 3 ) CALL push_stack ( RNNN , RDNN ) END SELECT case ( 'NA' ) ! NA SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( NA ) CASE ( 2 ) CALL push_stack ( CMPLX ( NA , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( NA ) END SELECT case ( 'NOT' ) ! NOT SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = NOT ( INT ( STACK ( 1 ))) CASE ( 2 ) TMP = NOT ( INT ( real ( CSTACK ( 1 ), wp ))) TMP2 = NOT ( INT ( AIMAG ( CSTACK ( 1 )))) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , TMP2 , wp ) CASE ( 3 ) ITMP = RNSTACK ( 1 ) / RDSTACK ( 1 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NOT ( ITMP ) RDSTACK ( 1 ) = 1 END SELECT case ( 'OCT' ) ! OCT BASE_MODE = 8 case ( 'OR' ) ! OR SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = IOR ( INT ( STACK ( 2 )), INT ( STACK ( 1 ))) CALL DROP_STACK ( 2 ) CASE ( 2 ) TMP = IOR ( INT ( real ( CSTACK ( 2 ), wp )), INT ( real ( CSTACK ( 1 ), wp ))) TMP2 = IOR ( INT ( AIMAG ( CSTACK ( 2 ))), INT ( AIMAG ( CSTACK ( 1 )))) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , TMP2 , wp ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) ITMP = RNSTACK ( 1 ) / RDSTACK ( 1 ) ITMP2 = RNSTACK ( 2 ) / RDSTACK ( 2 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = IOR ( ITMP2 , ITMP ) RDSTACK ( 1 ) = 1 CALL RDROP_STACK ( 2 ) END SELECT case ( 'P>R' ) ! P>R SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) TMP = STACK ( 1 ) * COS ( STACK ( 2 ) * ANGLE_FACTOR ) TMP2 = STACK ( 1 ) * SIN ( STACK ( 2 ) * ANGLE_FACTOR ) LASTX = STACK ( 1 ) STACK ( 1 ) = TMP STACK ( 2 ) = TMP2 CASE ( 2 ) TMP = real ( CSTACK ( 1 ), wp ) * COS ( AIMAG ( CSTACK ( 1 )) * ANGLE_FACTOR ) TMP2 = real ( CSTACK ( 1 ), wp ) * SIN ( AIMAG ( CSTACK ( 1 )) * ANGLE_FACTOR ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , TMP2 , wp ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL TMP = STACK ( 1 ) * COS ( STACK ( 2 ) * ANGLE_FACTOR ) TMP2 = STACK ( 1 ) * SIN ( STACK ( 2 ) * ANGLE_FACTOR ) LASTX = STACK ( 1 ) STACK ( 1 ) = TMP STACK ( 2 ) = TMP2 END SELECT case ( 'PI' ) ! PI SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( PI ) CASE ( 2 ) CALL push_stack ( CMPLX ( PI , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( PI ) END SELECT case ( 'PNR' ) ! PNR SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF (( RDSTACK ( 1 ) /= 1 ). OR .( RDSTACK ( 2 ) /= 1 )) THEN write ( stderr , * ) '  PNR Error' ELSE IF (( RNSTACK ( 1 ) < 0 ) . OR . ( RNSTACK ( 2 ) < 0 )) THEN write ( stderr , * ) '  PNR Error' ELSE IF ( RNSTACK ( 2 ) < RNSTACK ( 1 )) THEN write ( stderr , * ) '  PNR Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = PNR ( ITMP2 , ITMP ) CALL DROP_STACK ( 2 ) END IF CASE ( 2 ) IF ( ISFRAC ( real ( CSTACK ( 1 ), wp )) . OR . ISFRAC ( real ( CSTACK ( 2 ), wp ))) THEN write ( stderr , * ) '  PNR Error' ELSE IF ( real ( CSTACK ( 1 ), wp ) < 0.0D0 ) THEN write ( stderr , * ) '  PNR Error' ELSE IF ( real ( CSTACK ( 2 ), wp ) < 0.0D0 ) THEN write ( stderr , * ) '  PNR Error' ELSE IF (. not . isclose ( AIMAG ( CSTACK ( 1 )), 0._wp )) THEN write ( stderr , * ) '  PNR Error' ELSE IF (. not . isclose ( AIMAG ( CSTACK ( 2 )), 0._wp )) THEN write ( stderr , * ) '  PNR Error' ELSE IF ( real ( CSTACK ( 2 ), wp ) < real ( CSTACK ( 1 ), wp )) THEN write ( stderr , * ) '  PNR Error' ELSE ITMP = NINT ( real ( CSTACK ( 1 ), wp )) ITMP2 = NINT ( real ( CSTACK ( 2 ), wp )) TMP = PNR ( ITMP2 , ITMP ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , kind = wp ) CALL CDROP_STACK ( 2 ) END IF CASE ( 3 ) IF ( ISFRAC ( STACK ( 1 )) . OR . ISFRAC ( STACK ( 2 ))) THEN write ( stderr , * ) '  PNR Error' ELSE IF (( STACK ( 1 ) < 0.0D0 ) . OR . ( STACK ( 2 ) < 0.0D0 )) THEN write ( stderr , * ) '  PNR Error' ELSE IF ( STACK ( 2 ) < STACK ( 1 )) THEN write ( stderr , * ) '  PNR Error' ELSE RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = int ( PNR ( RNSTACK ( 2 ), RNSTACK ( 1 ))) CALL RDROP_STACK ( 2 ) END IF END SELECT case ( 'PR' ) ! PR WRITE ( UNIT =* , FMT = '()' ) DO I = 0 , REG_SIZE - 1 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PRINTX ( REG ( I ), NUMSTR ) CASE ( 2 ) CALL printx ( CREG ( I ), NUMSTR ) CASE ( 3 ) CALL printx ( RNREG ( I ), RDREG ( I ), NUMSTR ) END SELECT WRITE ( UNIT =* , FMT = '(1X,I3,A)' ) I , ':  ' // TRIM ( NUMSTR ) END DO print * , ' ' case ( 'PS' ) ! PS WRITE ( UNIT =* , FMT = '()' ) DO I = STACK_SIZE , 1 , - 1 SELECT CASE ( I ) CASE ( 1 ) REGNAME = ' X' CASE ( 2 ) REGNAME = ' Y' CASE ( 3 ) REGNAME = ' Z' CASE ( 4 ) REGNAME = ' T' CASE DEFAULT WRITE ( UNIT = REGNAME , FMT = '(I2)' ) I END SELECT SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PRINTX ( STACK ( I ), NUMSTR ) CASE ( 2 ) CALL printx ( CSTACK ( I ), NUMSTR ) CASE ( 3 ) CALL printx ( RNSTACK ( I ), RDSTACK ( I ), NUMSTR ) END SELECT WRITE ( UNIT =* , FMT = '(2X,A)' ) REGNAME // ':  ' // TRIM ( NUMSTR ) END DO print * , ' ' case ( 'PSUMS' ) ! PSUMS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) WRITE ( UNIT =* , FMT = '()' ) CALL PRINTX ( NN , NUMSTR ) print * , '  N:   ' // TRIM ( NUMSTR ) CALL PRINTX ( SUMX , NUMSTR ) print * , '  X:   ' // TRIM ( NUMSTR ) CALL PRINTX ( SUMX2 , NUMSTR ) print * , '  X2:  ' // TRIM ( NUMSTR ) CALL PRINTX ( SUMY , NUMSTR ) print * , '  Y:   ' // TRIM ( NUMSTR ) CALL PRINTX ( SUMY2 , NUMSTR ) print * , '  Y2:  ' // TRIM ( NUMSTR ) CALL PRINTX ( SUMXY , NUMSTR ) print * , '  XY:  ' // TRIM ( NUMSTR ) print * , ' ' CASE ( 2 ) WRITE ( UNIT =* , FMT = '()' ) CALL printx ( CNN , NUMSTR ) print * , '  N:   ' // TRIM ( NUMSTR ) CALL printx ( CSUMX , NUMSTR ) print * , '  X:   ' // TRIM ( NUMSTR ) CALL printx ( CSUMX2 , NUMSTR ) print * , '  X2:  ' // TRIM ( NUMSTR ) CALL printx ( CSUMY , NUMSTR ) print * , '  Y:   ' // TRIM ( NUMSTR ) CALL printx ( CSUMY2 , NUMSTR ) print * , '  Y2:  ' // TRIM ( NUMSTR ) CALL printx ( CSUMXY , NUMSTR ) print * , '  XY:  ' // TRIM ( NUMSTR ) print * , ' ' CASE ( 3 ) WRITE ( UNIT =* , FMT = '()' ) CALL printx ( RNNN , RDNN , NUMSTR ) print * , '  N:   ' // TRIM ( NUMSTR ) CALL printx ( RNSUMX , RDSUMX , NUMSTR ) print * , '  X:   ' // TRIM ( NUMSTR ) CALL printx ( RNSUMX2 , RDSUMX2 , NUMSTR ) print * , '  X2:  ' // TRIM ( NUMSTR ) CALL printx ( RNSUMY , RDSUMY , NUMSTR ) print * , '  Y:   ' // TRIM ( NUMSTR ) CALL printx ( RNSUMY2 , RDSUMY2 , NUMSTR ) print * , '  Y2:  ' // TRIM ( NUMSTR ) CALL printx ( RNSUMXY , RDSUMXY , NUMSTR ) print * , '  XY:  ' // TRIM ( NUMSTR ) print * , ' ' END SELECT case ( 'R' ) ! R SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) stack = cshift ( stack , 1 ) CASE ( 2 ) cstack = cshift ( cstack , 1 ) CASE ( 3 ) rnstack = cshift ( rnstack , 1 ) rdstack = cshift ( rdstack , 1 ) END SELECT case ( 'D' ) ! D SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) call drop_stack ( 1 ) CASE ( 2 ) call cdrop_stack ( 1 ) CASE ( 3 ) call rdrop_stack ( 1 ) END SELECT case ( 'R>D' ) ! R>D SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * 18 0.0D0 / PI CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 1 ) * 18 0.0D0 / PI CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) * 18 0.0D0 / PI END SELECT case ( 'R>P' ) ! R>P SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) TMP = SQRT (( STACK ( 1 )) ** 2 + ( STACK ( 2 )) ** 2 ) TMP2 = ATAN2 ( STACK ( 2 ), STACK ( 1 )) / ANGLE_FACTOR LASTX = STACK ( 1 ) STACK ( 1 ) = TMP STACK ( 2 ) = TMP2 CASE ( 2 ) TMP = ABS ( CSTACK ( 1 )) TMP2 = ATAN2 ( AIMAG ( CSTACK ( 1 )), real ( CSTACK ( 1 ), wp )) / ANGLE_FACTOR CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , TMP2 , wp ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL TMP = SQRT (( STACK ( 1 )) ** 2 + ( STACK ( 2 )) ** 2 ) TMP2 = ATAN2 ( STACK ( 2 ), STACK ( 1 )) / ANGLE_FACTOR LASTX = STACK ( 1 ) STACK ( 1 ) = TMP STACK ( 2 ) = TMP2 END SELECT case ( 'RAD' ) ! RAD ANGLE_MODE = 2 ANGLE_FACTOR = 1._wp case ( 'RAND' ) ! RAND SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL RANDOM_NUMBER ( TMP ) CALL PUSH_STACK ( TMP ) CASE ( 2 ) CALL RANDOM_NUMBER ( TMP ) CALL RANDOM_NUMBER ( TMP2 ) CALL push_stack ( CMPLX ( TMP , TMP2 , wp )) CASE ( 3 ) CALL RANDOM_NUMBER ( TMP ) CALL DEC_TO_FRAC ( TMP , NUM , DEN , FRACTOL ) CALL push_stack ( NUM , DEN ) END SELECT case ( 'RATIONAL' ) ! RATIONAL SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) DOMAIN_MODE = 3 DO I = 1 , STACK_SIZE CALL DEC_TO_FRAC ( STACK ( I ), ITMP , ITMP2 , FRACTOL ) RNSTACK ( I ) = ITMP RDSTACK ( I ) = ITMP2 END DO DO I = 0 , REG_SIZE - 1 CALL DEC_TO_FRAC ( REG ( I ), ITMP , ITMP2 , FRACTOL ) RNREG ( I ) = ITMP RDREG ( I ) = ITMP2 END DO CALL DEC_TO_FRAC ( LASTX , ITMP , ITMP2 , FRACTOL ) RNLASTX = ITMP RDLASTX = ITMP2 CALL DEC_TO_FRAC ( NN , ITMP , ITMP2 , FRACTOL ) RNNN = ITMP RDNN = ITMP2 CALL DEC_TO_FRAC ( SUMX , ITMP , ITMP2 , FRACTOL ) RNSUMX = ITMP RDSUMX = ITMP2 CALL DEC_TO_FRAC ( SUMX2 , ITMP , ITMP2 , FRACTOL ) RNSUMX2 = ITMP RDSUMX2 = ITMP2 CALL DEC_TO_FRAC ( SUMY , ITMP , ITMP2 , FRACTOL ) RNSUMY = ITMP RDSUMY = ITMP2 CALL DEC_TO_FRAC ( SUMY2 , ITMP , ITMP2 , FRACTOL ) RNSUMY2 = ITMP RDSUMY2 = ITMP2 CALL DEC_TO_FRAC ( SUMXY , ITMP , ITMP2 , FRACTOL ) RNSUMXY = ITMP RDSUMXY = ITMP2 CASE ( 2 ) DOMAIN_MODE = 3 DO I = 1 , STACK_SIZE CALL DEC_TO_FRAC ( real ( CSTACK ( I ), wp ), ITMP , ITMP2 , FRACTOL ) RNSTACK ( I ) = ITMP RDSTACK ( I ) = ITMP2 END DO DO I = 0 , REG_SIZE - 1 CALL DEC_TO_FRAC ( real ( CREG ( I ), wp ), ITMP , ITMP2 , FRACTOL ) RNREG ( I ) = ITMP RDREG ( I ) = ITMP2 END DO CALL DEC_TO_FRAC ( real ( CLASTX , wp ), ITMP , ITMP2 , FRACTOL ) RNLASTX = ITMP RDLASTX = ITMP2 CALL DEC_TO_FRAC ( real ( CNN , wp ), ITMP , ITMP2 , FRACTOL ) RNNN = ITMP RDNN = ITMP2 CALL DEC_TO_FRAC ( real ( CSUMX , wp ), ITMP , ITMP2 , FRACTOL ) RNSUMX = ITMP RDSUMX = ITMP2 CALL DEC_TO_FRAC ( real ( CSUMX2 , wp ), ITMP , ITMP2 , FRACTOL ) RNSUMX2 = ITMP RDSUMX2 = ITMP2 CALL DEC_TO_FRAC ( real ( CSUMY , wp ), ITMP , ITMP2 , FRACTOL ) RNSUMY = ITMP RDSUMY = ITMP2 CALL DEC_TO_FRAC ( real ( CSUMY2 , wp ), ITMP , ITMP2 , FRACTOL ) RNSUMY2 = ITMP RDSUMY2 = ITMP2 CALL DEC_TO_FRAC ( real ( CSUMXY , wp ), ITMP , ITMP2 , FRACTOL ) RNSUMXY = ITMP RDSUMXY = ITMP2 END SELECT case ( 'RCORR' ) ! RCORR SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( NN <= 1._wp ) THEN write ( stderr , * ) '  RCORR Error' ELSE CALL LINREG ( TMPM , TMPB , TMPR ) CALL PUSH_STACK ( TMPR ) END IF CASE ( 2 ) IF ( real ( CNN , wp ) <= 1._wp ) THEN write ( stderr , * ) '  RCORR Error' ELSE CALL CLINREG ( CTMPM , CTMPB , CTMPR ) CALL push_stack ( CTMPR ) END IF CASE ( 3 ) IF ( RNNN <= 1 ) THEN write ( stderr , * ) '  RCORR Error' ELSE CALL SWITCH_RAT_TO_REAL CALL LINREG ( TMPM , TMPB , TMPR ) CALL PUSH_STACK ( TMPR ) END IF END SELECT case ( 'RE' ) ! RE SELECT CASE ( DOMAIN_MODE ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( real ( CSTACK ( 1 ), wp ), kind = wp ) END SELECT case ( 'REAL' ) ! REAL SELECT CASE ( DOMAIN_MODE ) CASE ( 2 ) DOMAIN_MODE = 1 STACK = real ( CSTACK , wp ) REG = real ( CREG , wp ) LASTX = real ( CLASTX , wp ) NN = real ( CNN , wp ) SUMX = real ( CSUMX , wp ) SUMX2 = real ( CSUMX2 , wp ) SUMY = real ( CSUMY , wp ) SUMY2 = real ( CSUMY2 , wp ) SUMXY = real ( CSUMXY , wp ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL END SELECT case ( 'REARTH' ) ! REARTH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( REARTH ) CASE ( 2 ) CALL push_stack ( CMPLX ( REARTH , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( REARTH ) END SELECT case ( 'REDUCE' ) ! REDUCE SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) TMP = STACK ( 1 ) CALL DROP_STACK ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = REDUCE ( STACK ( 1 ) * ANGLE_FACTOR , TMP * ANGLE_FACTOR ) / ANGLE_FACTOR CASE ( 2 ) TMP = real ( CSTACK ( 1 ), wp ) CALL CDROP_STACK ( 1 ) CLASTX = CSTACK ( 1 ) TMP2 = REDUCE ( real ( CSTACK ( 1 ), wp ) * ANGLE_FACTOR , TMP * ANGLE_FACTOR ) / ANGLE_FACTOR CSTACK ( 1 ) = CMPLX ( TMP2 , kind = wp ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL TMP = STACK ( 1 ) CALL DROP_STACK ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = REDUCE ( STACK ( 1 ) * ANGLE_FACTOR , TMP * ANGLE_FACTOR ) / ANGLE_FACTOR END SELECT case ( 'RESET' ) ! RESET STACK = 0._wp REG = 0._wp LASTX = 0._wp NN = 0._wp SUMX = 0._wp SUMX2 = 0._wp SUMY = 0._wp SUMY2 = 0._wp SUMXY = 0._wp CSTACK = ( 0._wp , 0._wp ) CREG = ( 0._wp , 0._wp ) CLASTX = ( 0._wp , 0._wp ) CNN = ( 0._wp , 0._wp ) CSUMX = ( 0._wp , 0._wp ) CSUMX2 = ( 0._wp , 0._wp ) CSUMY = ( 0._wp , 0._wp ) CSUMY2 = ( 0._wp , 0._wp ) CSUMXY = ( 0._wp , 0._wp ) RNSTACK = 0 ; RDSTACK = 1 RNREG = 0 ; RDREG = 1 RNLASTX = 0 ; RDLASTX = 1 RNNN = 0 ; RDNN = 1 RNSUMX = 0 ; RDSUMX = 1 RNSUMX2 = 0 ; RDSUMX2 = 1 RNSUMY = 0 ; RDSUMY = 1 RNSUMY2 = 0 ; RDSUMY2 = 1 RNSUMXY = 0 ; RDSUMXY = 1 ANGLE_MODE = INITIAL_ANGLE_MODE SELECT CASE ( ANGLE_MODE ) CASE ( 1 ) ANGLE_FACTOR = PI / 18 0.0D0 CASE ( 2 ) ANGLE_FACTOR = 1._wp CASE ( 3 ) ANGLE_FACTOR = PI / 20 0.0D0 CASE ( 4 ) ANGLE_FACTOR = 2 * pi END SELECT DISP_MODE = INITIAL_DISP_MODE DISP_DIGITS = INITIAL_DISP_DIGITS DOMAIN_MODE = INITIAL_DOMAIN_MODE BASE_MODE = INITIAL_BASE_MODE FRACTION_MODE = INITIAL_FRACTION_MODE FRACTOL = INITIAL_FRACTOL case ( 'REV' ) ! REV ANGLE_MODE = 4 ANGLE_FACTOR = 2 * pi case ( 'RGAS' ) ! RGAS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( RGAS ) CASE ( 2 ) CALL push_stack ( CMPLX ( RGAS , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( RGAS ) END SELECT case ( 'RI' ) ! RI SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) STACK ( 1 ) = 0._wp CASE ( 2 ) TMP = real ( CSTACK ( 1 ), wp ) TMP2 = AIMAG ( CSTACK ( 1 )) CSTACK ( 1 ) = CMPLX ( TMP2 , TMP , wp ) CASE ( 3 ) RNSTACK ( 1 ) = 0 RDSTACK ( 1 ) = 1 END SELECT case ( 'ROUND' ) ! ROUND SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = ANINT ( STACK ( 1 )) CASE ( 2 ) TMP = ANINT ( real ( CSTACK ( 1 ), wp )) TMP2 = ANINT ( AIMAG ( CSTACK ( 1 ))) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , TMP2 , wp ) CASE ( 3 ) NUM = RNSTACK ( 1 ) DEN = RDSTACK ( 1 ) CALL RNINT ( NUM , DEN ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = DEN END SELECT case ( 'U' ) ! roll stack up SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) stack = cshift ( stack , - 1 ) CASE ( 2 ) cstack = cshift ( cstack , - 1 ) CASE ( 3 ) rnstack = cshift ( rnstack , - 1 ) rdstack = cshift ( rdstack , - 1 ) END SELECT case ( 'RZETA' ) ! RZETA SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = RIEMANNZETA ( STACK ( 1 ), 1.e-10_wp ) + 1._wp CASE ( 2 ) write ( stderr , * ) ' RZETA function not available in COMPLEX mode.' CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = RIEMANNZETA ( STACK ( 1 ), 1.e-10_wp ) + 1._wp END SELECT case ( 'S' ) ! S SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) NN = NN + 1._wp SUMX = SUMX + STACK ( 1 ) SUMX2 = SUMX2 + STACK ( 1 ) ** 2 SUMY = SUMY + STACK ( 2 ) SUMY2 = SUMY2 + STACK ( 2 ) ** 2 SUMXY = SUMXY + STACK ( 1 ) * STACK ( 2 ) LASTX = STACK ( 1 ) STACK ( 1 ) = NN CASE ( 2 ) CNN = CNN + 1._wp CSUMX = CSUMX + CSTACK ( 1 ) CSUMX2 = CSUMX2 + CSTACK ( 1 ) ** 2 CSUMY = CSUMY + CSTACK ( 2 ) CSUMY2 = CSUMY2 + CSTACK ( 2 ) ** 2 CSUMXY = CSUMXY + CSTACK ( 1 ) * CSTACK ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CNN CASE ( 3 ) CALL RADD ( RNNN , RDNN , 1 , 1 , RNNN , RDNN ) CALL RADD ( RNSUMX , RDSUMX , RNSTACK ( 1 ), RDSTACK ( 1 ), RNSUMX , RDSUMX ) CALL RMUL ( RNSTACK ( 1 ), RDSTACK ( 1 ), RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) CALL RADD ( RNSUMX2 , RDSUMX2 , NUM , DEN , RNSUMX2 , RDSUMX2 ) CALL RADD ( RNSUMY , RDSUMY , RNSTACK ( 2 ), RDSTACK ( 2 ), RNSUMY , RDSUMY ) CALL RMUL ( RNSTACK ( 2 ), RDSTACK ( 2 ), RNSTACK ( 2 ), RDSTACK ( 2 ), NUM , DEN ) CALL RADD ( RNSUMY2 , RDSUMY2 , NUM , DEN , RNSUMY2 , RDSUMY2 ) CALL RMUL ( RNSTACK ( 2 ), RDSTACK ( 2 ), RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) CALL RADD ( RNSUMXY , RDSUMXY , NUM , DEN , RNSUMXY , RDSUMXY ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = RNNN RDSTACK ( 1 ) = RDNN END SELECT case ( 'S-' ) ! S- SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) NN = NN - 1._wp SUMX = SUMX - STACK ( 1 ) SUMX2 = SUMX2 - STACK ( 1 ) ** 2 SUMY = SUMY - STACK ( 2 ) SUMY2 = SUMY2 - STACK ( 2 ) ** 2 SUMXY = SUMXY - STACK ( 1 ) * STACK ( 2 ) LASTX = STACK ( 1 ) STACK ( 1 ) = NN CASE ( 2 ) CNN = CNN - 1._wp CSUMX = CSUMX - CSTACK ( 1 ) CSUMX2 = CSUMX2 - CSTACK ( 1 ) ** 2 CSUMY = CSUMY - CSTACK ( 2 ) CSUMY2 = CSUMY2 - CSTACK ( 2 ) ** 2 CSUMXY = CSUMXY - CSTACK ( 1 ) * CSTACK ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CNN CASE ( 3 ) CALL RADD ( RNNN , RDNN , 1 , 1 , RNNN , RDNN ) CALL RSUB ( RNSUMX , RDSUMX , RNSTACK ( 1 ), RDSTACK ( 1 ), RNSUMX , RDSUMX ) CALL RMUL ( RNSTACK ( 1 ), RDSTACK ( 1 ), RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) CALL RSUB ( RNSUMX2 , RDSUMX2 , NUM , DEN , RNSUMX2 , RDSUMX2 ) CALL RSUB ( RNSUMY , RDSUMY , RNSTACK ( 2 ), RDSTACK ( 2 ), RNSUMY , RDSUMY ) CALL RMUL ( RNSTACK ( 2 ), RDSTACK ( 2 ), RNSTACK ( 2 ), RDSTACK ( 2 ), NUM , DEN ) CALL RSUB ( RNSUMY2 , RDSUMY2 , NUM , DEN , RNSUMY2 , RDSUMY2 ) CALL RMUL ( RNSTACK ( 2 ), RDSTACK ( 2 ), RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) CALL RSUB ( RNSUMXY , RDSUMXY , NUM , DEN , RNSUMXY , RDSUMXY ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = RNNN RDSTACK ( 1 ) = RDNN END SELECT case ( 'SEC' ) ! SEC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = SEC ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = SEC ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = SEC ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'SECH' ) ! SECH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = SECH ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = SECH ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = SECH ( STACK ( 1 )) END SELECT case ( 'SGN' ) ! SGN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) < 0._wp ) THEN TMP = - 1._wp ELSE IF ( isclose ( STACK ( 1 ), 0._wp )) THEN TMP = 0._wp ELSE TMP = + 1._wp END IF LASTX = STACK ( 1 ) STACK ( 1 ) = TMP CASE ( 2 ) IF ( real ( CSTACK ( 1 ), wp ) < 0._wp ) THEN TMP = - 1._wp ELSE IF ( isclose ( real ( CSTACK ( 1 ), wp ), 0._wp )) THEN TMP = 0._wp ELSE TMP = + 1._wp END IF IF ( AIMAG ( CSTACK ( 1 )) < 0._wp ) THEN TMP2 = - 1._wp ELSE IF ( isclose ( AIMAG ( CSTACK ( 1 )), 0._wp )) THEN TMP2 = 0._wp ELSE TMP2 = + 1._wp END IF CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , TMP2 , wp ) CASE ( 3 ) IF ( RNSTACK ( 1 ) < 0 ) THEN ITMP = 1 ELSE IF ( RNSTACK ( 1 ) == 0 ) THEN ITMP = 0 ELSE ITMP = + 1 END IF RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = ITMP RDSTACK ( 1 ) = 1 END SELECT case ( 'SIN' ) ! SIN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = SIN ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = SIN ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = SIN ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'SINC' ) ! SINC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = SINC ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = SINC ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = SINC ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'SINH' ) ! SINH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = SINH ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = SINH ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = SINH ( STACK ( 1 )) END SELECT case ( 'SINHC' ) ! SINHC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = SINHC ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSINHC ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = SINHC ( STACK ( 1 )) END SELECT case ( 'SQR' ) ! SQR SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 1 ) ** 2 CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 1 ) ** 2 CASE ( 3 ) NUM = RNSTACK ( 1 ) DEN = RDSTACK ( 1 ) CALL RMUL ( NUM , DEN , NUM , DEN , NUM2 , DEN2 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM2 RDSTACK ( 1 ) = DEN2 END SELECT case ( 'SQRT' ) ! SQRT SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) < 0._wp ) THEN write ( stderr , * ) '  SQRT Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = SQRT ( STACK ( 1 )) END IF CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = SQRT ( CSTACK ( 1 )) CASE ( 3 ) IF ( RNSTACK ( 1 ) < 0 ) THEN write ( stderr , * ) '  SQRT Error' ELSE TMP = SQRT ( real ( RNSTACK ( 1 ), wp )) TMP2 = SQRT ( real ( RDSTACK ( 1 ), wp )) IF ( ISFRAC ( TMP ). OR . ISFRAC ( TMP2 )) THEN CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = SQRT ( STACK ( 1 )) ELSE RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NINT ( SQRT ( real ( RNSTACK ( 1 ), wp ))) RDSTACK ( 1 ) = NINT ( SQRT ( real ( RDSTACK ( 1 ), wp ))) END IF END IF END SELECT case ( 'STEFAN' ) ! STEFAN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( STEFAN ) CASE ( 2 ) CALL push_stack ( CMPLX ( STEFAN , kind = wp )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL CALL PUSH_STACK ( STEFAN ) END SELECT case ( 'SUMX' ) ! SUMX SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( SUMX ) CASE ( 2 ) CALL push_stack ( CSUMX ) CASE ( 3 ) CALL push_stack ( RNSUMX , RDSUMX ) END SELECT case ( 'SUMX2' ) ! SUMX2 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( SUMX2 ) CASE ( 2 ) CALL push_stack ( CSUMX2 ) CASE ( 3 ) CALL push_stack ( RNSUMX2 , RDSUMX2 ) END SELECT case ( 'SUMXY' ) ! SUMXY SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( SUMXY ) CASE ( 2 ) CALL push_stack ( CSUMXY ) CASE ( 3 ) CALL push_stack ( RNSUMXY , RDSUMXY ) END SELECT case ( 'SUMY' ) ! SUMY SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( SUMY ) CASE ( 2 ) CALL push_stack ( CSUMY ) CASE ( 3 ) CALL push_stack ( RNSUMY , RDSUMY ) END SELECT case ( 'SUMY2' ) ! SUMY2 SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( SUMY2 ) CASE ( 2 ) CALL push_stack ( CSUMY2 ) CASE ( 3 ) CALL push_stack ( RNSUMY2 , RDSUMY2 ) END SELECT case ( 'TAN' ) ! TAN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = TAN ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = tan ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = TAN ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'TANC' ) ! TANC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = TANC ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = TANC ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = TANC ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'TANH' ) ! TANH SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = TANH ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = TANH ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = TANH ( STACK ( 1 )) END SELECT case ( 'TANHC' ) ! TANHC SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = TANHC ( STACK ( 1 )) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CTANHC ( CSTACK ( 1 )) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = TANHC ( STACK ( 1 )) END SELECT case ( 'TIME' ) ! TIME CALL DATE_AND_TIME ( DATE , TIME , ZONE , DT ) YEAR = DT ( 1 ) MONTH = DT ( 2 ) DAY = DT ( 3 ) HOUR = DT ( 5 ) MINUTE = DT ( 6 ) SECOND = DT ( 7 ) print '(A,I2.2,A1,I2.2,A1,I4)' , '  Date:  ' , MONTH , '-' , DAY , '-' , YEAR print '(A,I2.2,A1,I2.2,A1,I2.2)' , '  Time:  ' , HOUR , ':' , MINUTE , ':' , SECOND case ( 'VER' ) ! VER print * , 'Fortran 2018  RPN Calculator.  Version ' // VERSION case ( 'VERS' ) ! VERS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = VERS ( STACK ( 1 ) * ANGLE_FACTOR ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CVERS ( CSTACK ( 1 ) * ANGLE_FACTOR ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = VERS ( STACK ( 1 ) * ANGLE_FACTOR ) END SELECT case ( 'X&#94;' ) ! X&#94; SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( NN <= 1._wp ) THEN write ( stderr , * ) '  X&#94; Error' ELSE CALL LINREG ( TMPM , TMPB , TMPR ) LASTX = STACK ( 1 ) STACK ( 1 ) = ( STACK ( 1 ) - TMPB ) / TMPM END IF CASE ( 2 ) IF ( real ( CNN , wp ) <= 1._wp ) THEN write ( stderr , * ) '  X&#94; Error' ELSE CALL CLINREG ( CTMPM , CTMPB , CTMPR ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ( CSTACK ( 1 ) - CTMPB ) / CTMPM END IF CASE ( 3 ) IF ( RNNN <= 1 ) THEN write ( stderr , * ) '  X&#94; Error' ELSE CALL RLINREG ( NUMM , DENM , NUMB , DENB , TMPR ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) CALL RSUB ( RNSTACK ( 1 ), RDSTACK ( 1 ), NUMB , DENB , NUM , DEN ) CALL RDIV ( NUM , DEN , NUMM , DENM , NUM2 , DEN2 ) RNSTACK ( 1 ) = NUM2 RDSTACK ( 1 ) = DEN2 END IF END SELECT case ( 'XMEAN' ) ! XMEAN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( isclose ( NN , 0._wp )) THEN write ( stderr , * ) '  XMEAN Error' ELSE TMP = SUMX / NN CALL PUSH_STACK ( TMP ) END IF CASE ( 2 ) IF ( isclose ( CNN , C0 )) THEN write ( stderr , * ) '  XMEAN Error' ELSE CTMP = CSUMX / CNN CALL push_stack ( CTMP ) END IF CASE ( 3 ) IF ( RNNN == 0 ) THEN write ( stderr , * ) '  XMEAN Error' ELSE CALL RDIV ( RNSUMX , RDSUMX , RNNN , RDNN , NUM , DEN ) CALL push_stack ( NUM , DEN ) END IF END SELECT case ( 'XOR' ) ! XOR SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = IEOR ( INT ( STACK ( 2 )), INT ( STACK ( 1 ))) CALL DROP_STACK ( 2 ) CASE ( 2 ) TMP = IEOR ( INT ( real ( CSTACK ( 2 ), wp )), INT ( real ( CSTACK ( 1 ), wp ))) TMP2 = IEOR ( INT ( AIMAG ( CSTACK ( 2 ))), INT ( AIMAG ( CSTACK ( 1 )))) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CMPLX ( TMP , TMP2 , wp ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) ITMP = RNSTACK ( 1 ) / RDSTACK ( 1 ) ITMP2 = RNSTACK ( 2 ) / RDSTACK ( 2 ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = IEOR ( ITMP2 , ITMP ) RDSTACK ( 1 ) = 1 CALL RDROP_STACK ( 2 ) END SELECT case ( 'XRT' ) ! XRT SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) ** ( 1._wp / STACK ( 1 )) CALL DROP_STACK ( 2 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 2 ) ** ( 1._wp / CSTACK ( 1 )) CALL CDROP_STACK ( 2 ) CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) ** ( 1._wp / STACK ( 1 )) CALL DROP_STACK ( 2 ) END SELECT case ( 'XS' ) ! XS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( NN <= 1._wp ) THEN write ( stderr , * ) '  XS Error' ELSE TMP = SQRT (( SUMX2 - SUMX ** 2 / NN ) / ( NN - 1._wp )) CALL PUSH_STACK ( TMP ) END IF CASE ( 2 ) IF ( real ( CNN , wp ) <= 1._wp ) THEN write ( stderr , * ) '  XS Error' ELSE CTMP = SQRT (( CSUMX2 - CSUMX ** 2 / CNN ) / ( CNN - 1._wp )) CALL push_stack ( CTMP ) END IF CASE ( 3 ) IF ( RNNN <= RDNN ) THEN write ( stderr , * ) '  XS Error' ELSE CALL SWITCH_RAT_TO_REAL TMP = SQRT (( SUMX2 - SUMX ** 2 / NN ) / ( NN - 1._wp )) CALL PUSH_STACK ( TMP ) END IF END SELECT case ( 'XSIG' ) ! XSIG SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( NN <= 1._wp ) THEN write ( stderr , * ) '  XSIG Error' ELSE TMP = SQRT (( SUMX2 - SUMX ** 2 / NN ) / NN ) CALL PUSH_STACK ( TMP ) END IF CASE ( 2 ) IF ( real ( CNN , wp ) <= 1._wp ) THEN write ( stderr , * ) '  XSIG Error' ELSE CTMP = SQRT (( CSUMX2 - CSUMX ** 2 / CNN ) / CNN ) CALL push_stack ( CTMP ) END IF CASE ( 3 ) IF ( RNNN <= RDNN ) THEN write ( stderr , * ) '  XSIG Error' ELSE CALL SWITCH_RAT_TO_REAL TMP = SQRT (( SUMX2 - SUMX ** 2 / NN ) / NN ) CALL PUSH_STACK ( TMP ) END IF END SELECT case ( 'XY' ) ! XY SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) TMP = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) STACK ( 2 ) = TMP CASE ( 2 ) CTMP = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 2 ) CSTACK ( 2 ) = CTMP CASE ( 3 ) ITMP = RNSTACK ( 1 ) ITMP2 = RDSTACK ( 1 ) RNSTACK ( 1 ) = RNSTACK ( 2 ) RDSTACK ( 1 ) = RDSTACK ( 2 ) RNSTACK ( 2 ) = ITMP RDSTACK ( 2 ) = ITMP2 END SELECT case ( 'Y&#94;' ) ! Y&#94; SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( NN <= 1._wp ) THEN write ( stderr , * ) '  Y&#94; Error' ELSE CALL LINREG ( TMPM , TMPB , TMPR ) LASTX = STACK ( 1 ) STACK ( 1 ) = TMPM * STACK ( 1 ) + TMPB END IF CASE ( 2 ) IF ( real ( CNN , wp ) <= 1._wp ) THEN write ( stderr , * ) '  Y&#94; Error' ELSE CALL CLINREG ( CTMPM , CTMPB , CTMPR ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CTMPM * CSTACK ( 1 ) + CTMPB END IF CASE ( 3 ) IF ( RNNN <= 1 ) THEN write ( stderr , * ) '  Y&#94; Error' ELSE CALL RLINREG ( NUMM , DENM , NUMB , DENB , TMPR ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) CALL RMUL ( NUMM , DENM , RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) CALL RADD ( NUM , DEN , NUMB , DENB , NUM2 , DEN2 ) RNSTACK ( 1 ) = NUM2 RDSTACK ( 1 ) = DEN2 END IF END SELECT case ( 'YMEAN' ) ! YMEAN SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( isclose ( NN , 0._wp )) THEN write ( stderr , * ) '  YMEAN Error' ELSE TMP = SUMY / NN CALL PUSH_STACK ( TMP ) END IF CASE ( 2 ) IF ( isclose ( CNN , C0 )) THEN write ( stderr , * ) '  YMEAN Error' ELSE CTMP = CSUMY / CNN CALL push_stack ( CTMP ) END IF CASE ( 3 ) IF ( RNNN == 0 ) THEN write ( stderr , * ) '  YMEAN Error' ELSE CALL RDIV ( RNSUMY , RDSUMY , RNNN , RDNN , NUM , DEN ) CALL push_stack ( NUM , DEN ) END IF END SELECT case ( 'YS' ) ! YS SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( NN <= 1._wp ) THEN write ( stderr , * ) '  YS Error' ELSE TMP = SQRT (( SUMY2 - SUMY ** 2 / NN ) / ( NN - 1._wp )) CALL PUSH_STACK ( TMP ) END IF CASE ( 2 ) IF ( real ( CNN , wp ) <= 1._wp ) THEN write ( stderr , * ) '  YS Error' ELSE CTMP = SQRT (( CSUMY2 - CSUMY ** 2 / CNN ) / ( CNN - 1._wp )) CALL push_stack ( CTMP ) END IF CASE ( 3 ) IF ( RNNN <= RDNN ) THEN write ( stderr , * ) '  YS Error' ELSE CALL SWITCH_RAT_TO_REAL TMP = SQRT (( SUMY2 - SUMY ** 2 / NN ) / ( NN - 1._wp )) CALL PUSH_STACK ( TMP ) END IF END SELECT case ( 'YSIG' ) ! YSIG SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( NN <= 1._wp ) THEN write ( stderr , * ) '  YSIG Error' ELSE TMP = SQRT (( SUMY2 - SUMY ** 2 / NN ) / NN ) CALL PUSH_STACK ( TMP ) END IF CASE ( 2 ) IF ( real ( CNN , wp ) <= 1._wp ) THEN write ( stderr , * ) '  YSIG Error' ELSE CTMP = SQRT (( CSUMY2 - CSUMY ** 2 / CNN ) / CNN ) CALL push_stack ( CTMP ) END IF CASE ( 3 ) IF ( RNNN <= RDNN ) THEN write ( stderr , * ) '  YSIG Error' ELSE CALL SWITCH_RAT_TO_REAL TMP = SQRT (( SUMY2 - SUMY ** 2 / NN ) / NN ) CALL PUSH_STACK ( TMP ) END IF END SELECT case default call regops ( str ) END select END SUBROUTINE EVAL subroutine regops ( str ) character ( * ), intent ( in ) :: str integer :: ierr , itmp select case ( str (: 3 )) case ( 'RCL' ) ! RCL IF ( LEN_TRIM ( STR ) == 3 ) THEN write ( stderr , * ) '  RCLx requires specifying a integer register x ~ (0..9) to store in.  E.g.  RCL6' return endif READ ( STR ( 4 : 4 ), '(I1)' , IOSTAT = IERR ) ITMP IF ( IERR /= 0 ) THEN write ( stderr , * ) '  RCL Error with register ' // str ( 4 : 4 ) return endif IF (( ITMP < 0 ). OR .( ITMP >= REG_SIZE )) THEN write ( stderr , * ) '  RCL Error: no register at' , itmp return endif SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) CALL PUSH_STACK ( REG ( ITMP )) CASE ( 2 ) CALL push_stack ( CREG ( ITMP )) CASE ( 3 ) CALL push_stack ( RNREG ( ITMP ), RDREG ( ITMP )) END SELECT PRINT * , REG ( ITMP ) case ( 'STO' ) ! STO IF ( LEN_TRIM ( STR ) == 3 ) THEN write ( stderr , * ) '  STOx requires specifying a integer register x ~ (0..9) to store in.  E.g.  STO6' return endif READ ( STR ( 4 : 4 ), '(I1)' , IOSTAT = IERR ) ITMP IF ( IERR /= 0 ) THEN write ( stderr , * ) '  STO Error with register ' // str ( 4 : 4 ) return endif IF (( ITMP < 0 ). OR .( ITMP >= REG_SIZE )) THEN write ( stderr , * ) '  STO Error: no register at' , itmp return endif SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) REG ( ITMP ) = STACK ( 1 ) CASE ( 2 ) CREG ( ITMP ) = CSTACK ( 1 ) CASE ( 3 ) RNREG ( ITMP ) = RNSTACK ( 1 ) RDREG ( ITMP ) = RDSTACK ( 1 ) END SELECT PRINT * , REG ( ITMP ) case ( 'ENG' ) ! ENG IF ( LEN_TRIM ( STR ) == 3 ) THEN write ( stderr , * ) '  ENG Error: must specify # of digits of precision (0..9)' return endif READ ( STR ( 4 : 4 ), '(I1)' , IOSTAT = IERR ) ITMP IF ( IERR /= 0 ) THEN write ( stderr , * ) '  ENG Error: with # digits: ' // str ( 4 : 4 ) return endif DISP_MODE = 3 DISP_DIGITS = ITMP case ( 'FIX' ) ! FIX IF ( LEN_TRIM ( STR ) == 3 ) THEN write ( stderr , * ) '  FIX Error: must specify # of digits of precision (0..9)' return endif READ ( UNIT = STR ( 4 : 4 ), FMT =* , IOSTAT = IERR ) ITMP IF ( IERR /= 0 ) THEN write ( stderr , * ) '  FIX Error: with # digits: ' // str ( 4 : 4 ) return endif DISP_MODE = 1 DISP_DIGITS = ITMP case ( 'SCI' ) ! SCI IF ( LEN_TRIM ( STR ) == 3 ) THEN write ( stderr , * ) '  SCI Error: must specify # of digits of precision (0..9)' return endif READ ( UNIT = STR ( 4 : 4 ), FMT =* , IOSTAT = IERR ) ITMP IF ( IERR /= 0 ) THEN write ( stderr , * ) '  SCI Error: with # digits: ' // str ( 4 : 4 ) return endif DISP_MODE = 2 DISP_DIGITS = ITMP case default WRITE ( stderr , * ) '  Input error:  \"' // TRIM ( STR ) // '\"' end select end subroutine regops subroutine add ( mode ) integer , intent ( in ) :: mode integer :: NUM , DEN SELECT CASE ( MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) + STACK ( 1 ) CALL DROP_STACK ( 2 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 2 ) + CSTACK ( 1 ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) CALL RADD ( RNSTACK ( 2 ), RDSTACK ( 2 ), RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = DEN CALL RDROP_STACK ( 2 ) END SELECT end subroutine add subroutine subtract ( mode ) integer , intent ( in ) :: mode integer :: NUM , DEN SELECT CASE ( MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) - STACK ( 1 ) CALL DROP_STACK ( 2 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 2 ) - CSTACK ( 1 ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) CALL RSUB ( RNSTACK ( 2 ), RDSTACK ( 2 ), RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = DEN CALL RDROP_STACK ( 2 ) END SELECT end subroutine subtract subroutine multiply ( mode ) integer , intent ( in ) :: mode integer :: NUM , DEN SELECT CASE ( MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) * STACK ( 1 ) CALL DROP_STACK ( 2 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 2 ) * CSTACK ( 1 ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) CALL RMUL ( RNSTACK ( 2 ), RDSTACK ( 2 ), RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = DEN CALL RDROP_STACK ( 2 ) END SELECT end subroutine multiply subroutine divide ( mode ) integer , intent ( in ) :: mode integer :: NUM , DEN SELECT CASE ( MODE ) CASE ( 1 ) IF ( isclose ( stack ( 1 ), 0._wp )) THEN write ( stderr , * ) '  Divide by zero Error' return ENDIF LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) / STACK ( 1 ) CALL DROP_STACK ( 2 ) CASE ( 2 ) IF ( isclose ( cstack ( 1 ), C0 )) THEN write ( stderr , * ) '  Divide by zero Error' return ENDIF CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 2 ) / CSTACK ( 1 ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) CALL RDIV ( RNSTACK ( 2 ), RDSTACK ( 2 ), RNSTACK ( 1 ), RDSTACK ( 1 ), NUM , DEN ) RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = NUM RDSTACK ( 1 ) = DEN CALL RDROP_STACK ( 2 ) END SELECT end subroutine divide subroutine power ( mode ) integer , intent ( in ) :: mode SELECT CASE ( MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) ** STACK ( 1 ) CALL DROP_STACK ( 2 ) CASE ( 2 ) CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = CSTACK ( 2 ) ** CSTACK ( 1 ) CALL CDROP_STACK ( 2 ) CASE ( 3 ) IF ( RDSTACK ( 1 ) == 1 ) THEN RNLASTX = RNSTACK ( 1 ) RDLASTX = RDSTACK ( 1 ) RNSTACK ( 1 ) = RNSTACK ( 2 ) ** RNLASTX RDSTACK ( 1 ) = RDSTACK ( 2 ) ** RNLASTX CALL RDROP_STACK ( 2 ) ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = STACK ( 2 ) ** STACK ( 1 ) CALL DROP_STACK ( 2 ) END IF END SELECT end subroutine power subroutine bsj () integer :: Nb , ncalc real ( wp ), allocatable :: B (:) associate ( X => stack ( 1 ), y => stack ( 2 )) IF (( x < 0._wp ) . OR . ( y < 0._wp )) THEN write ( stderr , * ) '  BESSELJ Error 1' return ENDIF NB = INT ( y ) + 1 ALLOCATE ( B ( NB )) CALL RJBESL ( X = x , ALPHA = FRAC ( y ), NB = NB , B = B , NCALC = NCALC ) IF ( NCALC < 0 ) THEN write ( stderr , * ) '  BESSELJ Error 2' return ELSE IF ( NCALC /= NB ) THEN write ( stderr , * ) '  BESSELJ Error 3' return Endif LASTX = x x = B ( NB ) CALL DROP_STACK ( 2 ) end associate end subroutine bsj subroutine bsy0 () associate ( X => stack ( 1 )) IF ( x <= 0._wp ) THEN write ( stderr , * ) '  BESSELY0 Error' ELSE LASTX = x x = bessel_y0 ( x ) END IF end associate end subroutine bsy0 end module evals","tags":"","loc":"sourcefile/eval.f90.html"},{"title":"funcs.f90 – RPN calculator in Fortran","text":"This file depends on sourcefile~~funcs.f90~~EfferentGraph sourcefile~funcs.f90 funcs.f90 sourcefile~gamma.f90 gamma.f90 sourcefile~funcs.f90->sourcefile~gamma.f90 sourcefile~trig.f90 trig.f90 sourcefile~funcs.f90->sourcefile~trig.f90 sourcefile~rat.f90 rat.f90 sourcefile~funcs.f90->sourcefile~rat.f90 sourcefile~hyper.f90 hyper.F90 sourcefile~funcs.f90->sourcefile~hyper.f90 sourcefile~stats.f90 stats.f90 sourcefile~funcs.f90->sourcefile~stats.f90 sourcefile~bessel.f90 bessel.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~gamma.f90->sourcefile~rat.f90 sourcefile~gamma.f90->sourcefile~hyper.f90 sourcefile~reg.f90 reg.f90 sourcefile~rat.f90->sourcefile~reg.f90 sourcefile~hyper.f90->sourcefile~rat.f90 sourcefile~hyper.f90->sourcefile~reg.f90 sourcefile~stats.f90->sourcefile~rat.f90 sourcefile~stats.f90->sourcefile~reg.f90 sourcefile~k1.f k1.f sourcefile~bessel.f90->sourcefile~k1.f sourcefile~ribesl.f ribesl.f sourcefile~bessel.f90->sourcefile~ribesl.f sourcefile~rybesl.f rybesl.f sourcefile~bessel.f90->sourcefile~rybesl.f sourcefile~rkbesl.f rkbesl.f sourcefile~bessel.f90->sourcefile~rkbesl.f sourcefile~k0.f k0.f sourcefile~bessel.f90->sourcefile~k0.f sourcefile~i0.f i0.f sourcefile~bessel.f90->sourcefile~i0.f sourcefile~i1.f i1.f sourcefile~bessel.f90->sourcefile~i1.f sourcefile~rjbesl.f rjbesl.f sourcefile~bessel.f90->sourcefile~rjbesl.f Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~funcs.f90~~AfferentGraph sourcefile~funcs.f90 funcs.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules funcs Source Code funcs.f90 Source Code module funcs use , intrinsic :: iso_fortran_env , only : stderr => error_unit use assert , only : wp , isclose use bessel use trig use rat , only : ratnorm , rdiv , rsub , radd , rmul , isfrac , lcm , gcd , isint , isreal , iscomplex , isdigit , isrational , & dec_to_frac , frac_to_mixed use hyper use stats use fgamma implicit none interface cuberoot procedure cuberoot_r , cuberoot_c end interface cuberoot interface frac procedure frac_r , frac_c end interface frac interface sinc procedure sinc_r , sinc_c end interface sinc interface tanc procedure tanc_r , tanc_c end interface tanc real ( wp ), parameter , private :: xinf = huge ( 0._wp ), xmax = xinf , xmin = tiny ( 0._wp ) complex ( wp ), parameter , private :: c0 = ( 0._wp , 0._wp ) contains !*********************************************************************************************************************************** !  FRAC ! !  Fractional part of a number. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION FRAC_r ( X ) RESULT ( Y ) real ( wp ), INTENT ( IN ) :: X real ( wp ) :: Z Z = ABS ( X ) Y = Z - INT ( Z ) Y = SIGN ( Y , X ) END FUNCTION FRAC_r elemental complex ( wp ) FUNCTION FRAC_c ( X ) result ( frac ) COMPLEX ( wp ), INTENT ( IN ) :: X real ( wp ) :: XR , XI , YR , YI , ZR , ZI XR = real ( X , wp ) XI = AIMAG ( X ) ZR = ABS ( XR ) YR = ZR - INT ( ZR ) YR = SIGN ( YR , XR ) ZI = ABS ( XI ) YI = ZI - INT ( ZI ) YI = SIGN ( YI , XI ) FRAC = CMPLX ( YR , YI , wp ) END FUNCTION FRAC_c !*********************************************************************************************************************************** !  RFRAC ! !  Rational FRAC. !*********************************************************************************************************************************** elemental SUBROUTINE RFRAC ( N , D , NR , DR ) INTEGER , INTENT ( IN ) :: N , D INTEGER , INTENT ( OUT ) :: NR , DR INTEGER :: NI , NA , DA NA = ABS ( N ) DA = ABS ( D ) NI = RINT ( NA , DA ) CALL RSUB ( NA , DA , NI , 1 , NR , DR ) NR = SIGN ( NR , N ) CALL RATNORM ( NR , DR ) END SUBROUTINE RFRAC !*********************************************************************************************************************************** !  CINT ! !  Complex INT. !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CINT ( X ) RESULT ( Y ) COMPLEX ( wp ), INTENT ( IN ) :: X real ( wp ) :: YR , YI YR = AINT ( DBLE ( X )) YI = AINT ( AIMAG ( X )) Y = CMPLX ( YR , YI , wp ) END FUNCTION CINT !*********************************************************************************************************************************** !  RINT ! !  Rational INT. !*********************************************************************************************************************************** elemental integer FUNCTION RINT ( N , D ) RESULT ( R ) INTEGER , INTENT ( IN ) :: N , D INTEGER :: NN , DN NN = N DN = D CALL RATNORM ( NN , DN ) R = NN / DN END FUNCTION RINT !*********************************************************************************************************************************** !  RNINT ! !  Rational NINT. !*********************************************************************************************************************************** elemental SUBROUTINE RNINT ( N , D ) INTEGER , INTENT ( IN OUT ) :: N , D INTEGER :: NN , DN , TN , TD NN = N DN = D CALL RATNORM ( NN , DN ) IF ( NN . GE . 0 ) THEN CALL RADD ( NN , DN , 1 , 2 , TN , TD ) N = TN / TD D = 1 ELSE CALL RSUB ( NN , DN , 1 , 2 , TN , TD ) N = TN / TD D = 1 END IF END SUBROUTINE RNINT !*********************************************************************************************************************************** !  CMOD ! !  Complex MOD. !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CMOD ( X , Y ) RESULT ( Z ) COMPLEX ( wp ), INTENT ( IN ) :: X , Y Z = X - CINT ( X / Y ) * Y END FUNCTION CMOD !*********************************************************************************************************************************** !  RMOD ! !  Rational MOD. !*********************************************************************************************************************************** elemental SUBROUTINE RMOD ( N1 , D1 , N2 , D2 , NR , DR ) INTEGER , INTENT ( IN ) :: N1 , D1 , N2 , D2 INTEGER , INTENT ( OUT ) :: NR , DR INTEGER :: NAN , DAN , NBN , DBN , NT , DT , ITMP NAN = N1 DAN = D1 NBN = N2 DBN = D2 CALL RATNORM ( NAN , DAN ) CALL RATNORM ( NBN , DBN ) CALL RDIV ( NAN , DAN , NBN , DBN , NT , DT ) ITMP = RINT ( NT , DT ) CALL RMUL ( ITMP , 1 , NBN , DBN , NT , DT ) CALL RSUB ( NAN , DAN , NT , DT , NR , DR ) CALL RATNORM ( NR , DR ) END SUBROUTINE RMOD !*********************************************************************************************************************************** !  CUBEROOT ! !  Computes the cube root. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION CUBEROOT_r ( X ) result ( cuberoot ) real ( wp ), INTENT ( IN ) :: X CUBEROOT = SIGN (( ABS ( X )) ** ( 1._wp / 3._wp ), X ) END FUNCTION CUBEROOT_r elemental complex ( wp ) FUNCTION CUBEROOT_c ( Z ) result ( cuberoot ) COMPLEX ( wp ), INTENT ( IN ) :: Z CUBEROOT = Z ** ( 1._wp / 3._wp ) END FUNCTION CUBEROOT_c !*********************************************************************************************************************************** !  CLOG10 ! !  Complex common logarithm. !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CLOG10 ( X ) COMPLEX ( wp ), INTENT ( IN ) :: X CLOG10 = LOG ( X ) / LOG ( 1 0._wp ) END FUNCTION CLOG10 elemental real ( wp ) FUNCTION LOG1P ( X ) RESULT ( Y ) !  Compute log(1+x). real ( wp ), INTENT ( IN ) :: X real ( wp ) :: Z Z = 1._wp + X Y = LOG ( Z ) - (( Z - 1._wp ) - X ) / Z ! cancels errors with IEEE arithmetic END FUNCTION LOG1P elemental real ( wp ) FUNCTION SINC_r ( X ) result ( sinc ) !  Sine cardinal (sinc) function. real ( wp ), INTENT ( IN ) :: X IF ( isclose ( x , 0._wp )) THEN sinc = 1._wp ELSE sinc = SIN ( X ) / X END IF END FUNCTION SINC_r elemental complex ( wp ) FUNCTION SINC_c ( Z ) RESULT ( sinc ) !  Complex sine cardinal (sinc) function. COMPLEX ( wp ), INTENT ( IN ) :: Z IF ( isclose ( z , c0 )) THEN sinc = ( 1._wp , 0._wp ) ELSE sinc = SIN ( Z ) / Z END IF END FUNCTION SINC_c elemental real ( wp ) FUNCTION TANC_r ( X ) RESULT ( tanc ) !  Tanc function. real ( wp ), INTENT ( IN ) :: X IF ( isclose ( x , 0._wp )) THEN tanc = 1._wp ELSE tanc = TAN ( X ) / X END IF END FUNCTION TANC_r elemental complex ( wp ) FUNCTION TANC_c ( Z ) RESULT ( tanc ) !  Complex tanc function. COMPLEX ( wp ), INTENT ( IN ) :: Z IF ( isclose ( z , c0 )) THEN tanc = ( 1._wp , 0._wp ) ELSE tanc = TAN ( Z ) / Z END IF END FUNCTION TANC_c elemental real ( wp ) FUNCTION SINHC ( X ) RESULT ( Y ) !  Sinhc function. real ( wp ), INTENT ( IN ) :: X IF ( isclose ( x , 0._wp )) THEN Y = 1._wp ELSE Y = SINH ( X ) / X END IF END FUNCTION SINHC elemental complex ( wp ) FUNCTION CSINHC ( Z ) RESULT ( Y ) !  Complex sinhc function. COMPLEX ( wp ), INTENT ( IN ) :: Z IF ( isclose ( z , c0 )) THEN Y = ( 1._wp , 0._wp ) ELSE Y = SINH ( Z ) / Z END IF END FUNCTION CSINHC !*********************************************************************************************************************************** !  TANHC ! !  Tanhc function. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION TANHC ( X ) RESULT ( Y ) real ( wp ), INTENT ( IN ) :: X IF ( X . EQ . 0._wp ) THEN Y = 1._wp ELSE Y = TANH ( X ) / X END IF END FUNCTION TANHC !*********************************************************************************************************************************** !  CTANHC ! !  Complex tanhc function. !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CTANHC ( Z ) RESULT ( Y ) COMPLEX ( wp ), INTENT ( IN ) :: Z IF ( Z . EQ . ( 0._wp , 0._wp )) THEN Y = ( 1._wp , 0._wp ) ELSE Y = TANH ( Z ) / Z END IF END FUNCTION CTANHC !*********************************************************************************************************************************** !  ERROR FUNCTIONS ! !  From http://www.netlib.org/specfun ! !  DERFCX !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ERFCX ( X ) real ( wp ), intent ( in ) :: X erfcx = exp ( x * x ) * erfc ( x ) END FUNCTION ERFCX !*********************************************************************************************************************************** !  H2HMSD ! !  Convert decimal hours to hours, minutes, and seconds. Seconds are returned as a real value. !*********************************************************************************************************************************** elemental SUBROUTINE H2HMSD ( DHR , IHR , IMIN , SEC ) real ( wp ), INTENT ( IN ) :: DHR INTEGER , INTENT ( OUT ) :: IHR , IMIN real ( wp ), INTENT ( OUT ) :: SEC real ( wp ) :: TIME TIME = DHR ! hours IHR = INT ( TIME ) ! hours TIME = 6 0.0D0 * ( TIME - IHR ) ! minutes IMIN = INT ( TIME ) ! minutes SEC = 6 0.0D0 * ( TIME - IMIN ) ! seconds END SUBROUTINE H2HMSD !*********************************************************************************************************************************** !  HMS2H ! !  Convert hours, minutes, and seconds to decimal hours. !*********************************************************************************************************************************** elemental SUBROUTINE HMS2H ( IHR , IMIN , SEC , DHR ) INTEGER , INTENT ( IN ) :: IHR , IMIN real ( wp ), INTENT ( IN ) :: SEC real ( wp ), INTENT ( OUT ) :: DHR DHR = DBLE ( IHR ) + DBLE ( IMIN ) / 6 0.0D0 + SEC / 360 0.0D0 END SUBROUTINE HMS2H !*********************************************************************************************************************************** !  RIEMANNZETA ! !  Riemann zeta function. ! !  Algorithm from \"Atlas for Computing Mathematical Functions\" by W.J. Thompson, Wiley, 1997. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION RIEMANNZETA ( S , EPS ) !     Riemann zeta - 1  for  x > 1 real ( wp ), INTENT ( IN ) :: S , EPS real ( wp ) :: NSTERM , SUM , FN , NEGS INTEGER :: N , K !     Estimate N for accuracy  eps NSTERM = S * ( S + 1.0D00 ) * ( S + 2.0D00 ) * & ( S + 3.0D00 ) * ( S + 4.0D00 ) / 3024 0.0D00 N = int (( NSTERM * ( 2.0D00 ** S ) / EPS ) ** ( 1._wp / ( S + 5.0D00 ))) IF ( N < 10 ) THEN N = 10 END IF FN = N NEGS = - S !     Direct sum SUM = 0.0D00 DO K = 2 , N - 1 SUM = SUM + K ** NEGS END DO !     Add Euler-Maclaurin correction terms SUM = SUM + ( FN ** NEGS ) * ( 0.5D00 + FN / ( S - 1.0D00 ) & + S * ( 1._wp - ( S + 1._wp ) * ( S + 2.0D00 ) / & ( 6 0.0D00 * FN * FN )) & / ( 1 2.0D00 * FN )) + NSTERM / ( FN ** ( S + 5.0D00 )) riemannZETA = SUM END FUNCTION RIEMANNZETA !*********************************************************************************************************************************** !  REDUCE ! !  Reduce an angle to the range [angle_min, angle_max). !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION REDUCE ( THETA , ANGLE_MIN ) RESULT ( RHO ) real ( wp ), PARAMETER :: tau = 2 * 4._wp * atan ( 1._wp ) real ( wp ), INTENT ( IN ) :: THETA real ( wp ), INTENT ( IN ) :: ANGLE_MIN real ( wp ) :: ANGLE_MAX real ( wp ) :: REVS ! !     Start of code. ! ANGLE_MAX = ANGLE_MIN + tau IF ( THETA . LT . ANGLE_MIN ) THEN REVS = AINT (( ANGLE_MIN - THETA ) / tau ) + 1 RHO = THETA + REVS * tau ELSE IF ( THETA . GE . ANGLE_MAX ) THEN REVS = AINT (( THETA - ANGLE_MIN ) / tau ) RHO = THETA - REVS * tau ELSE RHO = THETA END IF END FUNCTION REDUCE !*********************************************************************************************************************************** !  KEPLER ! !  Solves the elliptical Kepler's equation by the Markley method. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION KEPLER ( MA , ECC ) RESULT ( E5 ) real ( wp ), INTENT ( IN ) :: MA real ( wp ), INTENT ( IN ) :: ECC !     Parameters. ! !     PI           = PI !     tau        = 2*PI !     PI_SQR       = PI**2 !     ONEP6_PI     = 1.6*PI !     TWO_THIRDS   = 2/3 !     SIXTH        = 1/6 !     R24          = 1/24 ! real ( wp ), PARAMETER :: PI = 4._wp * atan ( 1._wp ) ! !     Other variables. ! real ( wp ) :: ALPHA , D , Q , R , W , E1 real ( wp ) :: F , F1 , F2 , F3 , F4 , DELTA3 , DELTA4 , DELTA5 real ( wp ) :: SE , M !----------------------------------------------------------------------------------------------------------------------------------- ! !     Start of code. ! !     Put M in the range [-PI, PI) (required by the method). ! M = REDUCE ( MA , - PI ) ! !     Compute parameters. ! ALPHA = ( 3 * pi ** 2 + 1.6_wp * pi * ( PI - ABS ( M )) / ( 1._wp + ECC )) / ( pi ** 2 - 6.0D0 ) D = 3.0D0 * ( 1._wp - ECC ) + ALPHA * ECC Q = 2.0D0 * ALPHA * D * ( 1._wp - ECC ) - M ** 2 R = 3.0D0 * ALPHA * D * ( D - 1.0D0 + ECC ) * M + M ** 3 W = ( ABS ( R ) + SQRT ( Q ** 3 + R ** 2 )) ** ( 2._wp / 3._wp ) ! !     Compute first-order solution to Kepler's Equation (E1). ! E1 = ( 2._wp * R * W / ( W ** 2 + W * Q + Q ** 2 ) + M ) / D ! !     Save SIN(E1) into SE so we only have to evaluate it once. ! SE = SIN ( E1 ) ! !     Find !           F(E) = E - E SIN E - M ! !     and its derivatives, through fourth order. ! F = E1 - ECC * SE - M F1 = 1._wp - ECC * COS ( E1 ) F2 = ECC * SE F3 = 1._wp - F1 F4 = - F2 ! !     Compute 3rd, 4th, and 5th-order corrections to E1. ! DELTA3 = - F / ( F1 - 0.5D0 * F * F2 / F1 ) DELTA4 = - F / ( F1 + 0.5D0 * DELTA3 * F2 + DELTA3 ** 2 * F3 / 6._wp ) DELTA5 = - F / ( F1 + 0.5D0 * DELTA4 * F2 + DELTA4 ** 2 * F3 / 6._wp + DELTA4 ** 3 * F4 / 2 4._wp ) ! !     Find fifth-order refined estimate of E (E5). ! E5 = E1 + DELTA5 ! !     Put E5 in the range [0, 2*PI) and return. ! E5 = REDUCE ( E5 , 0._wp ) END FUNCTION KEPLER elemental function toLower ( str ) ! Michael Hirsch ! can be trivially extended to non-ASCII character ( * ), intent ( in ) :: str character ( len ( str )) :: toLower character ( * ), parameter :: lower = \"abcdefghijklmnopqrstuvwxyz\" , & upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" integer :: i , j toLower = str !do concurrent (i = 1:len(str)) ! FIXME: Flang do i = 1 , len ( str ) j = index ( upper , str ( i : i )) if ( j > 0 ) toLower ( i : i ) = lower ( j : j ) end do end function toLower elemental function toUpper ( str ) ! Michael Hirsch ! can be trivially extended to non-ASCII character ( * ), intent ( in ) :: str character ( len ( str )) :: toUpper character ( * ), parameter :: lower = \"abcdefghijklmnopqrstuvwxyz\" , & upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" integer :: i , j toUpper = str !do concurrent (i = 1:len(str))  ! FIXME: Flang do i = 1 , len ( str ) j = index ( lower , str ( i : i )) if ( j > 0 ) toUpper ( i : i ) = upper ( j : j ) end do end function toUpper end module funcs","tags":"","loc":"sourcefile/funcs.f90.html"},{"title":"gamma.f90 – RPN calculator in Fortran","text":"This file depends on sourcefile~~gamma.f90~~EfferentGraph sourcefile~gamma.f90 gamma.f90 sourcefile~hyper.f90 hyper.F90 sourcefile~gamma.f90->sourcefile~hyper.f90 sourcefile~rat.f90 rat.f90 sourcefile~gamma.f90->sourcefile~rat.f90 sourcefile~hyper.f90->sourcefile~rat.f90 sourcefile~reg.f90 reg.f90 sourcefile~hyper.f90->sourcefile~reg.f90 sourcefile~rat.f90->sourcefile~reg.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~gamma.f90~~AfferentGraph sourcefile~gamma.f90 gamma.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~gamma.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fgamma Source Code gamma.f90 Source Code module fgamma use assert , only : wp implicit none contains !*********************************************************************************************************************************** !  PSI ! !  Returns the digamma function of the argument XX.  XX cannot be 0 or a negative integer. ! !  From http://www.netlib.org/specfun/gamma !*********************************************************************************************************************************** FUNCTION PSI ( XX ) !---------------------------------------------------------------------- ! ! This function program evaluates the logarithmic derivative of the !   gamma function, ! !      psi(x) = d/dx (gamma(x)) / gamma(x) = d/dx (ln gamma(x)) ! !   for real x, where either ! !          -xmax1 < x < -xmin (x not a negative integer), or !            xmin < x. ! !   The calling sequence for this function is ! !                  Y = PSI(X) ! !   The main computation uses rational Chebyshev approximations !   published in Math. Comp. 27, 123-127 (1973) by Cody, Strecok and !   Thacher.  This transportable program is patterned after the !   machine-dependent FUNPACK program PSI(X), but cannot match that !   version for efficiency or accuracy.  This version uses rational !   approximations that are theoretically accurate to 20 significant !   decimal digits.  The accuracy achieved depends on the arithmetic !   system, the compiler, the intrinsic functions, and proper selection !   of the machine-dependent constants. ! !******************************************************************* !******************************************************************* ! ! Explanation of machine-dependent constants ! !   XINF   = largest positive machine number !   XMAX1  = beta ** (p-1), where beta is the radix for the !            floating-point system, and p is the number of base-beta !            digits in the floating-point significand.  This is an !            upper bound on non-integral floating-point numbers, and !            the negative of the lower bound on acceptable negative !            arguments for PSI.  If rounding is necessary, round this !            value down. !   XMIN1  = the smallest in magnitude acceptable argument.  We !            recommend XMIN1 = MAX(1/XINF,xmin) rounded up, where !            xmin is the smallest positive floating-point number. !   XSMALL = absolute argument below which  PI*COTAN(PI*X)  may be !            represented by 1/X.  We recommend XSMALL < sqrt(3 eps)/pi, !            where eps is the smallest positive number such that !            1+eps > 1. !   XLARGE = argument beyond which PSI(X) may be represented by !            LOG(X).  The solution to the equation !               x*ln(x) = beta ** p !            is a safe value. ! !     Approximate values for some important machines are ! !                        beta  p     eps     xmin       XINF ! !  CDC 7600      (S.P.)    2  48  7.11E-15  3.13E-294  1.26E+322 !  CRAY-1        (S.P.)    2  48  7.11E-15  4.58E-2467 5.45E+2465 !  IEEE (IBM/XT, !    SUN, etc.)  (S.P.)    2  24  1.19E-07  1.18E-38   3.40E+38 !  IEEE (IBM/XT, !    SUN, etc.)  (D.P.)    2  53  1.11D-16  2.23E-308  1.79D+308 !  IBM 3033      (D.P.)   16  14  1.11D-16  5.40D-79   7.23D+75 !  SUN 3/160     (D.P.)    2  53  1.11D-16  2.23D-308  1.79D+308 !  VAX 11/780    (S.P.)    2  24  5.96E-08  2.94E-39   1.70E+38 !                (D.P.)    2  56  1.39D-17  2.94D-39   1.70D+38 !   (G Format)   (D.P.)    2  53  1.11D-16  5.57D-309  8.98D+307 ! !                         XMIN1      XMAX1     XSMALL    XLARGE ! !  CDC 7600      (S.P.)  3.13E-294  1.40E+14  4.64E-08  9.42E+12 !  CRAY-1        (S.P.)  1.84E-2466 1.40E+14  4.64E-08  9.42E+12 !  IEEE (IBM/XT, !    SUN, etc.)  (S.P.)  1.18E-38   8.38E+06  1.90E-04  1.20E+06 !  IEEE (IBM/XT, !    SUN, etc.)  (D.P.)  2.23D-308  4.50D+15  5.80D-09  2.71D+14 !  IBM 3033      (D.P.)  1.39D-76   4.50D+15  5.80D-09  2.05D+15 !  SUN 3/160     (D.P.)  2.23D-308  4.50D+15  5.80D-09  2.71D+14 !  VAX 11/780    (S.P.)  5.89E-39   8.38E+06  1.35E-04  1.20E+06 !                (D.P.)  5.89D-39   3.60D+16  2.05D-09  2.05D+15 !   (G Format)   (D.P.)  1.12D-308  4.50D+15  5.80D-09  2.71D+14 ! !******************************************************************* !******************************************************************* ! ! Error Returns ! !  The program returns XINF for  X < -XMAX1, for X zero or a negative !    integer, or when X lies in (-XMIN1, 0), and returns -XINF !    when X lies in (0, XMIN1). ! ! Intrinsic functions required are: ! !     ABS, AINT, DBLE, INT, LOG, REAL, TAN ! ! !  Author: W. J. Cody !          Mathematics and Computer Science Division !          Argonne National Laboratory !          Argonne, IL 60439 ! !  Latest modification: June 8, 1988 ! !---------------------------------------------------------------------- INTEGER I , N , NQ !S    REAL real ( wp ) & AUG , DEN , PSI , FOUR , FOURTH , HALF , ONE , P1 , P2 , PIOV4 , Q1 , Q2 , & SGN , THREE , XLARGE , UPPER , W , X , XINF , XMAX1 , XMIN1 , XSMALL , X01 , & X01D , X02 , XX , Z , ZERO DIMENSION P1 ( 9 ), P2 ( 7 ), Q1 ( 8 ), Q2 ( 6 ) !---------------------------------------------------------------------- !  Mathematical constants.  PIOV4 = pi / 4 !---------------------------------------------------------------------- !S    DATA ZERO,FOURTH,HALF,ONE/0.0E0,0.25E0,0.5E0,1.0E0/ !S    DATA THREE,FOUR/3.0E0,4.0E0/,PIOV4/7.8539816339744830962E-01/ DATA ZERO , FOURTH , HALF , ONE / 0.0D0 , 0.25D0 , 0.5D0 , 1.0D0 / DATA THREE , FOUR / 3.0D0 , 4.0D0 / , PIOV4 / 7.8539816339744830962D-01 / !---------------------------------------------------------------------- !  Machine-dependent constants !---------------------------------------------------------------------- !S    DATA XINF/1.70E+38/, XMIN1/5.89E-39/, XMAX1/8.38E+06/, !S   1     XSMALL/1.35E-04/, XLARGE/1.20E+06/ DATA XINF / 1.70D+38 / , XMIN1 / 5.89D-39 / , XMAX1 / 3.60D+16 / , & XSMALL / 2.05D-09 / , XLARGE / 2.04D+15 / !---------------------------------------------------------------------- !  Zero of psi(x) !---------------------------------------------------------------------- !S    DATA X01/187.0E0/,X01D/128.0E0/,X02/6.9464496836234126266E-04/ DATA X01 / 18 7.0D0 / , X01D / 12 8.0D0 / , X02 / 6.9464496836234126266D-04 / !---------------------------------------------------------------------- !  Coefficients for approximation to  psi(x)/(x-x0)  over [0.5, 3.0] !---------------------------------------------------------------------- !S    DATA P1/4.5104681245762934160E-03,5.4932855833000385356E+00, !S   1        3.7646693175929276856E+02,7.9525490849151998065E+03, !S   2        7.1451595818951933210E+04,3.0655976301987365674E+05, !S   3        6.3606997788964458797E+05,5.8041312783537569993E+05, !S   4        1.6585695029761022321E+05/ !S    DATA Q1/9.6141654774222358525E+01,2.6287715790581193330E+03, !S   1        2.9862497022250277920E+04,1.6206566091533671639E+05, !S   2        4.3487880712768329037E+05,5.4256384537269993733E+05, !S   3        2.4242185002017985252E+05,6.4155223783576225996E-08/ DATA P1 / 4.5104681245762934160D-03 , 5.4932855833000385356D+00 , & 3.7646693175929276856D+02 , 7.9525490849151998065D+03 , & 7.1451595818951933210D+04 , 3.0655976301987365674D+05 , & 6.3606997788964458797D+05 , 5.8041312783537569993D+05 , & 1.6585695029761022321D+05 / DATA Q1 / 9.6141654774222358525D+01 , 2.6287715790581193330D+03 , & 2.9862497022250277920D+04 , 1.6206566091533671639D+05 , & 4.3487880712768329037D+05 , 5.4256384537269993733D+05 , & 2.4242185002017985252D+05 , 6.4155223783576225996D-08 / !---------------------------------------------------------------------- !  Coefficients for approximation to  psi(x) - ln(x) + 1/(2x) !     for  x > 3.0 !---------------------------------------------------------------------- !S    DATA P2/-2.7103228277757834192E+00,-1.5166271776896121383E+01, !S   1        -1.9784554148719218667E+01,-8.8100958828312219821E+00, !S   2        -1.4479614616899842986E+00,-7.3689600332394549911E-02, !S   3        -6.5135387732718171306E-21/ !S    DATA Q2/ 4.4992760373789365846E+01, 2.0240955312679931159E+02, !S   1         2.4736979003315290057E+02, 1.0742543875702278326E+02, !S   2         1.7463965060678569906E+01, 8.8427520398873480342E-01/ DATA P2 /- 2.7103228277757834192D+00 , - 1.5166271776896121383D+01 , & - 1.9784554148719218667D+01 , - 8.8100958828312219821D+00 , & - 1.4479614616899842986D+00 , - 7.3689600332394549911D-02 , & - 6.5135387732718171306D-21 / DATA Q2 / 4.4992760373789365846D+01 , 2.0240955312679931159D+02 , & 2.4736979003315290057D+02 , 1.0742543875702278326D+02 , & 1.7463965060678569906D+01 , 8.8427520398873480342D-01 / !---------------------------------------------------------------------- !S    CONV(I) = REAL(I) X = XX W = ABS ( X ) AUG = ZERO !---------------------------------------------------------------------- !  Check for valid arguments, then branch to appropriate algorithm !---------------------------------------------------------------------- IF (( - X . GE . XMAX1 ) . OR . ( W . LT . XMIN1 )) THEN GO TO 410 ELSE IF ( X . GE . HALF ) THEN GO TO 200 !---------------------------------------------------------------------- !  X < 0.5, use reflection formula: psi(1-x) = psi(x) + pi * cot(pi*x) !     Use 1/X for PI*COTAN(PI*X)  when  XMIN1 < |X| <= XSMALL. !---------------------------------------------------------------------- ELSE IF ( W . LE . XSMALL ) THEN AUG = - ONE / X GO TO 150 END IF !---------------------------------------------------------------------- !  Argument reduction for cot !---------------------------------------------------------------------- 100 IF ( X . LT . ZERO ) THEN SGN = PIOV4 ELSE SGN = - PIOV4 END IF W = W - AINT ( W ) NQ = INT ( W * FOUR ) W = FOUR * ( W - real ( NQ , wp ) * FOURTH ) !---------------------------------------------------------------------- !  W is now related to the fractional part of  4.0 * X. !     Adjust argument to correspond to values in the first !     quadrant and determine the sign. !---------------------------------------------------------------------- N = NQ / 2 IF (( N + N ) . NE . NQ ) W = ONE - W Z = PIOV4 * W IF ( MOD ( N , 2 ) . NE . 0 ) SGN = - SGN !---------------------------------------------------------------------- !  determine the final value for  -pi * cotan(pi*x) !---------------------------------------------------------------------- N = ( NQ + 1 ) / 2 IF ( MOD ( N , 2 ) . EQ . 0 ) THEN !---------------------------------------------------------------------- !  Check for singularity !---------------------------------------------------------------------- IF ( Z . EQ . ZERO ) GO TO 410 AUG = SGN * ( FOUR / TAN ( Z )) ELSE AUG = SGN * ( FOUR * TAN ( Z )) END IF 150 X = ONE - X 200 IF ( X . GT . THREE ) GO TO 300 !---------------------------------------------------------------------- !  0.5 <= X <= 3.0 !---------------------------------------------------------------------- DEN = X UPPER = P1 ( 1 ) * X DO 210 I = 1 , 7 DEN = ( DEN + Q1 ( I )) * X UPPER = ( UPPER + P1 ( I + 1 )) * X 210 CONTINUE DEN = ( UPPER + P1 ( 9 )) / ( DEN + Q1 ( 8 )) X = ( X - X01 / X01D ) - X02 PSI = DEN * X + AUG GO TO 500 !---------------------------------------------------------------------- !  3.0 < X !---------------------------------------------------------------------- 300 IF ( X . LT . XLARGE ) THEN W = ONE / ( X * X ) DEN = W UPPER = P2 ( 1 ) * W DO 310 I = 1 , 5 DEN = ( DEN + Q2 ( I )) * W UPPER = ( UPPER + P2 ( I + 1 )) * W 310 CONTINUE AUG = ( UPPER + P2 ( 7 )) / ( DEN + Q2 ( 6 )) - HALF / X + AUG END IF PSI = AUG + LOG ( X ) GO TO 500 !---------------------------------------------------------------------- !  Error return !---------------------------------------------------------------------- 410 PSI = XINF IF ( X . GT . ZERO ) PSI = - XINF 500 RETURN !---------- Last card of PSI ---------- END function psi !*********************************************************************************************************************************** !  CGAMMA ! !  Complex gamma function. !  Formulae from \"An Atlas of Functions\" by Spanier and Oldham, Sect. 43:11. !*********************************************************************************************************************************** complex ( wp ) FUNCTION CGAMMA ( Z ) RESULT ( R ) use hyper , only : csch COMPLEX ( wp ), INTENT ( IN ) :: Z real ( wp ), PARAMETER :: EPS = 1.0D-14 real ( wp ), PARAMETER :: PI = 4._wp * atan ( 1._wp ) real ( wp ), PARAMETER :: EULER = 0.57721566490153286060651209008240243104215933593992359880576723488486772677766467094_wp INTEGER :: J real ( wp ) :: X , Y , THETA , SUM , PROD , PSUM , PPROD X = DBLE ( Z ) Y = AIMAG ( Z ) IF ( Z . EQ . ( 0.0D0 , 0.0D0 )) THEN ! write(stderr, *) '  CGAMMA Error.' R = ( 0.0D0 , 0.0D0 ) RETURN END IF IF ( Y . EQ . 0.0D0 ) THEN ! if real Z R = CMPLX ( GAMMA ( X ), 0.0D0 , wp ) RETURN END IF IF ( X . EQ . 0.0D0 ) GO TO 100 ! branch for imaginary Z ! !     Complex Z ! SUM = 0.0D0 PSUM = HUGE ( 0._wp ) J = 0 DO SUM = SUM + Y / ( real ( j , wp ) + X ) - ATAN2 ( Y , real ( J , wp ) + X ) IF ( ABS (( SUM - PSUM ) / SUM ) . LE . EPS ) EXIT PSUM = SUM J = J + 1 IF ( J . LT . 0 ) EXIT END DO THETA = Y * PSI ( X ) + SUM PROD = 1._wp PPROD = HUGE ( 0._wp ) J = 0 DO PROD = PROD * ABS ( real ( j , wp ) + X ) / SQRT ( Y ** 2 + ( real ( J , wp ) + X ) ** 2 ) IF ( ABS (( PROD - PPROD ) / PROD ) . LE . EPS ) EXIT PPROD = PROD J = J + 1 IF ( J . LT . 0 ) EXIT END DO R = CMPLX ( COS ( THETA ), SIN ( THETA ), wp ) * ABS ( gamma ( X )) * PROD RETURN ! !     Imaginary Z ! 100 SUM = 0.0D0 PSUM = HUGE ( 0._wp ) J = 1 DO SUM = SUM + Y / real ( j , wp ) - ATAN2 ( Y , real ( j , wp )) IF ( ABS (( SUM - PSUM ) / SUM ) . LE . EPS ) EXIT PSUM = SUM J = J + 1 IF ( J . LT . 0 ) EXIT END DO THETA = - EULER * Y + SUM R = SQRT (( PI / Y ) * CSCH ( PI * Y )) * CMPLX ( SIN ( THETA ), - COS ( THETA ), wp ) END FUNCTION CGAMMA !*********************************************************************************************************************************** !  BETA ! !  Beta function. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION BETA ( X , Y ) RESULT ( R ) real ( wp ), INTENT ( IN ) :: X , Y R = gamma ( X ) * gamma ( Y ) / gamma ( X + Y ) END FUNCTION BETA !*********************************************************************************************************************************** !  CBETA ! !  Complex beta function. !*********************************************************************************************************************************** complex ( wp ) FUNCTION CBETA ( X , Y ) RESULT ( R ) COMPLEX ( wp ), INTENT ( IN ) :: X , Y R = CGAMMA ( X ) * CGAMMA ( Y ) / CGAMMA ( X + Y ) END FUNCTION CBETA !*********************************************************************************************************************************** !  RBETA ! !  Rational beta function. !*********************************************************************************************************************************** elemental SUBROUTINE RBETA ( X , Y , N , D ) use rat , only : ratnorm INTEGER , INTENT ( IN ) :: X , Y INTEGER , INTENT ( OUT ) :: N , D INTEGER :: I N = 1 DO I = 2 , X - 1 N = N * I END DO DO I = 2 , Y - 1 N = N * I END DO D = 1 DO I = 2 , X + Y - 1 D = D * I END DO CALL RATNORM ( N , D ) END SUBROUTINE RBETA end module fgamma","tags":"","loc":"sourcefile/gamma.f90.html"},{"title":"help.f90 – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~help.f90~~AfferentGraph sourcefile~help.f90 help.f90 sourcefile~eval.f90 eval.f90 sourcefile~eval.f90->sourcefile~help.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~eval.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules help Source Code help.f90 Source Code module help use , intrinsic :: iso_fortran_env , only : stderr => output_unit implicit none contains subroutine print_help () ! Fortran doesn't know the location of its executable, making it interested to read a help file in a relative location. print * , achar ( 13 ), 'See README.md for complete documentation' print * , 'https://github.com/scivision/rpn-calc-fortran' , new_line ( '' ) print * , 'Mode calculator is in:   MODES' print * , 'Stack:  R - roll down     U - roll up      D - drop' print * , '        CLALL - clear all     CLS - Clear stack' print * , 'Number systems:     REAL     COMPLEX     RATIONAL' print * , 'Angular systems:    DEG     RAD     GRAD' print * , 'Number base:  BIN    DEC    HEX    OCT' print * , 'Register memory:  STOx   RCLx   where x ~ 0..9' end subroutine print_help end module help","tags":"","loc":"sourcefile/help.f90.html"},{"title":"hyper.F90 – RPN calculator in Fortran","text":"This file depends on sourcefile~~hyper.f90~~EfferentGraph sourcefile~hyper.f90 hyper.F90 sourcefile~reg.f90 reg.f90 sourcefile~hyper.f90->sourcefile~reg.f90 sourcefile~rat.f90 rat.f90 sourcefile~hyper.f90->sourcefile~rat.f90 sourcefile~rat.f90->sourcefile~reg.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~hyper.f90~~AfferentGraph sourcefile~hyper.f90 hyper.F90 sourcefile~gamma.f90 gamma.f90 sourcefile~gamma.f90->sourcefile~hyper.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~hyper.f90 sourcefile~funcs.f90->sourcefile~gamma.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules hyper Source Code hyper.F90 Source Code module hyper use , intrinsic :: ieee_arithmetic use , intrinsic :: iso_fortran_env , only : stderr => error_unit use assert , only : wp use rat , only : SWITCH_RAT_TO_REAL use global implicit none interface sech procedure sech_r , sech_c end interface sech interface asech procedure asech_r , asech_c end interface asech interface csch procedure csch_r , csch_c end interface csch interface acsch procedure acsch_r , acsch_c end interface acsch interface coth procedure coth_r , coth_c end interface coth interface acoth procedure acoth_r , acoth_c end interface acoth contains !*********************************************************************************************************************************** !  SECH ! !  Hyperbolic secant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION SECH_r ( X ) result ( sech ) real ( wp ), INTENT ( IN ) :: X sech = 1._wp / COSH ( X ) END FUNCTION SECH_r elemental complex ( wp ) FUNCTION SECH_c ( Z ) RESULT ( sech ) COMPLEX ( wp ), INTENT ( IN ) :: Z sech = 1._wp / cosh ( Z ) END FUNCTION SECH_c !*********************************************************************************************************************************** !  ASECH ! !  Inverse hyperbolic secant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ASECH_r ( y ) result ( asech ) real ( wp ), INTENT ( IN ) :: Y asech = ACOSH ( 1._wp / Y ) END FUNCTION ASECH_r elemental complex ( wp ) FUNCTION ASECH_c ( Y ) result ( asech ) COMPLEX ( wp ), INTENT ( IN ) :: Y #ifdef F08HYPER asech = ACOSH ( 1._wp / Y ) #else asech = ieee_value ( 1. , ieee_quiet_nan ) #endif END FUNCTION ASECH_c !*********************************************************************************************************************************** !  CSCH ! !  Hyperbolic cosecant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION CSCH_r ( X ) RESULT ( Y ) real ( wp ), INTENT ( IN ) :: X Y = 1._wp / SINH ( X ) END FUNCTION CSCH_r elemental complex ( wp ) FUNCTION CSCH_c ( Z ) RESULT ( Y ) COMPLEX ( wp ), INTENT ( IN ) :: Z Y = 1._wp / SINH ( Z ) END FUNCTION CSCH_c !*********************************************************************************************************************************** !  ACSCH ! !  Inverse hyperbolic cosecant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ACSCH_r ( Y ) RESULT ( X ) real ( wp ), INTENT ( IN ) :: Y X = ASINH ( 1._wp / Y ) END FUNCTION ACSCH_r elemental complex ( wp ) FUNCTION ACSCH_c ( Y ) RESULT ( X ) COMPLEX ( wp ), INTENT ( IN ) :: Y #ifdef F08HYPER X = ASINH ( 1._wp / Y ) #else X = ieee_value ( 1. , ieee_quiet_nan ) #endif END FUNCTION ACSCH_c !*********************************************************************************************************************************** !  COTH ! !  Hyperbolic cotangent. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION COTH_r ( X ) result ( coth ) real ( wp ), INTENT ( IN ) :: X coth = 1._wp / TANH ( X ) END FUNCTION COTH_r elemental complex ( wp ) FUNCTION COTH_c ( Z ) result ( coth ) COMPLEX ( wp ), INTENT ( IN ) :: Z COTH = 1._wp / tanh ( Z ) END FUNCTION COTH_c !*********************************************************************************************************************************** !  ACOTH ! !  Inverse hyperbolic cotangent. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ACOTH_r ( Y ) result ( acoth ) real ( wp ), INTENT ( IN ) :: Y ACOTH = ATANH ( 1._wp / Y ) END FUNCTION ACOTH_r elemental complex ( wp ) FUNCTION ACOTH_c ( Z ) result ( acoth ) COMPLEX ( wp ), INTENT ( IN ) :: Z acoth = 0.5_wp * LOG (( Z + 1._wp ) / ( Z - 1._wp )) END FUNCTION ACOTH_c !------------------------------------------------- subroutine hasin ( domain_mode ) integer , intent ( in ) :: domain_mode SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) LASTX = STACK ( 1 ) STACK ( 1 ) = ASINH ( STACK ( 1 )) CASE ( 2 ) #ifdef F08HYPER CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ASINH ( CSTACK ( 1 )) #else write ( stderr , * ) 'your compiler  does not yet support complex ASINH' #endif CASE ( 3 ) CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ASINH ( STACK ( 1 )) END SELECT end subroutine hasin subroutine hacos ( domain_mode ) integer , intent ( in ) :: domain_mode SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( STACK ( 1 ) < 1._wp ) THEN write ( stderr , * ) '  ACOSH Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ACOSH ( STACK ( 1 )) END IF CASE ( 2 ) #ifdef F08HYPER CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ACOSH ( CSTACK ( 1 )) #else write ( stderr , * ) 'your compiler  does not yet support complex ASINH' #endif CASE ( 3 ) IF ( RNSTACK ( 1 ) < RDSTACK ( 1 )) THEN write ( stderr , * ) '  ACOSH Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ACOSH ( STACK ( 1 )) END IF END SELECT end subroutine hacos subroutine hatan ( domain_mode ) integer , intent ( in ) :: domain_mode SELECT CASE ( DOMAIN_MODE ) CASE ( 1 ) IF ( ABS ( STACK ( 1 )) >= 1._wp ) THEN write ( stderr , * ) '  ATANH Error' ELSE LASTX = STACK ( 1 ) STACK ( 1 ) = ATANH ( STACK ( 1 )) END IF CASE ( 2 ) #ifdef F08HYPER CLASTX = CSTACK ( 1 ) CSTACK ( 1 ) = ATANH ( CSTACK ( 1 )) #else write ( stderr , * ) 'your compiler  does not yet support complex ASINH' #endif CASE ( 3 ) IF ( ABS ( RNSTACK ( 1 )) >= ABS ( RDSTACK ( 1 ))) THEN write ( stderr , * ) '  ATANH Error' ELSE CALL SWITCH_RAT_TO_REAL LASTX = STACK ( 1 ) STACK ( 1 ) = ATANH ( STACK ( 1 )) END IF END SELECT end subroutine hatan end module hyper","tags":"","loc":"sourcefile/hyper.f90.html"},{"title":"i0.f – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~i0.f~~AfferentGraph sourcefile~i0.f i0.f sourcefile~bessel.f90 bessel.f90 sourcefile~bessel.f90->sourcefile~i0.f sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules i0 Source Code i0.f Source Code module i0 implicit none private public :: besi0 contains SUBROUTINE CALCI0 ( ARG , RESULT , JINT ) C-------------------------------------------------------------------- C C This packet computes modified Bessel functions of the first kind C   and order zero, I0(X) and EXP(-ABS(X))*I0(X), for real C   arguments X.  It contains two function type subprograms, BESI0 C   and BESEI0, and one subroutine type subprogram, CALCI0. C   The calling statements for the primary entries are C C                   Y=BESI0(X) C   and C                   Y=BESEI0(X) C C   where the entry points correspond to the functions I0(X) and C   EXP(-ABS(X))*I0(X), respectively.  The routine CALCI0 is C   intended for internal packet use only, all computations within C   the packet being concentrated in this routine.  The function C   subprograms invoke CALCI0 with the statement C          CALL CALCI0(ARG,RESULT,JINT) C   where the parameter usage is as follows C C      Function                     Parameters for CALCI0 C       Call              ARG                  RESULT          JINT C C     BESI0(ARG)    ABS(ARG) .LE. XMAX        I0(ARG)           1 C     BESEI0(ARG)    any real ARG        EXP(-ABS(ARG))*I0(ARG) 2 C C   The main computation evaluates slightly modified forms of C   minimax approximations generated by Blair and Edwards, Chalk C   River (Atomic Energy of Canada Limited) Report AECL-4928, C   October, 1974.  This transportable program is patterned after C   the machine-dependent FUNPACK packet NATSI0, but cannot match C   that version for efficiency or accuracy.  This version uses C   rational functions that theoretically approximate I-SUB-0(X) C   to at least 18 significant decimal digits.  The accuracy C   achieved depends on the arithmetic system, the compiler, the C   intrinsic functions, and proper selection of the machine- C   dependent constants. C C******************************************************************* C******************************************************************* C C Explanation of machine-dependent constants C C   beta   = Radix for the floating-point system C   maxexp = Smallest power of beta that overflows C   XSMALL = Positive argument such that 1.0 - X = 1.0 to C            machine precision for all ABS(X) .LE. XSMALL. C   XINF =   Largest positive machine number; approximately C            beta**maxexp C   XMAX =   Largest argument acceptable to BESI0;  Solution to C            equation: C               W(X) * (1+1/(8*X)+9/(128*X**2) = beta**maxexp C            where  W(X) = EXP(X)/SQRT(2*PI*X) C C C     Approximate values for some important machines are: C C                          beta       maxexp       XSMALL C C CRAY-1        (S.P.)       2         8191       3.55E-15 C Cyber 180/855 C   under NOS   (S.P.)       2         1070       3.55E-15 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)       2          128       2.98E-8 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)       2         1024       5.55D-17 C IBM 3033      (D.P.)      16           63       6.95D-18 C VAX           (S.P.)       2          127       2.98E-8 C VAX D-Format  (D.P.)       2          127       6.95D-18 C VAX G-Format  (D.P.)       2         1023       5.55D-17 C C C                               XINF          XMAX C C CRAY-1        (S.P.)       5.45E+2465     5682.810 C Cyber 180/855 C   under NOS   (S.P.)       1.26E+322       745.893 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)       3.40E+38         91.900 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)       1.79D+308       713.986 C IBM 3033      (D.P.)       7.23D+75        178.182 C VAX           (S.P.)       1.70D+38         91.203 C VAX D-Format  (D.P.)       1.70D+38         91.203 C VAX G-Format  (D.P.)       8.98D+307       713.293 C C******************************************************************* C******************************************************************* C C Error returns C C  The program returns XINF for BESI0 for ABS(ARG) .GT. XMAX. C C C  Intrinsic functions required are: C C     ABS, SQRT, EXP C C C  Authors: W. J. Cody and L. Stoltz C           Mathematics and Computer Science Division C           Argonne National Laboratory C           Argonne, IL 60439 C C  Latest modification: June 7, 1988 C C-------------------------------------------------------------------- INTEGER I , JINT CS    REAL DOUBLE PRECISION 1 A , ARG , B , EXP40 , FORTY , ONE , ONE5 , P , PP , Q , QQ , RESULT , 2 REC15 , SUMP , SUMQ , TWO25 , X , XINF , XMAX , XSMALL , XX DIMENSION P ( 15 ), PP ( 8 ), Q ( 5 ), QQ ( 7 ) C-------------------------------------------------------------------- C  Mathematical constants C-------------------------------------------------------------------- CS    DATA ONE/1.0E0/,ONE5/15.0E0/,EXP40/2.353852668370199854E17/, CS   1     FORTY/40.0E0/,REC15/6.6666666666666666666E-2/, CS   2     TWO25/225.0E0/ CD    DATA ONE/1.0D0/,ONE5/15.0D0/,EXP40/2.353852668370199854D17/, CD   1     FORTY/40.0D0/,REC15/6.6666666666666666666D-2/, CD   2     TWO25/225.0D0/ C-------------------------------------------------------------------- C  Machine-dependent constants C-------------------------------------------------------------------- CS    DATA XSMALL/2.98E-8/,XINF/3.40E38/,XMAX/91.9E0/ CD    DATA XSMALL/5.55D-17/,XINF/1.79D308/,XMAX/713.986D0/ C-------------------------------------------------------------------- C  Coefficients for XSMALL .LE. ABS(ARG) .LT. 15.0 C-------------------------------------------------------------------- CS    DATA  P/-5.2487866627945699800E-18,-1.5982226675653184646E-14, CS   1        -2.6843448573468483278E-11,-3.0517226450451067446E-08, CS   2        -2.5172644670688975051E-05,-1.5453977791786851041E-02, CS   3        -7.0935347449210549190E+00,-2.4125195876041896775E+03, CS   4        -5.9545626019847898221E+05,-1.0313066708737980747E+08, CS   5        -1.1912746104985237192E+10,-8.4925101247114157499E+11, CS   6        -3.2940087627407749166E+13,-5.5050369673018427753E+14, CS   7        -2.2335582639474375249E+15/ CS    DATA  Q/-3.7277560179962773046E+03, 6.5158506418655165707E+06, CS   1        -6.5626560740833869295E+09, 3.7604188704092954661E+12, CS   2        -9.7087946179594019126E+14/ CD    DATA  P/-5.2487866627945699800D-18,-1.5982226675653184646D-14, CD   1        -2.6843448573468483278D-11,-3.0517226450451067446D-08, CD   2        -2.5172644670688975051D-05,-1.5453977791786851041D-02, CD   3        -7.0935347449210549190D+00,-2.4125195876041896775D+03, CD   4        -5.9545626019847898221D+05,-1.0313066708737980747D+08, CD   5        -1.1912746104985237192D+10,-8.4925101247114157499D+11, CD   6        -3.2940087627407749166D+13,-5.5050369673018427753D+14, CD   7        -2.2335582639474375249D+15/ CD    DATA  Q/-3.7277560179962773046D+03, 6.5158506418655165707D+06, CD   1        -6.5626560740833869295D+09, 3.7604188704092954661D+12, CD   2        -9.7087946179594019126D+14/ C-------------------------------------------------------------------- C  Coefficients for 15.0 .LE. ABS(ARG) C-------------------------------------------------------------------- CS    DATA PP/-3.9843750000000000000E-01, 2.9205384596336793945E+00, CS   1        -2.4708469169133954315E+00, 4.7914889422856814203E-01, CS   2        -3.7384991926068969150E-03,-2.6801520353328635310E-03, CS   3         9.9168777670983678974E-05,-2.1877128189032726730E-06/ CS    DATA QQ/-3.1446690275135491500E+01, 8.5539563258012929600E+01, CS   1        -6.0228002066743340583E+01, 1.3982595353892851542E+01, CS   2        -1.1151759188741312645E+00, 3.2547697594819615062E-02, CS   3        -5.5194330231005480228E-04/ CD    DATA PP/-3.9843750000000000000D-01, 2.9205384596336793945D+00, CD   1        -2.4708469169133954315D+00, 4.7914889422856814203D-01, CD   2        -3.7384991926068969150D-03,-2.6801520353328635310D-03, CD   3         9.9168777670983678974D-05,-2.1877128189032726730D-06/ CD    DATA QQ/-3.1446690275135491500D+01, 8.5539563258012929600D+01, CD   1        -6.0228002066743340583D+01, 1.3982595353892851542D+01, CD   2        -1.1151759188741312645D+00, 3.2547697594819615062D-02, CD   3        -5.5194330231005480228D-04/ C-------------------------------------------------------------------- X = ABS ( ARG ) IF ( X . LT . XSMALL ) THEN RESULT = ONE ELSE IF ( X . LT . ONE5 ) THEN C-------------------------------------------------------------------- C  XSMALL .LE.  ABS(ARG)  .LT. 15.0 C-------------------------------------------------------------------- XX = X * X SUMP = P ( 1 ) DO 50 I = 2 , 15 SUMP = SUMP * XX + P ( I ) 50 CONTINUE XX = XX - TWO25 SUMQ = (((( XX + Q ( 1 )) * XX + Q ( 2 )) * XX + Q ( 3 )) * XX + Q ( 4 )) * XX + Q ( 5 ) RESULT = SUMP / SUMQ IF ( JINT . EQ . 2 ) RESULT = RESULT * EXP ( - X ) ELSE IF ( X . GE . ONE5 ) THEN IF (( JINT . EQ . 1 ) . AND . ( X . GT . XMAX )) THEN RESULT = XINF ELSE C-------------------------------------------------------------------- C  15.0  .LE.  ABS(ARG) C-------------------------------------------------------------------- XX = ONE / X - REC15 SUMP = (((((( PP ( 1 ) * XX + PP ( 2 )) * XX + PP ( 3 )) * XX + PP ( 4 )) * XX + 1 PP ( 5 )) * XX + PP ( 6 )) * XX + PP ( 7 )) * XX + PP ( 8 ) SUMQ = (((((( XX + QQ ( 1 )) * XX + QQ ( 2 )) * XX + QQ ( 3 )) * XX + 1 QQ ( 4 )) * XX + QQ ( 5 )) * XX + QQ ( 6 )) * XX + QQ ( 7 ) RESULT = SUMP / SUMQ IF ( JINT . EQ . 2 ) THEN RESULT = ( RESULT - PP ( 1 )) / SQRT ( X ) ELSE C-------------------------------------------------------------------- C  Calculation reformulated to avoid premature overflow C-------------------------------------------------------------------- IF ( X . LE .( XMAX - ONE5 )) THEN A = EXP ( X ) B = ONE ELSE A = EXP ( X - FORTY ) B = EXP40 END IF RESULT = (( RESULT * A - PP ( 1 ) * A ) / SQRT ( X )) * B END IF END IF END IF C-------------------------------------------------------------------- C  Return for ABS(ARG) .LT. XSMALL C-------------------------------------------------------------------- RETURN C----------- Last line of CALCI0 ----------- END subroutine calci0 CS    REAL DOUBLE PRECISION FUNCTION BESI0 ( X ) C-------------------------------------------------------------------- C C This long precision subprogram computes approximate values for C   modified Bessel functions of the first kind of order zero for C   arguments ABS(ARG) .LE. XMAX  (see comments heading CALCI0). C C-------------------------------------------------------------------- INTEGER JINT CS    REAL DOUBLE PRECISION X , RESULT C-------------------------------------------------------------------- JINT = 1 CALL CALCI0 ( X , RESULT , JINT ) BESI0 = RESULT RETURN C---------- Last line of BESI0 ---------- END function besi0 CS    REAL DOUBLE PRECISION FUNCTION BESEI0 ( X ) C-------------------------------------------------------------------- C C This function program computes approximate values for the C   modified Bessel function of the first kind of order zero C   multiplied by EXP(-ABS(X)), where EXP is the C   exponential function, ABS is the absolute value, and X C   is any argument. C C-------------------------------------------------------------------- INTEGER JINT CS    REAL DOUBLE PRECISION X , RESULT C-------------------------------------------------------------------- JINT = 2 CALL CALCI0 ( X , RESULT , JINT ) BESEI0 = RESULT RETURN C---------- Last line of BESEI0 ---------- END function besei0 end module i0","tags":"","loc":"sourcefile/i0.f.html"},{"title":"i1.f – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~i1.f~~AfferentGraph sourcefile~i1.f i1.f sourcefile~bessel.f90 bessel.f90 sourcefile~bessel.f90->sourcefile~i1.f sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules i1 Source Code i1.f Source Code module i1 implicit none private public :: besi1 contains SUBROUTINE CALCI1 ( ARG , RESULT , JINT ) C-------------------------------------------------------------------- C C This packet computes modified Bessel functioons of the first kind C   and order one, I1(X) and EXP(-ABS(X))*I1(X), for real C   arguments X.  It contains two function type subprograms, BESI1 C   and BESEI1, and one subroutine type subprogram, CALCI1. C   The calling statements for the primary entries are C C                   Y=BESI1(X) C   and C                   Y=BESEI1(X) C C   where the entry points correspond to the functions I1(X) and C   EXP(-ABS(X))*I1(X), respectively.  The routine CALCI1 is C   intended for internal packet use only, all computations within C   the packet being concentrated in this routine.  The function C   subprograms invoke CALCI1 with the statement C          CALL CALCI1(ARG,RESULT,JINT) C   where the parameter usage is as follows C C      Function                     Parameters for CALCI1 C       Call              ARG                  RESULT          JINT C C     BESI1(ARG)    ABS(ARG) .LE. XMAX        I1(ARG)           1 C     BESEI1(ARG)    any real ARG        EXP(-ABS(ARG))*I1(ARG) 2 C C   The main computation evaluates slightly modified forms of C   minimax approximations generated by Blair and Edwards, Chalk C   River (Atomic Energy of Canada Limited) Report AECL-4928, C   October, 1974.  This transportable program is patterned after C   the machine-dependent FUNPACK packet NATSI1, but cannot match C   that version for efficiency or accuracy.  This version uses C   rational functions that theoretically approximate I-SUB-1(X) C   to at least 18 significant decimal digits.  The accuracy C   achieved depends on the arithmetic system, the compiler, the C   intrinsic functions, and proper selection of the machine- C   dependent constants. C C******************************************************************* C******************************************************************* C C Explanation of machine-dependent constants C C   beta   = Radix for the floating-point system C   maxexp = Smallest power of beta that overflows C   XSMALL = Positive argument such that 1.0 - X = 1.0 to C            machine precision for all ABS(X) .LE. XSMALL. C   XINF =   Largest positive machine number; approximately C            beta**maxexp C   XMAX =   Largest argument acceptable to BESI1;  Solution to C            equation: C               EXP(X) * (1-3/(8*X)) / SQRT(2*PI*X) = beta**maxexp C C C     Approximate values for some important machines are: C C                          beta       maxexp       XSMALL C C CRAY-1        (S.P.)       2         8191       3.55E-15 C Cyber 180/855 C   under NOS   (S.P.)       2         1070       3.55E-15 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)       2          128       2.98E-8 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)       2         1024       5.55D-17 C IBM 3033      (D.P.)      16           63       6.95D-18 C VAX           (S.P.)       2          127       2.98E-8 C VAX D-Format  (D.P.)       2          127       6.95D-18 C VAX G-Format  (D.P.)       2         1023       5.55D-17 C C C                               XINF          XMAX C C CRAY-1        (S.P.)       5.45E+2465     5682.810 C Cyber 180/855 C   under NOS   (S.P.)       1.26E+322       745.894 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)       3.40E+38         91.906 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)       1.79D+308       713.987 C IBM 3033      (D.P.)       7.23D+75        178.185 C VAX           (S.P.)       1.70D+38         91.209 C VAX D-Format  (D.P.)       1.70D+38         91.209 C VAX G-Format  (D.P.)       8.98D+307       713.293 C C******************************************************************* C******************************************************************* C C Error returns C C  The program returns the value XINF for ABS(ARG) .GT. XMAX. C C C Intrinsic functions required are: C C     ABS, SQRT, EXP C C C  Authors: W. J. Cody and L. Stoltz C           Mathematics and Computer Science Division C           Argonne National Laboratory C           Argonne, IL  60439 C C  Latest modification: May 31, 1989 C C-------------------------------------------------------------------- INTEGER J , JINT CS    REAL DOUBLE PRECISION 1 A , ARG , B , EXP40 , FORTY , HALF , ONE , ONE5 , P , PBAR , PP , Q , QQ , REC15 , 2 RESULT , SUMP , SUMQ , TWO25 , X , XINF , XMAX , XSMALL , XX , ZERO DIMENSION P ( 15 ), PP ( 8 ), Q ( 5 ), QQ ( 6 ) C-------------------------------------------------------------------- C  Mathematical constants C-------------------------------------------------------------------- CS    DATA ONE/1.0E0/,ONE5/15.0E0/,EXP40/2.353852668370199854E17/, CS   1     FORTY/40.0E0/,REC15/6.6666666666666666666E-2/, CS   2     TWO25/225.0E0/,HALF/0.5E0/,ZERO/0.0E0/ CD    DATA ONE/1.0D0/,ONE5/15.0D0/,EXP40/2.353852668370199854D17/, CD   1     FORTY/40.0D0/,REC15/6.6666666666666666666D-2/, CD   2     TWO25/225.0D0/,HALF/0.5D0/,ZERO/0.0D0/ C-------------------------------------------------------------------- C  Machine-dependent constants C-------------------------------------------------------------------- CS    DATA XSMALL/2.98E-8/,XINF/3.4E38/,XMAX/91.906E0/ CD    DATA XSMALL/5.55D-17/,XINF/1.79D308/,XMAX/713.987D0/ C-------------------------------------------------------------------- C  Coefficients for XSMALL .LE. ABS(ARG) .LT. 15.0 C-------------------------------------------------------------------- CS    DATA P/-1.9705291802535139930E-19,-6.5245515583151902910E-16, CS   1       -1.1928788903603238754E-12,-1.4831904935994647675E-09, CS   2       -1.3466829827635152875E-06,-9.1746443287817501309E-04, CS   3       -4.7207090827310162436E-01,-1.8225946631657315931E+02, CS   4       -5.1894091982308017540E+04,-1.0588550724769347106E+07, CS   5       -1.4828267606612366099E+09,-1.3357437682275493024E+11, CS   6       -6.9876779648010090070E+12,-1.7732037840791591320E+14, CS   7       -1.4577180278143463643E+15/ CD    DATA P/-1.9705291802535139930D-19,-6.5245515583151902910D-16, CD   1       -1.1928788903603238754D-12,-1.4831904935994647675D-09, CD   2       -1.3466829827635152875D-06,-9.1746443287817501309D-04, CD   3       -4.7207090827310162436D-01,-1.8225946631657315931D+02, CD   4       -5.1894091982308017540D+04,-1.0588550724769347106D+07, CD   5       -1.4828267606612366099D+09,-1.3357437682275493024D+11, CD   6       -6.9876779648010090070D+12,-1.7732037840791591320D+14, CD   7       -1.4577180278143463643D+15/ CS    DATA Q/-4.0076864679904189921E+03, 7.4810580356655069138E+06, CS   1       -8.0059518998619764991E+09, 4.8544714258273622913E+12, CS   2       -1.3218168307321442305E+15/ CD    DATA Q/-4.0076864679904189921D+03, 7.4810580356655069138D+06, CD   1       -8.0059518998619764991D+09, 4.8544714258273622913D+12, CD   2       -1.3218168307321442305D+15/ C-------------------------------------------------------------------- C  Coefficients for 15.0 .LE. ABS(ARG) C-------------------------------------------------------------------- CS    DATA PP/-6.0437159056137600000E-02, 4.5748122901933459000E-01, CS   1        -4.2843766903304806403E-01, 9.7356000150886612134E-02, CS   2        -3.2457723974465568321E-03,-3.6395264712121795296E-04, CS   3         1.6258661867440836395E-05,-3.6347578404608223492E-07/ CD    DATA PP/-6.0437159056137600000D-02, 4.5748122901933459000D-01, CD   1        -4.2843766903304806403D-01, 9.7356000150886612134D-02, CD   2        -3.2457723974465568321D-03,-3.6395264712121795296D-04, CD   3         1.6258661867440836395D-05,-3.6347578404608223492D-07/ CS    DATA QQ/-3.8806586721556593450E+00, 3.2593714889036996297E+00, CS   1        -8.5017476463217924408E-01, 7.4212010813186530069E-02, CS   2        -2.2835624489492512649E-03, 3.7510433111922824643E-05/ CD    DATA QQ/-3.8806586721556593450D+00, 3.2593714889036996297D+00, CD   1        -8.5017476463217924408D-01, 7.4212010813186530069D-02, CD   2        -2.2835624489492512649D-03, 3.7510433111922824643D-05/ CS    DATA PBAR/3.98437500E-01/ CD    DATA PBAR/3.98437500D-01/ C-------------------------------------------------------------------- X = ABS ( ARG ) IF ( X . LT . XSMALL ) THEN C-------------------------------------------------------------------- C  Return for ABS(ARG) .LT. XSMALL C-------------------------------------------------------------------- RESULT = HALF * X ELSE IF ( X . LT . ONE5 ) THEN C-------------------------------------------------------------------- C  XSMALL .LE. ABS(ARG) .LT. 15.0 C-------------------------------------------------------------------- XX = X * X SUMP = P ( 1 ) DO 50 J = 2 , 15 SUMP = SUMP * XX + P ( J ) 50 CONTINUE XX = XX - TWO25 SUMQ = (((( XX + Q ( 1 )) * XX + Q ( 2 )) * XX + Q ( 3 )) * XX + Q ( 4 )) 1 * XX + Q ( 5 ) RESULT = ( SUMP / SUMQ ) * X IF ( JINT . EQ . 2 ) RESULT = RESULT * EXP ( - X ) ELSE IF (( JINT . EQ . 1 ) . AND . ( X . GT . XMAX )) THEN RESULT = XINF ELSE C-------------------------------------------------------------------- C  15.0 .LE. ABS(ARG) C-------------------------------------------------------------------- XX = ONE / X - REC15 SUMP = (((((( PP ( 1 ) * XX + PP ( 2 )) * XX + PP ( 3 )) * XX + 1 PP ( 4 )) * XX + PP ( 5 )) * XX + PP ( 6 )) * XX + PP ( 7 )) * XX + PP ( 8 ) SUMQ = ((((( XX + QQ ( 1 )) * XX + QQ ( 2 )) * XX + QQ ( 3 )) * XX + 1 QQ ( 4 )) * XX + QQ ( 5 )) * XX + QQ ( 6 ) RESULT = SUMP / SUMQ IF ( JINT . NE . 1 ) THEN RESULT = ( RESULT + PBAR ) / SQRT ( X ) ELSE C-------------------------------------------------------------------- C  Calculation reformulated to avoid premature overflow C-------------------------------------------------------------------- IF ( X . GT . XMAX - ONE5 ) THEN A = EXP ( X - FORTY ) B = EXP40 ELSE A = EXP ( X ) B = ONE END IF RESULT = (( RESULT * A + PBAR * A ) / 1 SQRT ( X )) * B C-------------------------------------------------------------------- C  Error return for ABS(ARG) .GT. XMAX C-------------------------------------------------------------------- END IF END IF IF ( ARG . LT . ZERO ) RESULT = - RESULT RETURN C----------- Last line of CALCI1 ----------- END SUBROUTINE CALCI1 CS    REAL DOUBLE PRECISION FUNCTION BESI1 ( X ) C-------------------------------------------------------------------- C C This long precision subprogram computes approximate values for C   modified Bessel functions of the first kind of order one for C   arguments ABS(ARG) .LE. XMAX  (see comments heading CALCI1). C C-------------------------------------------------------------------- INTEGER JINT CS    REAL DOUBLE PRECISION 1 X , RESULT C-------------------------------------------------------------------- JINT = 1 CALL CALCI1 ( X , RESULT , JINT ) BESI1 = RESULT RETURN C---------- Last line of BESI1 ---------- END FUNCTION BESI1 CS    REAL DOUBLE PRECISION FUNCTION BESEI1 ( X ) C-------------------------------------------------------------------- C C This function program computes approximate values for the C   modified Bessel function of the first kind of order one C   multiplied by EXP(-ABS(X)), where EXP is the C   exponential function, ABS is the absolute value, and X C   is any argument. C C-------------------------------------------------------------------- INTEGER JINT CS    REAL DOUBLE PRECISION 1 X , RESULT C-------------------------------------------------------------------- JINT = 2 CALL CALCI1 ( X , RESULT , JINT ) BESEI1 = RESULT RETURN C---------- Last line of BESEI1 ---------- END FUNCTION BESEI1 end module i1","tags":"","loc":"sourcefile/i1.f.html"},{"title":"k0.f – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~k0.f~~AfferentGraph sourcefile~k0.f k0.f sourcefile~bessel.f90 bessel.f90 sourcefile~bessel.f90->sourcefile~k0.f sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules k0 Source Code k0.f Source Code module k0 implicit none private public :: besk0 contains SUBROUTINE CALCK0 ( ARG , RESULT , JINT ) C-------------------------------------------------------------------- C C This packet computes modified Bessel functions of the second kind C   and order zero, K0(X) and EXP(X)*K0(X), for real C   arguments X.  It contains two function type subprograms, BESK0 C   and BESEK0, and one subroutine type subprogram, CALCK0. C   the calling statements for the primary entries are C C                   Y=BESK0(X) C   and C                   Y=BESEK0(X) C C   where the entry points correspond to the functions K0(X) and C   EXP(X)*K0(X), respectively.  The routine CALCK0 is C   intended for internal packet use only, all computations within C   the packet being concentrated in this routine.  The function C   subprograms invoke CALCK0 with the statement C          CALL CALCK0(ARG,RESULT,JINT) C   where the parameter usage is as follows C C      Function                     Parameters for CALCK0 C       Call              ARG                  RESULT          JINT C C     BESK0(ARG)   0 .LT. ARG .LE. XMAX       K0(ARG)           1 C     BESEK0(ARG)     0 .LT. ARG           EXP(ARG)*K0(ARG)     2 C C   The main computation evaluates slightly modified forms of near C   minimax rational approximations generated by Russon and Blair, C   Chalk River (Atomic Energy of Canada Limited) Report AECL-3461, C   1969.  This transportable program is patterned after the C   machine-dependent FUNPACK packet NATSK0, but cannot match that C   version for efficiency or accuracy.  This version uses rational C   functions that theoretically approximate K-SUB-0(X) to at C   least 18 significant decimal digits.  The accuracy achieved C   depends on the arithmetic system, the compiler, the intrinsic C   functions, and proper selection of the machine-dependent C   constants. C C******************************************************************* C******************************************************************* C C Explanation of machine-dependent constants C C   beta   = Radix for the floating-point system C   minexp = Smallest representable power of beta C   maxexp = Smallest power of beta that overflows C   XSMALL = Argument below which BESK0 and BESEK0 may C            each be represented by a constant and a log. C            largest X such that  1.0 + X = 1.0  to machine C            precision. C   XINF   = Largest positive machine number; approximately C            beta**maxexp C   XMAX   = Largest argument acceptable to BESK0;  Solution to C            equation: C               W(X) * (1-1/8X+9/128X**2) = beta**minexp C            where  W(X) = EXP(-X)*SQRT(PI/2X) C C C     Approximate values for some important machines are: C C C                           beta       minexp       maxexp C C  CRAY-1        (S.P.)       2        -8193         8191 C  Cyber 180/185 C    under NOS   (S.P.)       2         -975         1070 C  IEEE (IBM/XT, C    SUN, etc.)  (S.P.)       2         -126          128 C  IEEE (IBM/XT, C    SUN, etc.)  (D.P.)       2        -1022         1024 C  IBM 3033      (D.P.)      16          -65           63 C  VAX D-Format  (D.P.)       2         -128          127 C  VAX G-Format  (D.P.)       2        -1024         1023 C C C                          XSMALL       XINF         XMAX C C CRAY-1        (S.P.)    3.55E-15   5.45E+2465    5674.858 C Cyber 180/855 C   under NOS   (S.P.)    1.77E-15   1.26E+322      672.788 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)    5.95E-8    3.40E+38        85.337 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)    1.11D-16   1.79D+308      705.342 C IBM 3033      (D.P.)    1.11D-16   7.23D+75       177.852 C VAX D-Format  (D.P.)    6.95D-18   1.70D+38        86.715 C VAX G-Format  (D.P.)    5.55D-17   8.98D+307      706.728 C C******************************************************************* C******************************************************************* C C Error returns C C  The program returns the value XINF for ARG .LE. 0.0, and the C  BESK0 entry returns the value 0.0 for ARG .GT. XMAX. C C C  Intrinsic functions required are: C C     EXP, LOG, SQRT C C  Latest modification: March 19, 1990 C C  Authors: W. J. Cody and Laura Stoltz C           Mathematics and Computer Science Division C           Argonne National Laboratory C           Argonne, IL 60439 C C-------------------------------------------------------------------- INTEGER I , JINT CS    REAL DOUBLE PRECISION 1 ARG , F , G , ONE , P , PP , Q , QQ , RESULT , SUMF , SUMG , SUMP , SUMQ , TEMP , 2 X , XINF , XMAX , XSMALL , XX , ZERO DIMENSION P ( 6 ), Q ( 2 ), PP ( 10 ), QQ ( 10 ), F ( 4 ), G ( 3 ) C-------------------------------------------------------------------- C  Mathematical constants C-------------------------------------------------------------------- CS    DATA ONE/1.0E0/,ZERO/0.0E0/ CD    DATA ONE/1.0D0/,ZERO/0.0D0/ C-------------------------------------------------------------------- C  Machine-dependent constants C-------------------------------------------------------------------- CS    DATA XSMALL/5.95E-8/,XINF/3.40E+38/,XMAX/ 85.337E0/ CD    DATA XSMALL/1.11D-16/,XINF/1.79D+308/,XMAX/705.342D0/ C-------------------------------------------------------------------- C C     Coefficients for XSMALL .LE.  ARG  .LE. 1.0 C C-------------------------------------------------------------------- CS    DATA   P/ 5.8599221412826100000E-04, 1.3166052564989571850E-01, CS   1          1.1999463724910714109E+01, 4.6850901201934832188E+02, CS   2          5.9169059852270512312E+03, 2.4708152720399552679E+03/ CS    DATA   Q/-2.4994418972832303646E+02, 2.1312714303849120380E+04/ CS    DATA   F/-1.6414452837299064100E+00,-2.9601657892958843866E+02, CS   1         -1.7733784684952985886E+04,-4.0320340761145482298E+05/ CS    DATA   G/-2.5064972445877992730E+02, 2.9865713163054025489E+04, CS   1         -1.6128136304458193998E+06/ CD    DATA   P/ 5.8599221412826100000D-04, 1.3166052564989571850D-01, CD   1          1.1999463724910714109D+01, 4.6850901201934832188D+02, CD   2          5.9169059852270512312D+03, 2.4708152720399552679D+03/ CD    DATA   Q/-2.4994418972832303646D+02, 2.1312714303849120380D+04/ CD    DATA   F/-1.6414452837299064100D+00,-2.9601657892958843866D+02, CD   1         -1.7733784684952985886D+04,-4.0320340761145482298D+05/ CD    DATA   G/-2.5064972445877992730D+02, 2.9865713163054025489D+04, CD   1         -1.6128136304458193998D+06/ C-------------------------------------------------------------------- C C     Coefficients for  1.0 .LT. ARG C C-------------------------------------------------------------------- CS    DATA  PP/ 1.1394980557384778174E+02, 3.6832589957340267940E+03, CS   1          3.1075408980684392399E+04, 1.0577068948034021957E+05, CS   2          1.7398867902565686251E+05, 1.5097646353289914539E+05, CS   3          7.1557062783764037541E+04, 1.8321525870183537725E+04, CS   4          2.3444738764199315021E+03, 1.1600249425076035558E+02/ CS    DATA  QQ/ 2.0013443064949242491E+02, 4.4329628889746408858E+03, CS   1          3.1474655750295278825E+04, 9.7418829762268075784E+04, CS   2          1.5144644673520157801E+05, 1.2689839587977598727E+05, CS   3          5.8824616785857027752E+04, 1.4847228371802360957E+04, CS   4          1.8821890840982713696E+03, 9.2556599177304839811E+01/ CD    DATA  PP/ 1.1394980557384778174D+02, 3.6832589957340267940D+03, CD   1          3.1075408980684392399D+04, 1.0577068948034021957D+05, CD   2          1.7398867902565686251D+05, 1.5097646353289914539D+05, CD   3          7.1557062783764037541D+04, 1.8321525870183537725D+04, CD   4          2.3444738764199315021D+03, 1.1600249425076035558D+02/ CD    DATA  QQ/ 2.0013443064949242491D+02, 4.4329628889746408858D+03, CD   1          3.1474655750295278825D+04, 9.7418829762268075784D+04, CD   2          1.5144644673520157801D+05, 1.2689839587977598727D+05, CD   3          5.8824616785857027752D+04, 1.4847228371802360957D+04, CD   4          1.8821890840982713696D+03, 9.2556599177304839811D+01/ C-------------------------------------------------------------------- X = ARG IF ( X . GT . ZERO ) THEN IF ( X . LE . ONE ) THEN C-------------------------------------------------------------------- C     0.0 .LT.  ARG  .LE. 1.0 C-------------------------------------------------------------------- TEMP = LOG ( X ) IF ( X . LT . XSMALL ) THEN C-------------------------------------------------------------------- C     Return for small ARG C-------------------------------------------------------------------- RESULT = P ( 6 ) / Q ( 2 ) - TEMP ELSE XX = X * X SUMP = (((( P ( 1 ) * XX + P ( 2 )) * XX + P ( 3 )) * XX + 1 P ( 4 )) * XX + P ( 5 )) * XX + P ( 6 ) SUMQ = ( XX + Q ( 1 )) * XX + Q ( 2 ) SUMF = (( F ( 1 ) * XX + F ( 2 )) * XX + F ( 3 )) * XX + F ( 4 ) SUMG = (( XX + G ( 1 )) * XX + G ( 2 )) * XX + G ( 3 ) RESULT = SUMP / SUMQ - XX * SUMF * TEMP / SUMG - TEMP IF ( JINT . EQ . 2 ) RESULT = RESULT * EXP ( X ) END IF ELSE IF (( JINT . EQ . 1 ) . AND . ( X . GT . XMAX )) THEN C-------------------------------------------------------------------- C     Error return for ARG .GT. XMAX C-------------------------------------------------------------------- RESULT = ZERO ELSE C-------------------------------------------------------------------- C     1.0 .LT. ARG C-------------------------------------------------------------------- XX = ONE / X SUMP = PP ( 1 ) DO 120 I = 2 , 10 SUMP = SUMP * XX + PP ( I ) 120 CONTINUE SUMQ = XX DO 140 I = 1 , 9 SUMQ = ( SUMQ + QQ ( I )) * XX 140 CONTINUE SUMQ = SUMQ + QQ ( 10 ) RESULT = SUMP / SUMQ / SQRT ( X ) IF ( JINT . EQ . 1 ) RESULT = RESULT * EXP ( - X ) END IF ELSE C-------------------------------------------------------------------- C     Error return for ARG .LE. 0.0 C-------------------------------------------------------------------- RESULT = XINF END IF C-------------------------------------------------------------------- C     Update error counts, etc. C-------------------------------------------------------------------- RETURN C---------- Last line of CALCK0 ---------- END SUBROUTINE CALCK0 CS    REAL DOUBLE PRECISION FUNCTION BESK0 ( X ) C-------------------------------------------------------------------- C C This function program computes approximate values for the C   modified Bessel function of the second kind of order zero C   for arguments 0.0 .LT. ARG .LE. XMAX (see comments heading C   CALCK0). C C  Authors: W. J. Cody and Laura Stoltz C C  Latest Modification: January 19, 1988 C C-------------------------------------------------------------------- INTEGER JINT CS    REAL DOUBLE PRECISION X , RESULT C-------------------------------------------------------------------- JINT = 1 CALL CALCK0 ( X , RESULT , JINT ) BESK0 = RESULT RETURN C---------- Last line of BESK0 ---------- END FUNCTION BESK0 CS    REAL DOUBLE PRECISION FUNCTION BESEK0 ( X ) C-------------------------------------------------------------------- C C This function program computes approximate values for the C   modified Bessel function of the second kind of order zero C   multiplied by the Exponential function, for arguments C   0.0 .LT. ARG. C C  Authors: W. J. Cody and Laura Stoltz C C  Latest Modification: January 19, 1988 C C-------------------------------------------------------------------- INTEGER JINT CS    REAL DOUBLE PRECISION X , RESULT C-------------------------------------------------------------------- JINT = 2 CALL CALCK0 ( X , RESULT , JINT ) BESEK0 = RESULT RETURN C---------- Last line of BESEK0 ---------- END FUNCTION BESEK0 end module k0","tags":"","loc":"sourcefile/k0.f.html"},{"title":"k1.f – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~k1.f~~AfferentGraph sourcefile~k1.f k1.f sourcefile~bessel.f90 bessel.f90 sourcefile~bessel.f90->sourcefile~k1.f sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules k1 Source Code k1.f Source Code module k1 implicit none private public :: besk1 contains SUBROUTINE CALCK1 ( ARG , RESULT , JINT ) C-------------------------------------------------------------------- C C This packet computes modified Bessel functions of the second kind C   and order one,  K1(X)  and  EXP(X)*K1(X), for real arguments X. C   It contains two function type subprograms, BESK1  and  BESEK1, C   and one subroutine type subprogram, CALCK1.  The calling C   statements for the primary entries are C C                   Y=BESK1(X) C   and C                   Y=BESEK1(X) C C   where the entry points correspond to the functions K1(X) and C   EXP(X)*K1(X), respectively.  The routine CALCK1 is intended C   for internal packet use only, all computations within the C   packet being concentrated in this routine.  The function C   subprograms invoke CALCK1 with the statement C          CALL CALCK1(ARG,RESULT,JINT) C   where the parameter usage is as follows C C      Function                      Parameters for CALCK1 C        Call             ARG                  RESULT          JINT C C     BESK1(ARG)  XLEAST .LT. ARG .LT. XMAX    K1(ARG)          1 C     BESEK1(ARG)     XLEAST .LT. ARG       EXP(ARG)*K1(ARG)    2 C C   The main computation evaluates slightly modified forms of near C   minimax rational approximations generated by Russon and Blair, C   Chalk River (Atomic Energy of Canada Limited) Report AECL-3461, C   1969.  This transportable program is patterned after the C   machine-dependent FUNPACK packet NATSK1, but cannot match that C   version for efficiency or accuracy.  This version uses rational C   functions that theoretically approximate K-SUB-1(X) to at C   least 18 significant decimal digits.  The accuracy achieved C   depends on the arithmetic system, the compiler, the intrinsic C   functions, and proper selection of the machine-dependent C   constants. C C******************************************************************* C******************************************************************* C C Explanation of machine-dependent constants C C   beta   = Radix for the floating-point system C   minexp = Smallest representable power of beta C   maxexp = Smallest power of beta that overflows C   XLEAST = Smallest acceptable argument, i.e., smallest machine C            number X such that 1/X is machine representable. C   XSMALL = Argument below which BESK1(X) and BESEK1(X) may C            each be represented by 1/X.  A safe value is the C            largest X such that  1.0 + X = 1.0  to machine C            precision. C   XINF   = Largest positive machine number; approximately C            beta**maxexp C   XMAX   = Largest argument acceptable to BESK1;  Solution to C            equation: C               W(X) * (1+3/8X-15/128X**2) = beta**minexp C            where  W(X) = EXP(-X)*SQRT(PI/2X) C C C     Approximate values for some important machines are: C C                           beta       minexp       maxexp C C  CRAY-1        (S.P.)       2        -8193         8191 C  Cyber 180/185 C    under NOS   (S.P.)       2         -975         1070 C  IEEE (IBM/XT, C    SUN, etc.)  (S.P.)       2         -126          128 C  IEEE (IBM/XT, C    SUN, etc.)  (D.P.)       2        -1022         1024 C  IBM 3033      (D.P.)      16          -65           63 C  VAX D-Format  (D.P.)       2         -128          127 C  VAX G-Format  (D.P.)       2        -1024         1023 C C C                         XLEAST     XSMALL      XINF       XMAX C C CRAY-1                1.84E-2466  3.55E-15  5.45E+2465  5674.858 C Cyber 180/855 C   under NOS   (S.P.)  3.14E-294   1.77E-15  1.26E+322    672.789 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)  1.18E-38    5.95E-8   3.40E+38      85.343 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)  2.23D-308   1.11D-16  1.79D+308    705.343 C IBM 3033      (D.P.)  1.39D-76    1.11D-16  7.23D+75     177.855 C VAX D-Format  (D.P.)  5.88D-39    6.95D-18  1.70D+38      86.721 C VAX G-Format  (D.P.)  1.12D-308   5.55D-17  8.98D+307    706.728 C C******************************************************************* C******************************************************************* C C Error returns C C  The program returns the value XINF for ARG .LE. 0.0 and the C   BESK1 entry returns the value 0.0 for ARG .GT. XMAX. C C C  Intrinsic functions required are: C C     LOG, SQRT, EXP C C C  Authors: W. J. Cody and Laura Stoltz C           Mathematics and Computer Science Division C           Argonne National Laboratory C           Argonne, IL 60439 C C  Latest modification: January 28, 1988 C C-------------------------------------------------------------------- INTEGER I , JINT CS    REAL DOUBLE PRECISION 1 ARG , F , G , ONE , P , PP , Q , QQ , RESULT , SUMF , SUMG , 2 SUMP , SUMQ , X , XINF , XMAX , XLEAST , XSMALL , XX , ZERO DIMENSION P ( 5 ), Q ( 3 ), PP ( 11 ), QQ ( 9 ), F ( 5 ), G ( 3 ) C-------------------------------------------------------------------- C  Mathematical constants C-------------------------------------------------------------------- CS    DATA ONE/1.0E0/,ZERO/0.0E0/ CD    DATA ONE/1.0D0/,ZERO/0.0D0/ C-------------------------------------------------------------------- C  Machine-dependent constants C-------------------------------------------------------------------- CS    DATA XLEAST/1.18E-38/,XSMALL/5.95E-8/,XINF/3.40E+38/, CS   1     XMAX/85.343E+0/ CD    DATA XLEAST/2.23D-308/,XSMALL/1.11D-16/,XINF/1.79D+308/, CD   1     XMAX/705.343D+0/ C-------------------------------------------------------------------- C  Coefficients for  XLEAST .LE.  ARG  .LE. 1.0 C-------------------------------------------------------------------- CS    DATA   P/ 4.8127070456878442310E-1, 9.9991373567429309922E+1, CS   1          7.1885382604084798576E+3, 1.7733324035147015630E+5, CS   2          7.1938920065420586101E+5/ CS    DATA   Q/-2.8143915754538725829E+2, 3.7264298672067697862E+4, CS   1         -2.2149374878243304548E+6/ CS    DATA   F/-2.2795590826955002390E-1,-5.3103913335180275253E+1, CS   1         -4.5051623763436087023E+3,-1.4758069205414222471E+5, CS   2         -1.3531161492785421328E+6/ CS    DATA   G/-3.0507151578787595807E+2, 4.3117653211351080007E+4, CS   2         -2.7062322985570842656E+6/ CD    DATA   P/ 4.8127070456878442310D-1, 9.9991373567429309922D+1, CD   1          7.1885382604084798576D+3, 1.7733324035147015630D+5, CD   2          7.1938920065420586101D+5/ CD    DATA   Q/-2.8143915754538725829D+2, 3.7264298672067697862D+4, CD   1         -2.2149374878243304548D+6/ CD    DATA   F/-2.2795590826955002390D-1,-5.3103913335180275253D+1, CD   1         -4.5051623763436087023D+3,-1.4758069205414222471D+5, CD   2         -1.3531161492785421328D+6/ CD    DATA   G/-3.0507151578787595807D+2, 4.3117653211351080007D+4, CD   2         -2.7062322985570842656D+6/ C-------------------------------------------------------------------- C  Coefficients for  1.0 .LT.  ARG C-------------------------------------------------------------------- CS    DATA  PP/ 6.4257745859173138767E-2, 7.5584584631176030810E+0, CS   1          1.3182609918569941308E+2, 8.1094256146537402173E+2, CS   2          2.3123742209168871550E+3, 3.4540675585544584407E+3, CS   3          2.8590657697910288226E+3, 1.3319486433183221990E+3, CS   4          3.4122953486801312910E+2, 4.4137176114230414036E+1, CS   5          2.2196792496874548962E+0/ CS    DATA  QQ/ 3.6001069306861518855E+1, 3.3031020088765390854E+2, CS   1          1.2082692316002348638E+3, 2.1181000487171943810E+3, CS   2          1.9448440788918006154E+3, 9.6929165726802648634E+2, CS   3          2.5951223655579051357E+2, 3.4552228452758912848E+1, CS   4          1.7710478032601086579E+0/ CD    DATA  PP/ 6.4257745859173138767D-2, 7.5584584631176030810D+0, CD   1          1.3182609918569941308D+2, 8.1094256146537402173D+2, CD   2          2.3123742209168871550D+3, 3.4540675585544584407D+3, CD   3          2.8590657697910288226D+3, 1.3319486433183221990D+3, CD   4          3.4122953486801312910D+2, 4.4137176114230414036D+1, CD   5          2.2196792496874548962D+0/ CD    DATA  QQ/ 3.6001069306861518855D+1, 3.3031020088765390854D+2, CD   1          1.2082692316002348638D+3, 2.1181000487171943810D+3, CD   2          1.9448440788918006154D+3, 9.6929165726802648634D+2, CD   3          2.5951223655579051357D+2, 3.4552228452758912848D+1, CD   4          1.7710478032601086579D+0/ C-------------------------------------------------------------------- X = ARG IF ( X . LT . XLEAST ) THEN C-------------------------------------------------------------------- C  Error return for  ARG  .LT. XLEAST C-------------------------------------------------------------------- RESULT = XINF ELSE IF ( X . LE . ONE ) THEN C-------------------------------------------------------------------- C  XLEAST .LE.  ARG  .LE. 1.0 C-------------------------------------------------------------------- IF ( X . LT . XSMALL ) THEN C-------------------------------------------------------------------- C  Return for small ARG C-------------------------------------------------------------------- RESULT = ONE / X ELSE XX = X * X SUMP = (((( P ( 1 ) * XX + P ( 2 )) * XX + P ( 3 )) * XX + P ( 4 )) * XX 1 + P ( 5 )) * XX + Q ( 3 ) SUMQ = (( XX + Q ( 1 )) * XX + Q ( 2 )) * XX + Q ( 3 ) SUMF = ((( F ( 1 ) * XX + F ( 2 )) * XX + F ( 3 )) * XX + F ( 4 )) * XX 1 + F ( 5 ) SUMG = (( XX + G ( 1 )) * XX + G ( 2 )) * XX + G ( 3 ) RESULT = ( XX * LOG ( X ) * SUMF / SUMG + SUMP / SUMQ ) / X IF ( JINT . EQ . 2 ) RESULT = RESULT * EXP ( X ) END IF ELSE IF (( JINT . EQ . 1 ) . AND . ( X . GT . XMAX )) THEN C-------------------------------------------------------------------- C  Error return for  ARG  .GT. XMAX C-------------------------------------------------------------------- RESULT = ZERO ELSE C-------------------------------------------------------------------- C  1.0 .LT.  ARG C-------------------------------------------------------------------- XX = ONE / X SUMP = PP ( 1 ) DO 120 I = 2 , 11 SUMP = SUMP * XX + PP ( I ) 120 CONTINUE SUMQ = XX DO 140 I = 1 , 8 SUMQ = ( SUMQ + QQ ( I )) * XX 140 CONTINUE SUMQ = SUMQ + QQ ( 9 ) RESULT = SUMP / SUMQ / SQRT ( X ) IF ( JINT . EQ . 1 ) RESULT = RESULT * EXP ( - X ) END IF RETURN C---------- Last line of CALCK1 ---------- END SUBROUTINE CALCK1 CS    REAL DOUBLE PRECISION FUNCTION BESK1 ( X ) C-------------------------------------------------------------------- C C This function program computes approximate values for the C   modified Bessel function of the second kind of order one C   for arguments  XLEAST .LE. ARG .LE. XMAX. C C-------------------------------------------------------------------- INTEGER JINT CS    REAL DOUBLE PRECISION X , RESULT C-------------------------------------------------------------------- JINT = 1 CALL CALCK1 ( X , RESULT , JINT ) BESK1 = RESULT RETURN C---------- Last line of BESK1 ---------- END FUNCTION BESK1 CS    REAL DOUBLE PRECISION FUNCTION BESEK1 ( X ) C-------------------------------------------------------------------- C C This function program computes approximate values for the C   modified Bessel function of the second kind of order one C   multiplied by the exponential function, for arguments C   XLEAST .LE. ARG .LE. XMAX. C C-------------------------------------------------------------------- INTEGER JINT CS    REAL DOUBLE PRECISION X , RESULT C-------------------------------------------------------------------- JINT = 2 CALL CALCK1 ( X , RESULT , JINT ) BESEK1 = RESULT RETURN C---------- Last line of BESEK1 ---------- END FUNCTION BESEK1 end module k1","tags":"","loc":"sourcefile/k1.f.html"},{"title":"rat.f90 – RPN calculator in Fortran","text":"This file depends on sourcefile~~rat.f90~~EfferentGraph sourcefile~rat.f90 rat.f90 sourcefile~reg.f90 reg.f90 sourcefile~rat.f90->sourcefile~reg.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~rat.f90~~AfferentGraph sourcefile~rat.f90 rat.f90 sourcefile~hyper.f90 hyper.F90 sourcefile~hyper.f90->sourcefile~rat.f90 sourcefile~gamma.f90 gamma.f90 sourcefile~gamma.f90->sourcefile~rat.f90 sourcefile~gamma.f90->sourcefile~hyper.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~rat.f90 sourcefile~funcs.f90->sourcefile~hyper.f90 sourcefile~funcs.f90->sourcefile~gamma.f90 sourcefile~stats.f90 stats.f90 sourcefile~funcs.f90->sourcefile~stats.f90 sourcefile~stats.f90->sourcefile~rat.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rat Source Code rat.f90 Source Code module rat use , intrinsic :: iso_fortran_env , only : stderr => error_unit use assert , only : wp , isclose implicit none contains !*********************************************************************************************************************************** !  ISDIGIT ! !  Determines whether the input character is a digit (0-9). !*********************************************************************************************************************************** elemental logical FUNCTION ISDIGIT ( CH ) CHARACTER , INTENT ( IN ) :: CH isdigit = ( CH . GE . '0' ) . AND . ( CH . LE . '9' ) END FUNCTION ISDIGIT !*********************************************************************************************************************************** !  ISPM ! !  Determines whether the input character is a + or - sign. !*********************************************************************************************************************************** elemental logical FUNCTION ISPM ( CH ) CHARACTER , INTENT ( IN ) :: CH ispm = ( CH . EQ . '+' ) . OR . ( CH . EQ . '-' ) END FUNCTION ISPM !*********************************************************************************************************************************** !  ISHEX ! !  Determines whether the input character is a valid hexadecimal digit !*********************************************************************************************************************************** elemental logical FUNCTION ISHEX ( CH ) CHARACTER , INTENT ( IN ) :: CH ishex = ((( CH . GE . '0' ) . AND . ( CH . LE . '9' )) . OR . (( CH . GE . 'A' ) . AND . ( CH . LE . 'F' ))) END FUNCTION ISHEX !*********************************************************************************************************************************** !  ISREAL ! !  Determines whether the input string is a number.  If it is, it will also return its value. ! !  In decimal mode, the input string is a number if it satisfies all of these criteria: ! !     1.  The first non-blank character is a digit, +, -, or decimal point (.). !     2.  It contains, at most, one decimal point. !     3.  It contains, at most, one occurrence of E. !     4.  Any decimal point occurs before any E. !     5.  The E may be followed by an optional + or -. !     6.  A letter E must be followed by at least one digit (after the optional + or -). !     7.  + or - may only be the first non-blank character, or the character immediately following E. !     8.  It contains no other characters besides: digits, +, -, decimal point (.), and E. ! !  If not in decimal mode, the input string is a number if it satisfies these criteria: ! !     1.  BIN:  digits 0 and 1 only !     2.  OCT:  digits 0-7 only !     3.  HEX:  digits 0-9 and A-F only ! !  Uses functions:  ISDIGIT, ISPM, ISHEX !*********************************************************************************************************************************** logical FUNCTION ISREAL ( STR , X ) RESULT ( NUM_FLAG ) USE GLOBAL CHARACTER ( LEN =* ), INTENT ( IN ) :: STR real ( wp ), INTENT ( OUT ) :: X INTEGER :: I , IERR , ITMP , LENSTR LOGICAL :: DPFOUND , EFOUND CHARACTER :: CH NUM_FLAG = . TRUE . LENSTR = LEN_TRIM ( STR ) IF ( BASE_MODE . NE . 10 ) GO TO 100 CH = STR ( 1 : 1 ) IF ((. NOT . ISPM ( CH )). AND .( CH . NE . '.' ). AND .(. NOT . ISDIGIT ( CH ))) THEN ! first character not +, -, ., or 0-9 NUM_FLAG = . FALSE . RETURN END IF IF ( ISPM ( CH ). AND .( LENSTR . EQ . 1 )) THEN ! + or - is the only character NUM_FLAG = . FALSE . RETURN END IF IF (( CH . EQ . '.' ). AND .( LENSTR . EQ . 1 )) THEN ! . is the only character NUM_FLAG = . FALSE . RETURN END IF IF (( CH . EQ . 'E' ). AND .( LENSTR . EQ . 1 )) THEN ! E is the only character NUM_FLAG = . FALSE . RETURN END IF DPFOUND = CH . EQ . '.' EFOUND = . FALSE . DO I = 2 , LENSTR CH = STR ( I : I ) IF ( ISDIGIT ( CH )) CYCLE ! digit 0-9 OK anywhere IF ((. NOT . ISPM ( CH )). AND .( CH . NE . '.' ). AND .(. NOT . ISDIGIT ( CH )). AND . & ! invalid character ( CH . NE . 'E' )) THEN NUM_FLAG = . FALSE . RETURN END IF IF ( DPFOUND . AND . ( CH . EQ . '.' )) THEN ! more than one decimal point NUM_FLAG = . FALSE . RETURN END IF IF ( EFOUND . AND . ( CH . EQ . '.' )) THEN ! decimal point after E NUM_FLAG = . FALSE . RETURN END IF IF ( EFOUND . AND . ( CH . EQ . 'E' )) THEN ! more than one E NUM_FLAG = . FALSE . RETURN END IF IF ( ISPM ( CH ). AND .( STR ( I - 1 : I - 1 ). NE . 'E' )) THEN ! + or - must be preceded by E NUM_FLAG = . FALSE . RETURN END IF IF ( CH . EQ . 'E' ) THEN IF ( I . EQ . LENSTR ) THEN ! E is the last character NUM_FLAG = . FALSE . RETURN END IF IF ( ISPM ( STR ( I + 1 : I + 1 ))) THEN IF ( I . EQ . LENSTR - 1 ) THEN ! E+ or E- are the last two characters NUM_FLAG = . FALSE . RETURN END IF IF (. NOT . ISDIGIT ( STR ( I + 2 : I + 2 ))) THEN ! E+ or E- not followed by a digit NUM_FLAG = . FALSE . RETURN END IF ELSE IF (. NOT . ISDIGIT ( STR ( I + 1 : I + 1 ))) THEN ! E not followed by a digit NUM_FLAG = . FALSE . RETURN END IF END IF END IF DPFOUND = DPFOUND . OR . ( CH . EQ . '.' ) EFOUND = EFOUND . OR . ( CH . EQ . 'E' ) END DO READ ( UNIT = STR , FMT =* , IOSTAT = IERR ) X NUM_FLAG = IERR . EQ . 0 RETURN 100 SELECT CASE ( BASE_MODE ) CASE ( 2 ) ! BIN mode DO I = 1 , LENSTR CH = STR ( I : I ) IF (( CH . NE . '0' ). AND .( CH . NE . '1' )) THEN ! only 0 and 1 allowed NUM_FLAG = . FALSE . RETURN END IF END DO READ ( UNIT = STR , FMT = '(B30)' , IOSTAT = IERR ) ITMP X = real ( itmp , wp ) NUM_FLAG = IERR . EQ . 0 CASE ( 8 ) ! OCT mode DO I = 1 , LENSTR CH = STR ( I : I ) IF (( CH . LT . '0' ). OR .( CH . GT . '7' )) THEN ! only 0-7 allowed NUM_FLAG = . FALSE . RETURN END IF END DO READ ( UNIT = STR , FMT = '(O30)' , IOSTAT = IERR ) ITMP X = real ( itmp , wp ) NUM_FLAG = IERR . EQ . 0 CASE ( 16 ) ! HEX mode IF ( STR . EQ . 'DEC' ) THEN !   DEC is a valid hex integer, so check.. NUM_FLAG = . FALSE . !   ..if we're switching to DEC mode RETURN !   (enter 0DEC to get the hex integer DEC) END IF DO I = 1 , LENSTR CH = STR ( I : I ) IF (. NOT . ISHEX ( CH )) THEN !   only 0-9 and A-F allowed NUM_FLAG = . FALSE . RETURN END IF END DO READ ( UNIT = STR , FMT = '(Z30)' , IOSTAT = IERR ) ITMP X = real ( itmp , wp ) NUM_FLAG = IERR . EQ . 0 END SELECT END FUNCTION ISREAL !*********************************************************************************************************************************** !  ISCOMPLEX ! !  Determines whether the input string is a complex number.  If it is, it will also return its value. !  A complex number consists of two real numbers separated by a comma (no space).  For example:  2.0,5.0E2 ! !  In decimal mode, the input string is a number if it satisfies all of these criteria: ! !     1.  The first non-blank character is a digit, +, -, or decimal point (.). !     2.  It contains, at most, one decimal point. !     3.  It contains, at most, one occurrence of E. !     4.  Any decimal point occurs before any E. !     5.  The E may be followed by an optional + or -. !     6.  A letter E must be followed by at least one digit (after the optional + or -). !     7.  + or - may only be the first non-blank character, or the character immediately following E. !     8.  It contains no other characters besides: digits, +, -, decimal point (.), and E. ! !  If not in decimal mode, the input string is a number if it satisfies these criteria: ! !     1.  BIN:  digits 0 and 1 only !     2.  OCT:  digits 0-7 only !     3.  HEX:  digits 0-9 and A-F only ! !  Uses functions:  ISDIGIT, ISPM, ISHEX !*********************************************************************************************************************************** FUNCTION ISCOMPLEX ( STR , X ) RESULT ( NUM_FLAG ) USE GLOBAL CHARACTER ( LEN =* ), INTENT ( IN ) :: STR COMPLEX ( wp ), INTENT ( OUT ) :: X LOGICAL :: NUM_FLAG INTEGER :: I , IERRR , IERRI , LENSTR , COMMAIDX INTEGER :: IXR , IXI real ( wp ) :: XR , XI LOGICAL :: DPFOUND , EFOUND , COMMAFOUND CHARACTER :: CH NUM_FLAG = . TRUE . LENSTR = LEN_TRIM ( STR ) IF ( BASE_MODE . NE . 10 ) GO TO 100 CH = STR ( 1 : 1 ) IF ((. NOT . ISPM ( CH )). AND .( CH . NE . '.' ). AND .(. NOT . ISDIGIT ( CH ))) THEN ! first character not +, -, ., or 0-9 NUM_FLAG = . FALSE . RETURN END IF IF ( ISPM ( CH ). AND .( LENSTR . EQ . 1 )) THEN ! + or - is the only character NUM_FLAG = . FALSE . RETURN END IF IF (( CH . EQ . '.' ). AND .( LENSTR . EQ . 1 )) THEN ! . is the only character NUM_FLAG = . FALSE . RETURN END IF IF (( CH . EQ . 'E' ). AND .( LENSTR . EQ . 1 )) THEN ! E is the only character NUM_FLAG = . FALSE . RETURN END IF DPFOUND = CH . EQ . '.' EFOUND = . FALSE . COMMAFOUND = . FALSE . DO I = 2 , LENSTR CH = STR ( I : I ) IF ( ISDIGIT ( CH )) CYCLE ! digit 0-9 OK anywhere IF ((. NOT . ISPM ( CH )). AND .( CH . NE . '.' ). AND .(. NOT . ISDIGIT ( CH )). AND . & ! invalid character ( CH . NE . 'E' ). AND .( CH . NE . ',' )) THEN NUM_FLAG = . FALSE . RETURN END IF IF ( DPFOUND . AND . ( CH . EQ . '.' )) THEN ! more than one decimal point NUM_FLAG = . FALSE . RETURN END IF IF ( EFOUND . AND . ( CH . EQ . '.' )) THEN ! decimal point after E NUM_FLAG = . FALSE . RETURN END IF IF ( EFOUND . AND . ( CH . EQ . 'E' )) THEN ! more than one E NUM_FLAG = . FALSE . RETURN END IF IF ( ISPM ( CH ). AND .( STR ( I - 1 : I - 1 ). NE . 'E' ). AND .( STR ( I - 1 : I - 1 ). NE . ',' )) THEN ! + or - must be preceded by E or comma NUM_FLAG = . FALSE . RETURN END IF IF ( CH . EQ . 'E' ) THEN IF ( I . EQ . LENSTR ) THEN ! E is the last character NUM_FLAG = . FALSE . RETURN END IF IF ( ISPM ( STR ( I + 1 : I + 1 ))) THEN IF ( I . EQ . LENSTR - 1 ) THEN ! E+ or E- are the last two characters NUM_FLAG = . FALSE . RETURN END IF IF (. NOT . ISDIGIT ( STR ( I + 2 : I + 2 ))) THEN ! E+ or E- not followed by a digit NUM_FLAG = . FALSE . RETURN END IF ELSE IF (. NOT . ISDIGIT ( STR ( I + 1 : I + 1 ))) THEN ! E not followed by a digit NUM_FLAG = . FALSE . RETURN END IF END IF END IF DPFOUND = DPFOUND . OR . ( CH . EQ . '.' ) EFOUND = EFOUND . OR . ( CH . EQ . 'E' ) COMMAFOUND = COMMAFOUND . OR . ( CH . EQ . ',' ) IF ( CH . EQ . ',' ) THEN READ ( UNIT = STR ( 1 : I - 1 ), FMT =* , IOSTAT = IERRR ) XR COMMAIDX = I DPFOUND = . FALSE . EFOUND = . FALSE . END IF END DO IF (. NOT . COMMAFOUND ) THEN READ ( UNIT = STR ( 1 : I - 1 ), FMT =* , IOSTAT = IERRR ) XR XI = 0.0D0 IERRI = 0 ELSE READ ( UNIT = STR ( COMMAIDX + 1 :), FMT =* , IOSTAT = IERRI ) XI END IF X = CMPLX ( XR , XI , wp ) NUM_FLAG = ( IERRR . EQ . 0 ) . AND . ( IERRI . EQ . 0 ) RETURN 100 COMMAFOUND = . FALSE . IF ( STR ( 1 : 1 ) . EQ . ',' ) THEN ! first character is a comma NUM_FLAG = . FALSE . RETURN END IF SELECT CASE ( BASE_MODE ) CASE ( 2 ) ! BIN mode DO I = 1 , LENSTR CH = STR ( I : I ) IF ( CH . EQ . ',' ) THEN IF ( COMMAFOUND ) THEN ! more than one comma found NUM_FLAG = . FALSE . RETURN END IF READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(B50)' , IOSTAT = IERRR ) IXR COMMAFOUND = . TRUE . COMMAIDX = I ELSE IF (( CH . NE . '0' ). AND .( CH . NE . '1' )) THEN ! only 0 and 1 allowed NUM_FLAG = . FALSE . RETURN END IF END DO IF (. NOT . COMMAFOUND ) THEN READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(B50)' , IOSTAT = IERRR ) IXR IXI = 0 IERRI = 0 ELSE READ ( UNIT = STR ( COMMAIDX + 1 :), FMT = '(B50)' , IOSTAT = IERRI ) IXI END IF X = CMPLX ( real ( ixr , wp ), real ( ixi , wp ), wp ) NUM_FLAG = ( IERRR . EQ . 0 ) . AND . ( IERRI . EQ . 0 ) CASE ( 8 ) ! OCT mode DO I = 1 , LENSTR CH = STR ( I : I ) IF ( CH . EQ . ',' ) THEN IF ( COMMAFOUND ) THEN ! more than one comma found NUM_FLAG = . FALSE . RETURN END IF READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(O50)' , IOSTAT = IERRR ) IXR COMMAFOUND = . TRUE . COMMAIDX = I ELSE IF (( CH . LT . '0' ). OR .( CH . GT . '7' )) THEN ! only 0-7 allowed NUM_FLAG = . FALSE . RETURN END IF END DO IF (. NOT . COMMAFOUND ) THEN READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(O50)' , IOSTAT = IERRR ) IXR IXI = 0 IERRI = 0 ELSE READ ( UNIT = STR ( COMMAIDX + 1 :), FMT = '(O50)' , IOSTAT = IERRI ) IXI END IF X = CMPLX ( real ( ixr , wp ), real ( ixi , wp ), wp ) NUM_FLAG = ( IERRR . EQ . 0 ) . AND . ( IERRI . EQ . 0 ) CASE ( 16 ) ! HEX mode DO I = 1 , LENSTR CH = STR ( I : I ) IF ( CH . EQ . ',' ) THEN IF ( COMMAFOUND ) THEN ! more than one comma found NUM_FLAG = . FALSE . RETURN END IF IF ( STR ( 1 : I - 1 ) . EQ . 'DEC' ) THEN !   DEC is a valid hex integer, so check.. NUM_FLAG = . FALSE . !   ..if we're switching to DEC mode RETURN !   (enter 0DEC to get the hex integer DEC) END IF READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(Z50)' , IOSTAT = IERRR ) IXR COMMAFOUND = . TRUE . COMMAIDX = I ELSE IF (. NOT . ISHEX ( CH )) THEN ! only hex digits allowed NUM_FLAG = . FALSE . RETURN END IF END DO IF (. NOT . COMMAFOUND ) THEN IF ( STR ( 1 : I - 1 ) . EQ . 'DEC' ) THEN !   DEC is a valid hex integer, so check.. NUM_FLAG = . FALSE . !   ..if we're switching to DEC mode RETURN !   (enter 0DEC to get the hex integer DEC) END IF READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(Z50)' , IOSTAT = IERRR ) IXR IXI = 0 IERRI = 0 ELSE IF ( STR ( 1 : I - 1 ) . EQ . 'DEC' ) THEN !   DEC is a valid hex integer, so check.. NUM_FLAG = . FALSE . !   ..if we're switching to DEC mode RETURN !   (enter 0DEC to get the hex integer DEC) END IF READ ( UNIT = STR ( COMMAIDX + 1 :), FMT = '(Z50)' , IOSTAT = IERRI ) IXI END IF X = CMPLX ( real ( IXR , wp ), real ( IXI , wp ), wp ) NUM_FLAG = ( IERRR . EQ . 0 ) . AND . ( IERRI . EQ . 0 ) END SELECT END FUNCTION ISCOMPLEX !*********************************************************************************************************************************** !  ISRATIONAL ! !  Determines whether the input string is a rational number.  If it is, it will also return its value. !  A rational number consists of two integers separated by a slash (no space).  For example:  2/5 ! !  In decimal mode, the input string is a number if it satisfies all of these criteria: ! !     1.  The first non-blank character is a digit, +, or -. !     2.  It contains no other characters besides: digits, +, and -. ! !  If not in decimal mode, the input string is a number if it satisfies these criteria: ! !     1.  BIN:  digits 0 and 1 only !     2.  OCT:  digits 0-7 only !     3.  HEX:  digits 0-9 and A-F only ! !  Uses functions:  ISDIGIT, ISPM, ISHEX !*********************************************************************************************************************************** FUNCTION ISRATIONAL ( STR , NUM , DEN ) RESULT ( NUM_FLAG ) USE GLOBAL CHARACTER ( LEN =* ), INTENT ( IN ) :: STR INTEGER , INTENT ( OUT ) :: NUM , DEN LOGICAL :: NUM_FLAG INTEGER :: I , IERRN , IERRD , LENSTR , SLASHIDX LOGICAL :: SLASHFOUND CHARACTER :: CH NUM_FLAG = . TRUE . LENSTR = LEN_TRIM ( STR ) IF ( BASE_MODE . NE . 10 ) GO TO 100 CH = STR ( 1 : 1 ) IF ((. NOT . ISPM ( CH )). AND .(. NOT . ISDIGIT ( CH ))) THEN ! first character not +, -, or 0-9 NUM_FLAG = . FALSE . RETURN END IF IF ( ISPM ( CH ). AND .( LENSTR . EQ . 1 )) THEN ! + or - is the only character NUM_FLAG = . FALSE . RETURN END IF SLASHFOUND = . FALSE . DO I = 2 , LENSTR CH = STR ( I : I ) IF ( ISDIGIT ( CH )) CYCLE ! digit 0-9 OK anywhere IF ((. NOT . ISDIGIT ( CH )). AND .( CH . NE . '/' )) THEN ! invalid character NUM_FLAG = . FALSE . RETURN END IF SLASHFOUND = SLASHFOUND . OR . ( CH . EQ . '/' ) IF ( CH . EQ . '/' ) THEN READ ( UNIT = STR ( 1 : I - 1 ), FMT =* , IOSTAT = IERRN ) NUM SLASHIDX = I END IF END DO IF (. NOT . SLASHFOUND ) THEN READ ( UNIT = STR ( 1 : I - 1 ), FMT =* , IOSTAT = IERRN ) NUM DEN = 1 IERRD = 0 ELSE READ ( UNIT = STR ( SLASHIDX + 1 :), FMT =* , IOSTAT = IERRD ) DEN END IF NUM_FLAG = ( IERRN . EQ . 0 ) . AND . ( IERRD . EQ . 0 ) IF ( NUM_FLAG ) CALL RATNORM ( NUM , DEN ) RETURN 100 SLASHFOUND = . FALSE . IF ( STR ( 1 : 1 ) . EQ . '/' ) THEN ! first character is a slash NUM_FLAG = . FALSE . RETURN END IF SELECT CASE ( BASE_MODE ) CASE ( 2 ) ! BIN mode DO I = 1 , LENSTR CH = STR ( I : I ) IF ( CH . EQ . '/' ) THEN IF ( SLASHFOUND ) THEN ! more than one slash found NUM_FLAG = . FALSE . RETURN END IF READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(B50)' , IOSTAT = IERRN ) NUM SLASHFOUND = . TRUE . SLASHIDX = I ELSE IF (( CH . NE . '0' ). AND .( CH . NE . '1' )) THEN ! only 0 and 1 allowed NUM_FLAG = . FALSE . RETURN END IF END DO IF (. NOT . SLASHFOUND ) THEN READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(B50)' , IOSTAT = IERRN ) NUM DEN = 1 IERRD = 0 ELSE READ ( UNIT = STR ( SLASHIDX + 1 :), FMT = '(B50)' , IOSTAT = IERRD ) DEN END IF NUM_FLAG = ( IERRN . EQ . 0 ) . AND . ( IERRD . EQ . 0 ) IF ( NUM_FLAG ) CALL RATNORM ( NUM , DEN ) CASE ( 8 ) ! OCT mode DO I = 1 , LENSTR CH = STR ( I : I ) IF ( CH . EQ . '/' ) THEN IF ( SLASHFOUND ) THEN ! more than one slash found NUM_FLAG = . FALSE . RETURN END IF READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(O50)' , IOSTAT = IERRN ) NUM SLASHFOUND = . TRUE . SLASHIDX = I ELSE IF (( CH . LT . '0' ). OR .( CH . GT . '7' )) THEN ! only 0-7 allowed NUM_FLAG = . FALSE . RETURN END IF END DO IF (. NOT . SLASHFOUND ) THEN READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(O50)' , IOSTAT = IERRN ) NUM DEN = 1 IERRD = 0 ELSE READ ( UNIT = STR ( SLASHIDX + 1 :), FMT = '(O50)' , IOSTAT = IERRD ) DEN END IF NUM_FLAG = ( IERRN . EQ . 0 ) . AND . ( IERRD . EQ . 0 ) IF ( NUM_FLAG ) CALL RATNORM ( NUM , DEN ) CASE ( 16 ) ! HEX mode DO I = 1 , LENSTR CH = STR ( I : I ) IF ( CH . EQ . '/' ) THEN IF ( SLASHFOUND ) THEN ! more than one slash found NUM_FLAG = . FALSE . RETURN END IF IF ( STR ( 1 : I - 1 ) . EQ . 'DEC' ) THEN !   DEC is a valid hex integer, so check.. NUM_FLAG = . FALSE . !   ..if we're switching to DEC mode RETURN !   (enter 0DEC to get the hex integer DEC) END IF READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(Z50)' , IOSTAT = IERRN ) NUM SLASHFOUND = . TRUE . SLASHIDX = I ELSE IF (. NOT . ISHEX ( CH )) THEN ! only hex digits allowed NUM_FLAG = . FALSE . RETURN END IF END DO IF (. NOT . SLASHFOUND ) THEN IF ( STR ( 1 : I - 1 ) . EQ . 'DEC' ) THEN !   DEC is a valid hex integer, so check.. NUM_FLAG = . FALSE . !   ..if we're switching to DEC mode RETURN !   (enter 0DEC to get the hex integer DEC) END IF READ ( UNIT = STR ( 1 : I - 1 ), FMT = '(Z50)' , IOSTAT = IERRN ) NUM DEN = 1 IERRD = 0 ELSE IF ( STR ( 1 : I - 1 ) . EQ . 'DEC' ) THEN !   DEC is a valid hex integer, so check.. NUM_FLAG = . FALSE . !   ..if we're switching to DEC mode RETURN !   (enter 0DEC to get the hex integer DEC) END IF READ ( UNIT = STR ( SLASHIDX + 1 :), FMT = '(Z50)' , IOSTAT = IERRD ) DEN END IF NUM_FLAG = ( IERRN . EQ . 0 ) . AND . ( IERRD . EQ . 0 ) IF ( NUM_FLAG ) CALL RATNORM ( NUM , DEN ) END SELECT END FUNCTION ISRATIONAL !*********************************************************************************************************************************** !  SWITCH_RAT_TO_REAL !*********************************************************************************************************************************** SUBROUTINE SWITCH_RAT_TO_REAL USE GLOBAL DOMAIN_MODE = 1 where ( rdstack /= 0 ) STACK = real ( RNSTACK , wp ) / real ( RDSTACK , wp ) elsewhere stack = 0._wp endwhere reg = real ( RNREG , wp ) / real ( RDREG , wp ) LASTX = DBLE ( RNLASTX ) / DBLE ( RDLASTX ) NN = DBLE ( RNNN ) / DBLE ( RDNN ) SUMX = DBLE ( RNSUMX ) / DBLE ( RDSUMX ) SUMX2 = DBLE ( RNSUMX2 ) / DBLE ( RDSUMX2 ) SUMY = DBLE ( RNSUMY ) / DBLE ( RDSUMY ) SUMY2 = DBLE ( RNSUMY2 ) / DBLE ( RDSUMY2 ) SUMXY = DBLE ( RNSUMXY ) / DBLE ( RDSUMXY ) END SUBROUTINE SWITCH_RAT_TO_REAL !*********************************************************************************************************************************** !  ISFRAC ! !  Returns .TRUE. if X has a fractional part (i.e. if X is not an integer) !*********************************************************************************************************************************** elemental logical FUNCTION ISFRAC ( X ) RESULT ( Y ) real ( wp ), INTENT ( IN ) :: X real ( wp ), PARAMETER :: EPS = 1.0D-8 y = ( ABS ( X ) - INT ( ABS ( X ))) > EPS END FUNCTION ISFRAC !*********************************************************************************************************************************** !  ISINT ! !  Returns .TRUE. if X has no fractional part (i.e. if X is an integer) !*********************************************************************************************************************************** elemental logical FUNCTION ISINT ( X ) real ( wp ), INTENT ( IN ) :: X isint = ( ABS ( X ) - INT ( ABS ( X ))) < epsilon ( 0._wp ) END FUNCTION ISINT !*********************************************************************************************************************************** !  FRAC_TO_MIXED ! !  Convert a fraction from improper format to mixed format. !*********************************************************************************************************************************** elemental SUBROUTINE FRAC_TO_MIXED ( AN , AD , A1 , A2 , A3 ) INTEGER , INTENT ( IN ) :: AN , AD INTEGER , INTENT ( OUT ) :: A1 , A2 , A3 INTEGER :: ANN , ADN LOGICAL :: NEGFLAG ANN = AN ! normalize the input fraction ADN = AD CALL RATNORM ( ANN , ADN ) NEGFLAG = ANN . LT . 0 ! save the sign of the fraction.. ANN = ABS ( ANN ) ! ..and take its absolute value A1 = ANN / ADN ! find components of mixed fraction A2 = ANN - A1 * ADN A3 = ADN IF ( NEGFLAG ) A1 = - A1 ! restore the sign (assign to A1) END SUBROUTINE FRAC_TO_MIXED !*********************************************************************************************************************************** !  MATHEMATICAL FUNCTIONS !*********************************************************************************************************************************** !*********************************************************************************************************************************** !  GCD ! !  Greatest common divisor. !  Find the greatest common divisor of two integers using Euclid's algorithm. !*********************************************************************************************************************************** elemental integer FUNCTION GCD ( A , B ) INTEGER , INTENT ( IN ) :: A , B INTEGER :: A1 , B1 , T A1 = A B1 = B DO WHILE ( B1 . NE . 0 ) T = B1 B1 = MOD ( A1 , B1 ) A1 = T END DO GCD = A1 END FUNCTION GCD !*********************************************************************************************************************************** !  LCM ! !  Least common multiple. !  Find the least common multiple of two integers. !*********************************************************************************************************************************** elemental integer FUNCTION LCM ( A , B ) INTEGER , INTENT ( IN ) :: A , B LCM = A * B / GCD ( A , B ) END FUNCTION LCM !*********************************************************************************************************************************** !  RATNORM ! !  Normalize a rational number !  Check for a denominator or numerator of 0; make the denominator positive; and reduce the fraction. !*********************************************************************************************************************************** elemental SUBROUTINE RATNORM ( NUM , DEN ) INTEGER , INTENT ( INOUT ) :: NUM , DEN INTEGER :: G LOGICAL :: NEGFLAG IF ( DEN . EQ . 0 ) THEN ! check for zero denominator ! write(stderr, *)  'Error in RATNORM: denominator is zero.' NUM = 0 DEN = 1 RETURN END IF IF ( NUM . EQ . 0 ) THEN ! if zero numerator, just return 0/1 NUM = 0 DEN = 1 RETURN END IF NEGFLAG = ( NUM . LT . 0 . AND .. NOT . DEN . LT . 0 ) ! save sign of fraction in NEGFLAG NUM = ABS ( NUM ) ! take absolute value of NUM and DEN DEN = ABS ( DEN ) G = GCD ( NUM , DEN ) ! find GCD of NUM and DEN NUM = NUM / G ! reduce the fraction DEN = DEN / G IF ( NEGFLAG ) NUM = - NUM ! restore the sign to the numerator END SUBROUTINE RATNORM !*********************************************************************************************************************************** !  RADD ! !  Add two rational numbers. !*********************************************************************************************************************************** elemental SUBROUTINE RADD ( N1 , D1 , N2 , D2 , NR , DR ) INTEGER , INTENT ( IN ) :: N1 , D1 , N2 , D2 INTEGER , INTENT ( OUT ) :: NR , DR NR = N1 * D2 + D1 * N2 DR = D1 * D2 CALL RATNORM ( NR , DR ) END SUBROUTINE RADD !*********************************************************************************************************************************** !  RSUB ! !  Subtract two rational numbers. !*********************************************************************************************************************************** elemental SUBROUTINE RSUB ( N1 , D1 , N2 , D2 , NR , DR ) INTEGER , INTENT ( IN ) :: N1 , D1 , N2 , D2 INTEGER , INTENT ( OUT ) :: NR , DR NR = N1 * D2 - D1 * N2 DR = D1 * D2 CALL RATNORM ( NR , DR ) END SUBROUTINE RSUB !*********************************************************************************************************************************** !  RMUL ! !  Multiply two rational numbers. !*********************************************************************************************************************************** elemental SUBROUTINE RMUL ( N1 , D1 , N2 , D2 , NR , DR ) INTEGER , INTENT ( IN ) :: N1 , D1 , N2 , D2 INTEGER , INTENT ( OUT ) :: NR , DR NR = N1 * N2 DR = D1 * D2 CALL RATNORM ( NR , DR ) END SUBROUTINE RMUL !*********************************************************************************************************************************** !  RDIV ! !  Multiply two rational numbers. !*********************************************************************************************************************************** elemental SUBROUTINE RDIV ( N1 , D1 , N2 , D2 , NR , DR ) INTEGER , INTENT ( IN ) :: N1 , D1 , N2 , D2 INTEGER , INTENT ( OUT ) :: NR , DR NR = N1 * D2 DR = D1 * N2 CALL RATNORM ( NR , DR ) END SUBROUTINE RDIV !*********************************************************************************************************************************** !  DEC_TO_FRAC ! !  Converts a decimal number to a fraction. !  Algorithm from \"An Atlas of Functions\" by Spanier and Oldham, Springer-Verlag, 1987, pp. 665-667. !*********************************************************************************************************************************** SUBROUTINE DEC_TO_FRAC ( X , NUM , DEN , TOL ) real ( wp ), INTENT ( IN ) :: X INTEGER , INTENT ( OUT ) :: NUM , DEN real ( wp ), INTENT ( IN ), OPTIONAL :: TOL real ( wp ), PARAMETER :: TOL_DEF = 1.0D-6 ! default value of tolerance real ( wp ) :: TOL1 , NU , R , T , EPS , M INTEGER :: N1 , N2 , D1 , D2 LOGICAL :: SGN if ( isclose ( x , 0._wp )) then num = 0 den = 1 return endif !     Set a default value for TOL if TOL was not provided. IF ( PRESENT ( TOL )) THEN TOL1 = TOL ELSE TOL1 = TOL_DEF END IF ! !     Save the sign of X, and make it positive. ! NU = X ! make a local copy of X SGN = NU < 0._wp ! save sign NU = ABS ( NU ) ! remove sign from X ! !     Compute the rational equivalent of X. ! D1 = 1 D2 = 1 N1 = INT ( NU ) N2 = N1 + 1 GO TO 300 100 IF ( R . GT . 1._wp ) GO TO 200 R = 1._wp / R 200 N2 = N2 + N1 * INT ( R ) D2 = D2 + D1 * INT ( R ) N1 = N1 + N2 D1 = D1 + D2 300 R = 0.0D0 IF ( NU * D1 . EQ . DBLE ( N1 )) GO TO 400 R = ( N2 - NU * D2 ) / ( NU * D1 - N1 ) IF ( R . GT . 1._wp ) GO TO 400 T = N2 N2 = N1 N1 = int ( T ) T = D2 D2 = D1 D1 = int ( T ) 400 EPS = ABS ( 1._wp - ( N1 / ( NU * D1 ))) IF ( EPS . LE . TOL1 ) GO TO 600 M = 1._wp 500 M = 10 * M IF ( M * EPS . LT . 1._wp ) GO TO 500 EPS = ( 1._wp / M ) * INT ( 0.5D0 + M * EPS ) 600 IF ( EPS . LE . TOL1 ) THEN NUM = N1 DEN = D1 IF ( SGN ) NUM = - NUM ! negate numerator if needed RETURN END IF IF ( R . NE . 0.0D0 ) GO TO 100 END SUBROUTINE DEC_TO_FRAC end module rat","tags":"","loc":"sourcefile/rat.f90.html"},{"title":"reg.f90 – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~reg.f90~~AfferentGraph sourcefile~reg.f90 reg.f90 sourcefile~eval.f90 eval.f90 sourcefile~eval.f90->sourcefile~reg.f90 sourcefile~ui.f90 ui.f90 sourcefile~eval.f90->sourcefile~ui.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~ui.f90->sourcefile~reg.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~rat.f90 rat.f90 sourcefile~rat.f90->sourcefile~reg.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~reg.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~hyper.f90 hyper.F90 sourcefile~hyper.f90->sourcefile~reg.f90 sourcefile~hyper.f90->sourcefile~rat.f90 sourcefile~stats.f90 stats.f90 sourcefile~stats.f90->sourcefile~reg.f90 sourcefile~stats.f90->sourcefile~rat.f90 sourcefile~gamma.f90 gamma.f90 sourcefile~gamma.f90->sourcefile~rat.f90 sourcefile~gamma.f90->sourcefile~hyper.f90 sourcefile~funcs.f90->sourcefile~rat.f90 sourcefile~funcs.f90->sourcefile~hyper.f90 sourcefile~funcs.f90->sourcefile~stats.f90 sourcefile~funcs.f90->sourcefile~gamma.f90 var pansourcefileregf90AfferentGraph = svgPanZoom('#sourcefileregf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules GLOBAL Source Code reg.f90 Source Code MODULE GLOBAL use assert , only : wp IMPLICIT NONE CHARACTER ( * ), PARAMETER :: VERSION = '1.1.7' INTEGER :: STACK_SIZE ! stack size INTEGER , PARAMETER :: REG_SIZE = 10 ! number of storage registers real ( wp ), allocatable :: STACK (:) ! real stack real ( wp ), DIMENSION ( 0 : REG_SIZE - 1 ) :: REG ! real storage registers COMPLEX ( wp ), allocatable :: CSTACK (:) ! complex stack COMPLEX ( wp ), DIMENSION ( 0 : REG_SIZE - 1 ) :: CREG ! complex storage registers INTEGER , allocatable :: RNSTACK (:), RDSTACK (:) ! rational stack INTEGER , DIMENSION ( 0 : REG_SIZE - 1 ) :: RNREG , RDREG ! rational storage registers real ( wp ) :: LASTX ! real LAST X register COMPLEX ( wp ) :: CLASTX ! complex LAST X register INTEGER :: RNLASTX , RDLASTX ! rational LAST X register real ( wp ) :: NN , SUMX , SUMX2 , SUMY , SUMY2 , SUMXY ! real summation registers COMPLEX ( wp ) :: CNN , CSUMX , CSUMX2 , CSUMY , CSUMY2 , CSUMXY ! complex summation registers INTEGER :: RNNN , RNSUMX , RNSUMX2 , RNSUMY , RNSUMY2 , RNSUMXY ! rational summation registers (num.) INTEGER :: RDNN , RDSUMX , RDSUMX2 , RDSUMY , RDSUMY2 , RDSUMXY ! rational summation registers (den.) real ( wp ) :: ANGLE_FACTOR , FRACTOL INTEGER :: ANGLE_MODE , DISP_MODE , DISP_DIGITS , BASE_MODE , DOMAIN_MODE , & FRACTION_MODE INTEGER , PARAMETER :: INITIAL_ANGLE_MODE = 1 ! 1=deg 2=rad 3=grad 4=rev INTEGER , PARAMETER :: INITIAL_DISP_MODE = 4 ! 1=fix, 2=sci, 3=eng, 4=all INTEGER , PARAMETER :: INITIAL_DISP_DIGITS = 4 INTEGER , PARAMETER :: INITIAL_DOMAIN_MODE = 1 ! 1=real, 2=complex, 3=rational INTEGER , PARAMETER :: INITIAL_BASE_MODE = 10 ! 2=bin, 8=oct, 10=dec, 16=hex INTEGER , PARAMETER :: INITIAL_FRACTION_MODE = 1 ! 1=improper, 2=mixed real ( wp ), PARAMETER :: INITIAL_FRACTOL = 1.0D-4 ! tolerance for decimal to fraction conversion contains subroutine init_stack () integer :: i character ( 16 ) :: argv stack_size = 4 ! default call get_command_argument ( 1 , argv , status = i ) if ( i == 0 ) read ( argv , '(I2)' ) stack_size if ( stack_size < 2 ) stack_size = 2 ! doesn't make sense to have only 1 level allocate ( stack ( stack_size ), cstack ( stack_size ), rdstack ( stack_size ), rnstack ( stack_size )) end subroutine init_stack END MODULE GLOBAL","tags":"","loc":"sourcefile/reg.f90.html"},{"title":"ribesl.f – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~ribesl.f~~AfferentGraph sourcefile~ribesl.f ribesl.f sourcefile~bessel.f90 bessel.f90 sourcefile~bessel.f90->sourcefile~ribesl.f sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rji Source Code ribesl.f Source Code module rji implicit none contains SUBROUTINE RIBESL ( X , ALPHA , NB , IZE , B , NCALC ) C------------------------------------------------------------------- C C  This routine calculates Bessel functions I SUB(N+ALPHA) (X) C  for non-negative argument X, and non-negative order N+ALPHA, C  with or without exponential scaling. C C C Explanation of variables in the calling sequence C C X     - Working precision non-negative real argument for which C         I's or exponentially scaled I's (I*EXP(-X)) C         are to be calculated.  If I's are to be calculated, C         X must be less than EXPARG (see below). C ALPHA - Working precision fractional part of order for which C         I's or exponentially scaled I's (I*EXP(-X)) are C         to be calculated.  0 .LE. ALPHA .LT. 1.0. C NB    - Integer number of functions to be calculated, NB .GT. 0. C         The first function calculated is of order ALPHA, and the C         last is of order (NB - 1 + ALPHA). C IZE   - Integer type.  IZE = 1 if unscaled I's are to calculated, C         and 2 if exponentially scaled I's are to be calculated. C B     - Working precision output vector of length NB.  If the routine C         terminates normally (NCALC=NB), the vector B contains the C         functions I(ALPHA,X) through I(NB-1+ALPHA,X), or the C         corresponding exponentially scaled functions. C NCALC - Integer output variable indicating possible errors. C         Before using the vector B, the user should check that C         NCALC=NB, i.e., all orders have been calculated to C         the desired accuracy.  See error returns below. C C C******************************************************************* C******************************************************************* C C Explanation of machine-dependent constants C C   beta   = Radix for the floating-point system C   minexp = Smallest representable power of beta C   maxexp = Smallest power of beta that overflows C   it     = Number of bits in the mantissa of a working precision C            variable C   NSIG   = Decimal significance desired.  Should be set to C            INT(LOG10(2)*it+1).  Setting NSIG lower will result C            in decreased accuracy while setting NSIG higher will C            increase CPU time without increasing accuracy.  The C            truncation error is limited to a relative error of C            T=.5*10**(-NSIG). C   ENTEN  = 10.0 ** K, where K is the largest integer such that C            ENTEN is machine-representable in working precision C   ENSIG  = 10.0 ** NSIG C   RTNSIG = 10.0 ** (-K) for the smallest integer K such that C            K .GE. NSIG/4 C   ENMTEN = Smallest ABS(X) such that X/4 does not underflow C   XLARGE = Upper limit on the magnitude of X when IZE=2.  Bear C            in mind that if ABS(X)=N, then at least N iterations C            of the backward recursion will be executed.  The value C            of 10.0 ** 4 is used on every machine. C   EXPARG = Largest working precision argument that the library C            EXP routine can handle and upper limit on the C            magnitude of X when IZE=1; approximately C            LOG(beta**maxexp) C C C     Approximate values for some important machines are: C C                        beta       minexp      maxexp       it C C  CRAY-1        (S.P.)    2        -8193        8191        48 C  Cyber 180/855 C    under NOS   (S.P.)    2         -975        1070        48 C  IEEE (IBM/XT, C    SUN, etc.)  (S.P.)    2         -126         128        24 C  IEEE (IBM/XT, C    SUN, etc.)  (D.P.)    2        -1022        1024        53 C  IBM 3033      (D.P.)   16          -65          63        14 C  VAX           (S.P.)    2         -128         127        24 C  VAX D-Format  (D.P.)    2         -128         127        56 C  VAX G-Format  (D.P.)    2        -1024        1023        53 C C C                        NSIG       ENTEN       ENSIG      RTNSIG C C CRAY-1        (S.P.)    15       1.0E+2465   1.0E+15     1.0E-4 C Cyber 180/855 C   under NOS   (S.P.)    15       1.0E+322    1.0E+15     1.0E-4 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)     8       1.0E+38     1.0E+8      1.0E-2 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)    16       1.0D+308    1.0D+16     1.0D-4 C IBM 3033      (D.P.)     5       1.0D+75     1.0D+5      1.0D-2 C VAX           (S.P.)     8       1.0E+38     1.0E+8      1.0E-2 C VAX D-Format  (D.P.)    17       1.0D+38     1.0D+17     1.0D-5 C VAX G-Format  (D.P.)    16       1.0D+307    1.0D+16     1.0D-4 C C C                         ENMTEN      XLARGE   EXPARG C C CRAY-1        (S.P.)   1.84E-2466   1.0E+4    5677 C Cyber 180/855 C   under NOS   (S.P.)   1.25E-293    1.0E+4     741 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)   4.70E-38     1.0E+4      88 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)   8.90D-308    1.0D+4     709 C IBM 3033      (D.P.)   2.16D-78     1.0D+4     174 C VAX           (S.P.)   1.17E-38     1.0E+4      88 C VAX D-Format  (D.P.)   1.17D-38     1.0D+4      88 C VAX G-Format  (D.P.)   2.22D-308    1.0D+4     709 C C******************************************************************* C******************************************************************* C C Error returns C C  In case of an error,  NCALC .NE. NB, and not all I's are C  calculated to the desired accuracy. C C  NCALC .LT. 0:  An argument is out of range. For example, C     NB .LE. 0, IZE is not 1 or 2, or IZE=1 and ABS(X) .GE. EXPARG. C     In this case, the B-vector is not calculated, and NCALC is C     set to MIN0(NB,0)-1 so that NCALC .NE. NB. C C  NB .GT. NCALC .GT. 0: Not all requested function values could C     be calculated accurately.  This usually occurs because NB is C     much larger than ABS(X).  In this case, B(N) is calculated C     to the desired accuracy for N .LE. NCALC, but precision C     is lost for NCALC .LT. N .LE. NB.  If B(N) does not vanish C     for N .GT. NCALC (because it is too small to be represented), C     and B(N)/B(NCALC) = 10**(-K), then only the first NSIG-K C     significant figures of B(N) can be trusted. C C C Intrinsic functions required are: C C     DBLE, EXP, DGAMMA, GAMMA, INT, MAX, MIN, REAL, SQRT C C C Acknowledgement C C  This program is based on a program written by David J. C  Sookne (2) that computes values of the Bessel functions J or C  I of real argument and integer order.  Modifications include C  the restriction of the computation to the I Bessel function C  of non-negative real argument, the extension of the computation C  to arbitrary positive order, the inclusion of optional C  exponential scaling, and the elimination of most underflow. C  An earlier version was published in (3). C C References: \"A Note on Backward Recurrence Algorithms,\" Olver, C              F. W. J., and Sookne, D. J., Math. Comp. 26, 1972, C              pp 941-947. C C             \"Bessel Functions of Real Argument and Integer Order,\" C              Sookne, D. J., NBS Jour. of Res. B. 77B, 1973, pp C              125-132. C C             \"ALGORITHM 597, Sequence of Modified Bessel Functions C              of the First Kind,\" Cody, W. J., Trans. Math. Soft., C              1983, pp. 242-245. C C  Latest modification: May 30, 1989 C C  Modified by: W. J. Cody and L. Stoltz C               Applied Mathematics Division C               Argonne National Laboratory C               Argonne, IL  60439 C C------------------------------------------------------------------- integer , intent ( in ) :: NB double precision , intent ( out ) :: B ( NB ) integer , intent ( out ) :: NCALC INTEGER IZE , K , L , MAGX , N , NBMX , NEND , NSIG , NSTART double precision 1 ALPHA , CONST , EM , EMPAL , EMP2AL , EN , ENMTEN , ENSIG , 2 ENTEN , EXPARG , HALF , HALFX , ONE , P , PLAST , POLD , PSAVE , PSAVEL , 3 RTNSIG , SUM , TEMPA , TEMPB , TEMPC , TEST , TOVER , TWO , X , XLARGE , ZERO C------------------------------------------------------------------- C  Mathematical constants C------------------------------------------------------------------- CS    DATA ONE,TWO,ZERO,HALF,CONST/1.0E0,2.0E0,0.0E0,0.5E0,1.585E0/ CD    DATA ONE,TWO,ZERO,HALF,CONST/1.0D0,2.0D0,0.0D0,0.5D0,1.585D0/ C------------------------------------------------------------------- C  Machine-dependent parameters C------------------------------------------------------------------- CS    DATA NSIG,XLARGE,EXPARG /8,1.0E4,88.0E0/ CS    DATA ENTEN,ENSIG,RTNSIG/1.0E38,1.0E8,1.0E-2/ CS    DATA ENMTEN/4.7E-38/ CD    DATA NSIG,XLARGE,EXPARG /16,1.0D4,709.0D0/ CD    DATA ENTEN,ENSIG,RTNSIG/1.0D308,1.0D16,1.0D-4/ CD    DATA ENMTEN/8.9D-308/ C------------------------------------------------------------------- C  Statement functions for conversion C------------------------------------------------------------------- CS    CONV(N) = REAL(N) CS    FUNC(X) = GAMMA(X) CD    CONV(N) = DBLE(N) CD    FUNC(X) = DGAMMA(X) C------------------------------------------------------------------- C Check for X, NB, OR IZE out of range. C------------------------------------------------------------------- IF (( NB . GT . 0 ) . AND . ( X . GE . ZERO ) . AND . 1 ( ALPHA . GE . ZERO ) . AND . ( ALPHA . LT . ONE ) . AND . 2 ((( IZE . EQ . 1 ) . AND . ( X . LE . EXPARG )) . OR . 3 (( IZE . EQ . 2 ) . AND . ( X . LE . XLARGE )))) THEN C------------------------------------------------------------------- C Use 2-term ascending series for small X C------------------------------------------------------------------- NCALC = NB MAGX = INT ( X ) IF ( X . GE . RTNSIG ) THEN C------------------------------------------------------------------- C Initialize the forward sweep, the P-sequence of Olver C------------------------------------------------------------------- NBMX = NB - MAGX N = MAGX + 1 EN = dble ( N + N ) + ( ALPHA + ALPHA ) PLAST = ONE P = EN / X C------------------------------------------------------------------- C Calculate general significance test C------------------------------------------------------------------- TEST = ENSIG + ENSIG IF ( 2 * MAGX . GT . 5 * NSIG ) THEN TEST = SQRT ( TEST * P ) ELSE TEST = TEST / CONST ** MAGX END IF IF ( NBMX . GE . 3 ) THEN C------------------------------------------------------------------- C Calculate P-sequence until N = NB-1.  Check for possible overflow. C------------------------------------------------------------------- TOVER = ENTEN / ENSIG NSTART = MAGX + 2 NEND = NB - 1 DO 100 K = NSTART , NEND N = K EN = EN + TWO POLD = PLAST PLAST = P P = EN * PLAST / X + POLD IF ( P . GT . TOVER ) THEN C------------------------------------------------------------------- C To avoid overflow, divide P-sequence by TOVER.  Calculate C P-sequence until ABS(P) .GT. 1. C------------------------------------------------------------------- TOVER = ENTEN P = P / TOVER PLAST = PLAST / TOVER PSAVE = P PSAVEL = PLAST NSTART = N + 1 60 N = N + 1 EN = EN + TWO POLD = PLAST PLAST = P P = EN * PLAST / X + POLD IF ( P . LE . ONE ) GO TO 60 TEMPB = EN / X C------------------------------------------------------------------- C Calculate backward test, and find NCALC, the highest N C such that the test is passed. C------------------------------------------------------------------- TEST = POLD * PLAST / ENSIG TEST = TEST * ( HALF - HALF / ( TEMPB * TEMPB )) P = PLAST * TOVER N = N - 1 EN = EN - TWO NEND = MIN0 ( NB , N ) DO 80 L = NSTART , NEND NCALC = L POLD = PSAVEL PSAVEL = PSAVE PSAVE = EN * PSAVEL / X + POLD IF ( PSAVE * PSAVEL . GT . TEST ) GO TO 90 80 CONTINUE NCALC = NEND + 1 90 NCALC = NCALC - 1 GO TO 120 END IF 100 CONTINUE N = NEND EN = dble ( N + N ) + ( ALPHA + ALPHA ) C------------------------------------------------------------------- C Calculate special significance test for NBMX .GT. 2. C------------------------------------------------------------------- TEST = MAX ( TEST , SQRT ( PLAST * ENSIG ) * SQRT ( P + P )) END IF C------------------------------------------------------------------- C Calculate P-sequence until significance test passed. C------------------------------------------------------------------- 110 N = N + 1 EN = EN + TWO POLD = PLAST PLAST = P P = EN * PLAST / X + POLD IF ( P . LT . TEST ) GO TO 110 C------------------------------------------------------------------- C Initialize the backward recursion and the normalization sum. C------------------------------------------------------------------- 120 N = N + 1 EN = EN + TWO TEMPB = ZERO TEMPA = ONE / P EM = dble ( N ) - ONE EMPAL = EM + ALPHA EMP2AL = ( EM - ONE ) + ( ALPHA + ALPHA ) SUM = TEMPA * EMPAL * EMP2AL / EM NEND = N - NB IF ( NEND . LT . 0 ) THEN C------------------------------------------------------------------- C N .LT. NB, so store B(N) and set higher orders to zero. C------------------------------------------------------------------- B ( N ) = TEMPA NEND = - NEND DO L = 1 , NEND B ( N + L ) = ZERO enddo ELSE IF ( NEND . GT . 0 ) THEN C------------------------------------------------------------------- C Recur backward via difference equation, calculating (but C not storing) B(N), until N = NB. C------------------------------------------------------------------- DO 140 L = 1 , NEND N = N - 1 EN = EN - TWO TEMPC = TEMPB TEMPB = TEMPA TEMPA = ( EN * TEMPB ) / X + TEMPC EM = EM - ONE EMP2AL = EMP2AL - ONE IF ( N . EQ . 1 ) GO TO 150 IF ( N . EQ . 2 ) EMP2AL = ONE EMPAL = EMPAL - ONE SUM = ( SUM + TEMPA * EMPAL ) * EMP2AL / EM 140 CONTINUE END IF C------------------------------------------------------------------- C Store B(NB) C------------------------------------------------------------------- 150 B ( N ) = TEMPA IF ( NB . LE . 1 ) THEN SUM = ( SUM + SUM ) + TEMPA GO TO 230 END IF C------------------------------------------------------------------- C Calculate and Store B(NB-1) C------------------------------------------------------------------- N = N - 1 EN = EN - TWO B ( N ) = ( EN * TEMPA ) / X + TEMPB IF ( N . EQ . 1 ) GO TO 220 EM = EM - ONE EMP2AL = EMP2AL - ONE IF ( N . EQ . 2 ) EMP2AL = ONE EMPAL = EMPAL - ONE SUM = ( SUM + B ( N ) * EMPAL ) * EMP2AL / EM END IF NEND = N - 2 IF ( NEND . GT . 0 ) THEN C------------------------------------------------------------------- C Calculate via difference equation and store B(N), until N = 2. C------------------------------------------------------------------- DO 200 L = 1 , NEND N = N - 1 EN = EN - TWO B ( N ) = ( EN * B ( N + 1 )) / X + B ( N + 2 ) EM = EM - ONE EMP2AL = EMP2AL - ONE IF ( N . EQ . 2 ) EMP2AL = ONE EMPAL = EMPAL - ONE SUM = ( SUM + B ( N ) * EMPAL ) * EMP2AL / EM 200 CONTINUE END IF C------------------------------------------------------------------- C Calculate B(1) C------------------------------------------------------------------- B ( 1 ) = TWO * EMPAL * B ( 2 ) / X + B ( 3 ) 220 SUM = ( SUM + SUM ) + B ( 1 ) C------------------------------------------------------------------- C Normalize.  Divide all B(N) by sum. C------------------------------------------------------------------- 230 IF ( ALPHA . NE . ZERO ) 1 SUM = SUM * gamma ( ONE + ALPHA ) * ( X * HALF ) ** ( - ALPHA ) IF ( IZE . EQ . 1 ) SUM = SUM * EXP ( - X ) TEMPA = ENMTEN IF ( SUM . GT . ONE ) TEMPA = TEMPA * SUM DO 260 N = 1 , NB IF ( B ( N ) . LT . TEMPA ) B ( N ) = ZERO B ( N ) = B ( N ) / SUM 260 CONTINUE RETURN C------------------------------------------------------------------- C Two-term ascending series for small X. C------------------------------------------------------------------- ELSE TEMPA = ONE EMPAL = ONE + ALPHA HALFX = ZERO IF ( X . GT . ENMTEN ) HALFX = HALF * X IF ( ALPHA . NE . ZERO ) TEMPA = HALFX ** ALPHA / gamma ( EMPAL ) IF ( IZE . EQ . 2 ) TEMPA = TEMPA * EXP ( - X ) TEMPB = ZERO IF (( X + ONE ) . GT . ONE ) TEMPB = HALFX * HALFX B ( 1 ) = TEMPA + TEMPA * TEMPB / EMPAL IF (( X . NE . ZERO ) . AND . ( B ( 1 ) . EQ . ZERO )) NCALC = 0 IF ( NB . GT . 1 ) THEN IF ( X . EQ . ZERO ) THEN DO 310 N = 2 , NB B ( N ) = ZERO 310 CONTINUE ELSE C------------------------------------------------------------------- C Calculate higher-order functions. C------------------------------------------------------------------- TEMPC = HALFX TOVER = ( ENMTEN + ENMTEN ) / X IF ( TEMPB . NE . ZERO ) TOVER = ENMTEN / TEMPB DO 340 N = 2 , NB TEMPA = TEMPA / EMPAL EMPAL = EMPAL + ONE TEMPA = TEMPA * TEMPC IF ( TEMPA . LE . TOVER * EMPAL ) TEMPA = ZERO B ( N ) = TEMPA + TEMPA * TEMPB / EMPAL IF (( B ( N ) . EQ . ZERO ) . AND . ( NCALC . GT . N )) 1 NCALC = N - 1 340 CONTINUE END IF END IF END IF ELSE NCALC = MIN0 ( NB , 0 ) - 1 END IF RETURN C---------- Last line of RIBESL ---------- END subroutine ribesl end module rji","tags":"","loc":"sourcefile/ribesl.f.html"},{"title":"rjbesl.f – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~rjbesl.f~~AfferentGraph sourcefile~rjbesl.f rjbesl.f sourcefile~bessel.f90 bessel.f90 sourcefile~bessel.f90->sourcefile~rjbesl.f sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rjb Source Code rjbesl.f Source Code module rjb implicit none contains SUBROUTINE RJBESL ( X , ALPHA , NB , B , NCALC ) C--------------------------------------------------------------------- C This routine calculates Bessel functions J sub(N+ALPHA) (X) C   for non-negative argument X, and non-negative order N+ALPHA. C C C  Explanation of variables in the calling sequence. C C   X     - working precision non-negative real argument for which C           J's are to be calculated. C   ALPHA - working precision fractional part of order for which C           J's or exponentially scaled J'r (J*exp(X)) are C           to be calculated.  0 <= ALPHA < 1.0. C   NB  - integer number of functions to be calculated, NB > 0. C           The first function calculated is of order ALPHA, and the C           last is of order (NB - 1 + ALPHA). C   B  - working precision output vector of length NB.  If RJBESL C           terminates normally (NCALC=NB), the vector B contains the C           functions J/ALPHA/(X) through J/NB-1+ALPHA/(X), or the C           corresponding exponentially scaled functions. C   NCALC - integer output variable indicating possible errors. C           Before using the vector B, the user should check that C           NCALC=NB, i.e., all orders have been calculated to C           the desired accuracy.  See Error Returns below. C C C******************************************************************* C******************************************************************* C C  Explanation of machine-dependent constants C C   it     = Number of bits in the mantissa of a working precision C            variable C   NSIG   = Decimal significance desired.  Should be set to C            INT(LOG10(2)*it+1).  Setting NSIG lower will result C            in decreased accuracy while setting NSIG higher will C            increase CPU time without increasing accuracy.  The C            truncation error is limited to a relative error of C            T=.5*10**(-NSIG). C   ENTEN  = 10.0 ** K, where K is the largest integer such that C            ENTEN is machine-representable in working precision C   ENSIG  = 10.0 ** NSIG C   RTNSIG = 10.0 ** (-K) for the smallest integer K such that C            K .GE. NSIG/4 C   ENMTEN = Smallest ABS(X) such that X/4 does not underflow C   XLARGE = Upper limit on the magnitude of X.  If ABS(X)=N, C            then at least N iterations of the backward recursion C            will be executed.  The value of 10.0 ** 4 is used on C            every machine. C C C     Approximate values for some important machines are: C C C                            it    NSIG    ENTEN       ENSIG C C   CRAY-1        (S.P.)     48     15    1.0E+2465   1.0E+15 C   Cyber 180/855 C     under NOS   (S.P.)     48     15    1.0E+322    1.0E+15 C   IEEE (IBM/XT, C     SUN, etc.)  (S.P.)     24      8    1.0E+38     1.0E+8 C   IEEE (IBM/XT, C     SUN, etc.)  (D.P.)     53     16    1.0D+308    1.0D+16 C   IBM 3033      (D.P.)     14      5    1.0D+75     1.0D+5 C   VAX           (S.P.)     24      8    1.0E+38     1.0E+8 C   VAX D-Format  (D.P.)     56     17    1.0D+38     1.0D+17 C   VAX G-Format  (D.P.)     53     16    1.0D+307    1.0D+16 C C C                           RTNSIG      ENMTEN      XLARGE C C   CRAY-1        (S.P.)    1.0E-4    1.84E-2466   1.0E+4 C   Cyber 180/855 C     under NOS   (S.P.)    1.0E-4    1.25E-293    1.0E+4 C   IEEE (IBM/XT, C     SUN, etc.)  (S.P.)    1.0E-2    4.70E-38     1.0E+4 C   IEEE (IBM/XT, C     SUN, etc.)  (D.P.)    1.0E-4    8.90D-308    1.0D+4 C   IBM 3033      (D.P.)    1.0E-2    2.16D-78     1.0D+4 C   VAX           (S.P.)    1.0E-2    1.17E-38     1.0E+4 C   VAX D-Format  (D.P.)    1.0E-5    1.17D-38     1.0D+4 C   VAX G-Format  (D.P.)    1.0E-4    2.22D-308    1.0D+4 C C******************************************************************* C******************************************************************* C C  Error returns C C    In case of an error,  NCALC .NE. NB, and not all J's are C    calculated to the desired accuracy. C C    NCALC .LT. 0:  An argument is out of range. For example, C       NBES .LE. 0, ALPHA .LT. 0 or .GT. 1, or X is too large. C       In this case, B(1) is set to zero, the remainder of the C       B-vector is not calculated, and NCALC is set to C       MIN(NB,0)-1 so that NCALC .NE. NB. C C    NB .GT. NCALC .GT. 0: Not all requested function values could C       be calculated accurately.  This usually occurs because NB is C       much larger than ABS(X).  In this case, B(N) is calculated C       to the desired accuracy for N .LE. NCALC, but precision C       is lost for NCALC .LT. N .LE. NB.  If B(N) does not vanish C       for N .GT. NCALC (because it is too small to be represented), C       and B(N)/B(NCALC) = 10**(-K), then only the first NSIG-K C       significant figures of B(N) can be trusted. C C C  Intrinsic and other functions required are: C C     ABS, AINT, COS, DBLE, GAMMA (or DGAMMA), INT, MAX, MIN, C C     REAL, SIN, SQRT C C C  Acknowledgement C C   This program is based on a program written by David J. Sookne C   (2) that computes values of the Bessel functions J or I of real C   argument and integer order.  Modifications include the restriction C   of the computation to the J Bessel function of non-negative real C   argument, the extension of the computation to arbitrary positive C   order, and the elimination of most underflow. C C  References: \"A Note on Backward Recurrence Algorithms,\" Olver, C               F. W. J., and Sookne, D. J., Math. Comp. 26, 1972, C               pp 941-947. C C              \"Bessel Functions of Real Argument and Integer Order,\" C               Sookne, D. J., NBS Jour. of Res. B. 77B, 1973, pp C               125-132. C C  Latest modification: March 19, 1990 C C  Author: W. J. Cody C          Applied Mathematics Division C          Argonne National Laboratory C          Argonne, IL  60439 C C--------------------------------------------------------------------- INTEGER I , J , K , L , M , MAGX , N , NB , NBMX , NCALC , NEND , NSTART CS    REAL               GAMMA, CD    DOUBLE PRECISION  DGAMMA, double precision 1 ALPHA , ALPEM , ALP2EM , B , CAPP , CAPQ , EIGHTH , EM , EN , ENMTEN , ENSIG , 2 ENTEN , FACT , FOUR , GNU , HALF , HALFX , ONE , ONE30 , P , PI2 , PLAST , 3 POLD , PSAVE , PSAVEL , RTNSIG , S , SUM , T , T1 , TEMPA , TEMPB , TEMPC , TEST , 4 THREE , THREE5 , TOVER , TWO , TWOFIV , TWOPI1 , TWOPI2 , X , XC , XIN , XK , XLARGE , 5 XM , VCOS , VSIN , Z , ZERO DIMENSION B ( NB ), FACT ( 25 ) C--------------------------------------------------------------------- C  Mathematical constants C C   PI2    - 2 / PI C   TWOPI1 - first few significant digits of 2 * PI C   TWOPI2 - (2*PI - TWOPI) to working precision, i.e., C            TWOPI1 + TWOPI2 = 2 * PI to extra precision. C--------------------------------------------------------------------- CS    DATA PI2, TWOPI1, TWOPI2 /0.636619772367581343075535E0,6.28125E0, CS   1 1.935307179586476925286767E-3/ CS    DATA ZERO, EIGHTH, HALF, ONE /0.0E0,0.125E0,0.5E0,1.0E0/ CS    DATA TWO, THREE, FOUR, TWOFIV /2.0E0,3.0E0,4.0E0,25.0E0/ CS    DATA ONE30, THREE5 /130.0E0,35.0E0/ CD    DATA PI2, TWOPI1, TWOPI2 /0.636619772367581343075535D0,6.28125D0, CD   1 1.935307179586476925286767D-3/ CD    DATA ZERO, EIGHTH, HALF, ONE /0.0D0,0.125D0,0.5D0,1.0D0/ CD    DATA TWO, THREE, FOUR, TWOFIV /2.0D0,3.0D0,4.0D0,25.0D0/ CD    DATA ONE30, THREE5 /130.0D0,35.0D0/ C--------------------------------------------------------------------- C  Machine-dependent parameters C--------------------------------------------------------------------- CS    DATA ENTEN, ENSIG, RTNSIG /1.0E38,1.0E8,1.0E-2/ CS    DATA ENMTEN, XLARGE /1.2E-37,1.0E4/ CD    DATA ENTEN, ENSIG, RTNSIG /1.0D38,1.0D17,1.0D-4/ CD    DATA ENMTEN, XLARGE /1.2D-37,1.0D4/ C--------------------------------------------------------------------- C     Factorial(N) C--------------------------------------------------------------------- CS    DATA FACT /1.0E0,1.0E0,2.0E0,6.0E0,24.0E0,1.2E2,7.2E2,5.04E3, CS   1 4.032E4,3.6288E5,3.6288E6,3.99168E7,4.790016E8,6.2270208E9, CS   2 8.71782912E10,1.307674368E12,2.0922789888E13,3.55687428096E14, CS   3 6.402373705728E15,1.21645100408832E17,2.43290200817664E18, CS   4 5.109094217170944E19,1.12400072777760768E21, CS   5 2.585201673888497664E22,6.2044840173323943936E23/ CD    DATA FACT /1.0D0,1.0D0,2.0D0,6.0D0,24.0D0,1.2D2,7.2D2,5.04D3, CD   1 4.032D4,3.6288D5,3.6288D6,3.99168D7,4.790016D8,6.2270208D9, CD   2 8.71782912D10,1.307674368D12,2.0922789888D13,3.55687428096D14, CD   3 6.402373705728D15,1.21645100408832D17,2.43290200817664D18, CD   4 5.109094217170944D19,1.12400072777760768D21, CD   5 2.585201673888497664D22,6.2044840173323943936D23/ C--------------------------------------------------------------------- C Statement functions for conversion and the gamma function. C--------------------------------------------------------------------- CS    CONV(I) = REAL(I) CS    FUNC(X) = GAMMA(X) CD    CONV(I) = DBLE(I) CD    FUNC(X) = DGAMMA(X) C--------------------------------------------------------------------- C Check for out of range arguments. C--------------------------------------------------------------------- MAGX = INT ( X ) IF (( NB . GT . 0 ) . AND . ( X . GE . ZERO ) . AND . ( X . LE . XLARGE ) 1 . AND . ( ALPHA . GE . ZERO ) . AND . ( ALPHA . LT . ONE )) 2 THEN C--------------------------------------------------------------------- C Initialize result array to zero. C--------------------------------------------------------------------- NCALC = NB DO 20 I = 1 , NB B ( I ) = ZERO 20 CONTINUE C--------------------------------------------------------------------- C Branch to use 2-term ascending series for small X and asymptotic C form for large X when NB is not too large. C--------------------------------------------------------------------- IF ( X . LT . RTNSIG ) THEN C--------------------------------------------------------------------- C Two-term ascending series for small X. C--------------------------------------------------------------------- TEMPA = ONE ALPEM = ONE + ALPHA HALFX = ZERO IF ( X . GT . ENMTEN ) HALFX = HALF * X IF ( ALPHA . NE . ZERO ) 1 TEMPA = HALFX ** ALPHA / ( ALPHA * gamma ( ALPHA )) TEMPB = ZERO IF (( X + ONE ). GT . ONE ) TEMPB = - HALFX * HALFX B ( 1 ) = TEMPA + TEMPA * TEMPB / ALPEM IF (( X . NE . ZERO ) . AND . ( B ( 1 ). EQ . ZERO )) NCALC = 0 IF ( NB . NE . 1 ) THEN IF ( X . LE . ZERO ) THEN DO 30 N = 2 , NB B ( N ) = ZERO 30 CONTINUE ELSE C--------------------------------------------------------------------- C Calculate higher order functions. C--------------------------------------------------------------------- TEMPC = HALFX TOVER = ( ENMTEN + ENMTEN ) / X IF ( TEMPB . NE . ZERO ) TOVER = ENMTEN / TEMPB DO 50 N = 2 , NB TEMPA = TEMPA / ALPEM ALPEM = ALPEM + ONE TEMPA = TEMPA * TEMPC IF ( TEMPA . LE . TOVER * ALPEM ) TEMPA = ZERO B ( N ) = TEMPA + TEMPA * TEMPB / ALPEM IF (( B ( N ). EQ . ZERO ) . AND . ( NCALC . GT . N )) 1 NCALC = N - 1 50 CONTINUE END IF END IF ELSE IF (( X . GT . TWOFIV ) . AND . ( NB . LE . MAGX + 1 )) THEN C--------------------------------------------------------------------- C Asymptotic series for X .GT. 21.0. C--------------------------------------------------------------------- XC = SQRT ( PI2 / X ) XIN = ( EIGHTH / X ) ** 2 M = 11 IF ( X . GE . THREE5 ) M = 8 IF ( X . GE . ONE30 ) M = 4 XM = FOUR * dble ( M ) C--------------------------------------------------------------------- C Argument reduction for SIN and COS routines. C--------------------------------------------------------------------- T = AINT ( X / ( TWOPI1 + TWOPI2 ) + HALF ) Z = (( X - T * TWOPI1 ) - T * TWOPI2 ) - ( ALPHA + HALF ) / PI2 VSIN = SIN ( Z ) VCOS = COS ( Z ) GNU = ALPHA + ALPHA DO 80 I = 1 , 2 S = (( XM - ONE ) - GNU ) * (( XM - ONE ) + GNU ) * XIN * HALF T = ( GNU - ( XM - THREE )) * ( GNU + ( XM - THREE )) CAPP = S * T / FACT ( 2 * M + 1 ) T1 = ( GNU - ( XM + ONE )) * ( GNU + ( XM + ONE )) CAPQ = S * T1 / FACT ( 2 * M + 2 ) XK = XM K = M + M T1 = T DO 70 J = 2 , M XK = XK - FOUR S = (( XK - ONE ) - GNU ) * (( XK - ONE ) + GNU ) T = ( GNU - ( XK - THREE )) * ( GNU + ( XK - THREE )) CAPP = ( CAPP + ONE / FACT ( K - 1 )) * S * T * XIN CAPQ = ( CAPQ + ONE / FACT ( K )) * S * T1 * XIN K = K - 2 T1 = T 70 CONTINUE CAPP = CAPP + ONE CAPQ = ( CAPQ + ONE ) * ( GNU * GNU - ONE ) * ( EIGHTH / X ) B ( I ) = XC * ( CAPP * VCOS - CAPQ * VSIN ) IF ( NB . EQ . 1 ) GO TO 300 T = VSIN VSIN = - VCOS VCOS = T GNU = GNU + TWO 80 CONTINUE C--------------------------------------------------------------------- C If  NB .GT. 2, compute J(X,ORDER+I)  I = 2, NB-1 C--------------------------------------------------------------------- IF ( NB . GT . 2 ) THEN GNU = ALPHA + ALPHA + TWO DO 90 J = 3 , NB B ( J ) = GNU * B ( J - 1 ) / X - B ( J - 2 ) GNU = GNU + TWO 90 CONTINUE END IF C--------------------------------------------------------------------- C Use recurrence to generate results.  First initialize the C calculation of P*S. C--------------------------------------------------------------------- ELSE NBMX = NB - MAGX N = MAGX + 1 EN = dble ( N + N ) + ( ALPHA + ALPHA ) PLAST = ONE P = EN / X C--------------------------------------------------------------------- C Calculate general significance test. C--------------------------------------------------------------------- TEST = ENSIG + ENSIG IF ( NBMX . GE . 3 ) THEN C--------------------------------------------------------------------- C Calculate P*S until N = NB-1.  Check for possible overflow. C--------------------------------------------------------------------- TOVER = ENTEN / ENSIG NSTART = MAGX + 2 NEND = NB - 1 EN = dble ( NSTART + NSTART ) - TWO + ( ALPHA + ALPHA ) DO 130 K = NSTART , NEND N = K EN = EN + TWO POLD = PLAST PLAST = P P = EN * PLAST / X - POLD IF ( P . GT . TOVER ) THEN C--------------------------------------------------------------------- C To avoid overflow, divide P*S by TOVER.  Calculate P*S until C ABS(P) .GT. 1. C--------------------------------------------------------------------- TOVER = ENTEN P = P / TOVER PLAST = PLAST / TOVER PSAVE = P PSAVEL = PLAST NSTART = N + 1 100 N = N + 1 EN = EN + TWO POLD = PLAST PLAST = P P = EN * PLAST / X - POLD IF ( P . LE . ONE ) GO TO 100 TEMPB = EN / X C--------------------------------------------------------------------- C Calculate backward test and find NCALC, the highest N such that C the test is passed. C--------------------------------------------------------------------- TEST = POLD * PLAST * ( HALF - HALF / ( TEMPB * TEMPB )) TEST = TEST / ENSIG P = PLAST * TOVER N = N - 1 EN = EN - TWO NEND = MIN ( NB , N ) DO 110 L = NSTART , NEND POLD = PSAVEL PSAVEL = PSAVE PSAVE = EN * PSAVEL / X - POLD IF ( PSAVE * PSAVEL . GT . TEST ) THEN NCALC = L - 1 GO TO 190 END IF 110 CONTINUE NCALC = NEND GO TO 190 END IF 130 CONTINUE N = NEND EN = dble ( N + N ) + ( ALPHA + ALPHA ) C--------------------------------------------------------------------- C Calculate special significance test for NBMX .GT. 2. C--------------------------------------------------------------------- TEST = MAX ( TEST , SQRT ( PLAST * ENSIG ) * SQRT ( P + P )) END IF C--------------------------------------------------------------------- C Calculate P*S until significance test passes. C--------------------------------------------------------------------- 140 N = N + 1 EN = EN + TWO POLD = PLAST PLAST = P P = EN * PLAST / X - POLD IF ( P . LT . TEST ) GO TO 140 C--------------------------------------------------------------------- C Initialize the backward recursion and the normalization sum. C--------------------------------------------------------------------- 190 N = N + 1 EN = EN + TWO TEMPB = ZERO TEMPA = ONE / P M = 2 * N - 4 * ( N / 2 ) SUM = ZERO EM = dble ( N / 2 ) ALPEM = ( EM - ONE ) + ALPHA ALP2EM = ( EM + EM ) + ALPHA IF ( M . NE . 0 ) SUM = TEMPA * ALPEM * ALP2EM / EM NEND = N - NB IF ( NEND . GT . 0 ) THEN C--------------------------------------------------------------------- C Recur backward via difference equation, calculating (but not C storing) B(N), until N = NB. C--------------------------------------------------------------------- DO 200 L = 1 , NEND N = N - 1 EN = EN - TWO TEMPC = TEMPB TEMPB = TEMPA TEMPA = ( EN * TEMPB ) / X - TEMPC M = 2 - M IF ( M . NE . 0 ) THEN EM = EM - ONE ALP2EM = ( EM + EM ) + ALPHA IF ( N . EQ . 1 ) GO TO 210 ALPEM = ( EM - ONE ) + ALPHA IF ( ALPEM . EQ . ZERO ) ALPEM = ONE SUM = ( SUM + TEMPA * ALP2EM ) * ALPEM / EM END IF 200 CONTINUE END IF C--------------------------------------------------------------------- C Store B(NB). C--------------------------------------------------------------------- 210 B ( N ) = TEMPA IF ( NEND . GE . 0 ) THEN IF ( NB . LE . 1 ) THEN ALP2EM = ALPHA IF (( ALPHA + ONE ). EQ . ONE ) ALP2EM = ONE SUM = SUM + B ( 1 ) * ALP2EM GO TO 250 ELSE C--------------------------------------------------------------------- C Calculate and store B(NB-1). C--------------------------------------------------------------------- N = N - 1 EN = EN - TWO B ( N ) = ( EN * TEMPA ) / X - TEMPB IF ( N . EQ . 1 ) GO TO 240 M = 2 - M IF ( M . NE . 0 ) THEN EM = EM - ONE ALP2EM = ( EM + EM ) + ALPHA ALPEM = ( EM - ONE ) + ALPHA IF ( ALPEM . EQ . ZERO ) ALPEM = ONE SUM = ( SUM + B ( N ) * ALP2EM ) * ALPEM / EM END IF END IF END IF NEND = N - 2 IF ( NEND . NE . 0 ) THEN C--------------------------------------------------------------------- C Calculate via difference equation and store B(N), until N = 2. C--------------------------------------------------------------------- DO 230 L = 1 , NEND N = N - 1 EN = EN - TWO B ( N ) = ( EN * B ( N + 1 )) / X - B ( N + 2 ) M = 2 - M IF ( M . NE . 0 ) THEN EM = EM - ONE ALP2EM = ( EM + EM ) + ALPHA ALPEM = ( EM - ONE ) + ALPHA IF ( ALPEM . EQ . ZERO ) ALPEM = ONE SUM = ( SUM + B ( N ) * ALP2EM ) * ALPEM / EM END IF 230 CONTINUE END IF C--------------------------------------------------------------------- C Calculate B(1). C--------------------------------------------------------------------- B ( 1 ) = TWO * ( ALPHA + ONE ) * B ( 2 ) / X - B ( 3 ) 240 EM = EM - ONE ALP2EM = ( EM + EM ) + ALPHA IF ( ALP2EM . EQ . ZERO ) ALP2EM = ONE SUM = SUM + B ( 1 ) * ALP2EM C--------------------------------------------------------------------- C Normalize.  Divide all B(N) by sum. C--------------------------------------------------------------------- 250 IF (( ALPHA + ONE ). NE . ONE ) 1 SUM = SUM * gamma ( ALPHA ) * ( X * HALF ) ** ( - ALPHA ) TEMPA = ENMTEN IF ( SUM . GT . ONE ) TEMPA = TEMPA * SUM DO 260 N = 1 , NB IF ( ABS ( B ( N )). LT . TEMPA ) B ( N ) = ZERO B ( N ) = B ( N ) / SUM 260 CONTINUE END IF C--------------------------------------------------------------------- C Error return -- X, NB, or ALPHA is out of range. C--------------------------------------------------------------------- ELSE B ( 1 ) = ZERO NCALC = MIN ( NB , 0 ) - 1 END IF C--------------------------------------------------------------------- C Exit C--------------------------------------------------------------------- 300 RETURN C ---------- Last line of RJBESL ---------- END SUBROUTINE RJBESL end module rjb","tags":"","loc":"sourcefile/rjbesl.f.html"},{"title":"rkbesl.f – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~rkbesl.f~~AfferentGraph sourcefile~rkbesl.f rkbesl.f sourcefile~bessel.f90 bessel.f90 sourcefile~bessel.f90->sourcefile~rkbesl.f sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rjk Source Code rkbesl.f Source Code module rjk implicit none contains SUBROUTINE RKBESL ( X , ALPHA , NB , IZE , BK , NCALC ) C------------------------------------------------------------------- C C  This FORTRAN 77 routine calculates modified Bessel functions C  of the second kind, K SUB(N+ALPHA) (X), for non-negative C  argument X, and non-negative order N+ALPHA, with or without C  exponential scaling. C C  Explanation of variables in the calling sequence C C  Description of output values .. C C X     - Working precision non-negative real argument for which C         K's or exponentially scaled K's (K*EXP(X)) C         are to be calculated.  If K's are to be calculated, C         X must not be greater than XMAX (see below). C ALPHA - Working precision fractional part of order for which C         K's or exponentially scaled K's (K*EXP(X)) are C         to be calculated.  0 .LE. ALPHA .LT. 1.0. C NB    - Integer number of functions to be calculated, NB .GT. 0. C         The first function calculated is of order ALPHA, and the C         last is of order (NB - 1 + ALPHA). C IZE   - Integer type.  IZE = 1 if unscaled K's are to be calculated, C         and 2 if exponentially scaled K's are to be calculated. C BK    - Working precision output vector of length NB.  If the C         routine terminates normally (NCALC=NB), the vector BK C         contains the functions K(ALPHA,X), ... , K(NB-1+ALPHA,X), C         or the corresponding exponentially scaled functions. C         If (0 .LT. NCALC .LT. NB), BK(I) contains correct function C         values for I .LE. NCALC, and contains the ratios C         K(ALPHA+I-1,X)/K(ALPHA+I-2,X) for the rest of the array. C NCALC - Integer output variable indicating possible errors. C         Before using the vector BK, the user should check that C         NCALC=NB, i.e., all orders have been calculated to C         the desired accuracy.  See error returns below. C C C******************************************************************* C******************************************************************* C C Explanation of machine-dependent constants C C   beta   = Radix for the floating-point system C   minexp = Smallest representable power of beta C   maxexp = Smallest power of beta that overflows C   EPS    = The smallest positive floating-point number such that C            1.0+EPS .GT. 1.0 C   XMAX   = Upper limit on the magnitude of X when IZE=1;  Solution C            to equation: C               W(X) * (1-1/8X+9/128X**2) = beta**minexp C            where  W(X) = EXP(-X)*SQRT(PI/2X) C   SQXMIN = Square root of beta**minexp C   XINF   = Largest positive machine number; approximately C            beta**maxexp C   XMIN   = Smallest positive machine number; approximately C            beta**minexp C C C     Approximate values for some important machines are: C C                          beta       minexp      maxexp      EPS C C  CRAY-1        (S.P.)      2        -8193        8191    7.11E-15 C  Cyber 180/185 C    under NOS   (S.P.)      2         -975        1070    3.55E-15 C  IEEE (IBM/XT, C    SUN, etc.)  (S.P.)      2         -126         128    1.19E-7 C  IEEE (IBM/XT, C    SUN, etc.)  (D.P.)      2        -1022        1024    2.22D-16 C  IBM 3033      (D.P.)     16          -65          63    2.22D-16 C  VAX           (S.P.)      2         -128         127    5.96E-8 C  VAX D-Format  (D.P.)      2         -128         127    1.39D-17 C  VAX G-Format  (D.P.)      2        -1024        1023    1.11D-16 C C C                         SQXMIN       XINF        XMIN      XMAX C C CRAY-1        (S.P.)  6.77E-1234  5.45E+2465  4.59E-2467 5674.858 C Cyber 180/855 C   under NOS   (S.P.)  1.77E-147   1.26E+322   3.14E-294   672.788 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)  1.08E-19    3.40E+38    1.18E-38     85.337 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)  1.49D-154   1.79D+308   2.23D-308   705.342 C IBM 3033      (D.P.)  7.35D-40    7.23D+75    5.40D-79    177.852 C VAX           (S.P.)  5.42E-20    1.70E+38    2.94E-39     86.715 C VAX D-Format  (D.P.)  5.42D-20    1.70D+38    2.94D-39     86.715 C VAX G-Format  (D.P.)  7.46D-155   8.98D+307   5.57D-309   706.728 C C******************************************************************* C******************************************************************* C C Error returns C C  In case of an error, NCALC .NE. NB, and not all K's are C  calculated to the desired accuracy. C C  NCALC .LT. -1:  An argument is out of range. For example, C       NB .LE. 0, IZE is not 1 or 2, or IZE=1 and ABS(X) .GE. C       XMAX.  In this case, the B-vector is not calculated, C       and NCALC is set to MIN0(NB,0)-2  so that NCALC .NE. NB. C  NCALC = -1:  Either  K(ALPHA,X) .GE. XINF  or C       K(ALPHA+NB-1,X)/K(ALPHA+NB-2,X) .GE. XINF.  In this case, C       the B-vector is not calculated.  Note that again C       NCALC .NE. NB. C C  0 .LT. NCALC .LT. NB: Not all requested function values could C       be calculated accurately.  BK(I) contains correct function C       values for I .LE. NCALC, and contains the ratios C       K(ALPHA+I-1,X)/K(ALPHA+I-2,X) for the rest of the array. C C C Intrinsic functions required are: C C     ABS, AINT, EXP, INT, LOG, MAX, MIN, SINH, SQRT C C C Acknowledgement C C  This program is based on a program written by J. B. Campbell C  (2) that computes values of the Bessel functions K of real C  argument and real order.  Modifications include the addition C  of non-scaled functions, parameterization of machine C  dependencies, and the use of more accurate approximations C  for SINH and SIN. C C References: \"On Temme's Algorithm for the Modified Bessel C              Functions of the Third Kind,\" Campbell, J. B., C              TOMS 6(4), Dec. 1980, pp. 581-586. C C             \"A FORTRAN IV Subroutine for the Modified Bessel C              Functions of the Third Kind of Real Order and Real C              Argument,\" Campbell, J. B., Report NRC/ERB-925, C              National Research Council, Canada. C C  Latest modification: May 30, 1989 C C  Modified by: W. J. Cody and L. Stoltz C               Applied Mathematics Division C               Argonne National Laboratory C               Argonne, IL  60439 C C------------------------------------------------------------------- INTEGER I , IEND , ITEMP , IZE , J , K , M , MPLUS1 , NB , NCALC CS    REAL DOUBLE PRECISION 1 A , ALPHA , BLPHA , BK , BK1 , BK2 , C , D , DM , D1 , D2 , D3 , ENU , EPS , ESTF , ESTM , 2 EX , FOUR , F0 , F1 , F2 , HALF , ONE , P , P0 , Q , Q0 , R , RATIO , S , SQXMIN , T , TINYX , 3 TWO , TWONU , TWOX , T1 , T2 , WMINF , X , XINF , XMAX , XMIN , X2BY4 , ZERO DIMENSION BK ( 1 ), P ( 8 ), Q ( 7 ), R ( 5 ), S ( 4 ), T ( 6 ), ESTM ( 6 ), ESTF ( 7 ) C--------------------------------------------------------------------- C  Mathematical constants C    A = LOG(2.D0) - Euler's constant C    D = SQRT(2.D0/PI) C--------------------------------------------------------------------- CS    DATA HALF,ONE,TWO,ZERO/0.5E0,1.0E0,2.0E0,0.0E0/ CS    DATA FOUR,TINYX/4.0E0,1.0E-10/ CS    DATA A/ 0.11593151565841244881E0/,D/0.797884560802865364E0/ CD    DATA HALF,ONE,TWO,ZERO/0.5D0,1.0D0,2.0D0,0.0D0/ CD    DATA FOUR,TINYX/4.0D0,1.0D-10/ CD    DATA A/ 0.11593151565841244881D0/,D/0.797884560802865364D0/ C--------------------------------------------------------------------- C  Machine dependent parameters C--------------------------------------------------------------------- CS    DATA EPS/1.19E-7/,SQXMIN/1.08E-19/,XINF/3.40E+38/ CS    DATA XMIN/1.18E-38/,XMAX/85.337E0/ CD    DATA EPS/2.22D-16/,SQXMIN/1.49D-154/,XINF/1.79D+308/ CD    DATA XMIN/2.23D-308/,XMAX/705.342D0/ C--------------------------------------------------------------------- C  P, Q - Approximation for LOG(GAMMA(1+ALPHA))/ALPHA C                                         + Euler's constant C         Coefficients converted from hex to decimal and modified C         by W. J. Cody, 2/26/82 C  R, S - Approximation for (1-ALPHA*PI/SIN(ALPHA*PI))/(2.D0*ALPHA) C  T    - Approximation for SINH(Y)/Y C--------------------------------------------------------------------- CS    DATA P/ 0.805629875690432845E00,    0.204045500205365151E02, CS   1        0.157705605106676174E03,    0.536671116469207504E03, CS   2        0.900382759291288778E03,    0.730923886650660393E03, CS   3        0.229299301509425145E03,    0.822467033424113231E00/ CS    DATA Q/ 0.294601986247850434E02,    0.277577868510221208E03, CS   1        0.120670325591027438E04,    0.276291444159791519E04, CS   2        0.344374050506564618E04,    0.221063190113378647E04, CS   3        0.572267338359892221E03/ CS    DATA R/-0.48672575865218401848E+0,  0.13079485869097804016E+2, CS   1       -0.10196490580880537526E+3,  0.34765409106507813131E+3, CS   2        0.34958981245219347820E-3/ CS    DATA S/-0.25579105509976461286E+2,  0.21257260432226544008E+3, CS   1       -0.61069018684944109624E+3,  0.42269668805777760407E+3/ CS    DATA T/ 0.16125990452916363814E-9, 0.25051878502858255354E-7, CS   1        0.27557319615147964774E-5, 0.19841269840928373686E-3, CS   2        0.83333333333334751799E-2, 0.16666666666666666446E+0/ CS    DATA ESTM/5.20583E1, 5.7607E0, 2.7782E0, 1.44303E1, 1.853004E2, CS   1          9.3715E0/ CS    DATA ESTF/4.18341E1, 7.1075E0, 6.4306E0, 4.25110E1, 1.35633E0, CS   1          8.45096E1, 2.0E1/ CD    DATA P/ 0.805629875690432845D00,    0.204045500205365151D02, CD   1        0.157705605106676174D03,    0.536671116469207504D03, CD   2        0.900382759291288778D03,    0.730923886650660393D03, CD   3        0.229299301509425145D03,    0.822467033424113231D00/ CD    DATA Q/ 0.294601986247850434D02,    0.277577868510221208D03, CD   1        0.120670325591027438D04,    0.276291444159791519D04, CD   2        0.344374050506564618D04,    0.221063190113378647D04, CD   3        0.572267338359892221D03/ CD    DATA R/-0.48672575865218401848D+0,  0.13079485869097804016D+2, CD   1       -0.10196490580880537526D+3,  0.34765409106507813131D+3, CD   2        0.34958981245219347820D-3/ CD    DATA S/-0.25579105509976461286D+2,  0.21257260432226544008D+3, CD   1       -0.61069018684944109624D+3,  0.42269668805777760407D+3/ CD    DATA T/ 0.16125990452916363814D-9, 0.25051878502858255354D-7, CD   1        0.27557319615147964774D-5, 0.19841269840928373686D-3, CD   2        0.83333333333334751799D-2, 0.16666666666666666446D+0/ CD    DATA ESTM/5.20583D1, 5.7607D0, 2.7782D0, 1.44303D1, 1.853004D2, CD   1          9.3715D0/ CD    DATA ESTF/4.18341D1, 7.1075D0, 6.4306D0, 4.25110D1, 1.35633D0, CD   1          8.45096D1, 2.0D1/ C--------------------------------------------------------------------- EX = X ENU = ALPHA NCALC = MIN ( NB , 0 ) - 2 IF (( NB . GT . 0 ) . AND . (( ENU . GE . ZERO ) . AND . ( ENU . LT . ONE )) 1 . AND . (( IZE . GE . 1 ) . AND . ( IZE . LE . 2 )) . AND . 2 (( IZE . NE . 1 ) . OR . ( EX . LE . XMAX )) . AND . 3 ( EX . GT . ZERO )) THEN K = 0 IF ( ENU . LT . SQXMIN ) ENU = ZERO IF ( ENU . GT . HALF ) THEN K = 1 ENU = ENU - ONE END IF TWONU = ENU + ENU IEND = NB + K - 1 C = ENU * ENU D3 = - C IF ( EX . LE . ONE ) THEN C--------------------------------------------------------------------- C  Calculation of P0 = GAMMA(1+ALPHA) * (2/X)**ALPHA C                 Q0 = GAMMA(1-ALPHA) * (X/2)**ALPHA C--------------------------------------------------------------------- D1 = ZERO D2 = P ( 1 ) T1 = ONE T2 = Q ( 1 ) DO 10 I = 2 , 7 , 2 D1 = C * D1 + P ( I ) D2 = C * D2 + P ( I + 1 ) T1 = C * T1 + Q ( I ) T2 = C * T2 + Q ( I + 1 ) 10 CONTINUE D1 = ENU * D1 T1 = ENU * T1 F1 = LOG ( EX ) F0 = A + ENU * ( P ( 8 ) - ENU * ( D1 + D2 ) / ( T1 + T2 )) - F1 Q0 = EXP ( - ENU * ( A - ENU * ( P ( 8 ) + ENU * ( D1 - D2 ) / ( T1 - T2 )) - F1 )) F1 = ENU * F0 P0 = EXP ( F1 ) C--------------------------------------------------------------------- C  Calculation of F0 = C--------------------------------------------------------------------- D1 = R ( 5 ) T1 = ONE DO 20 I = 1 , 4 D1 = C * D1 + R ( I ) T1 = C * T1 + S ( I ) 20 CONTINUE IF ( ABS ( F1 ) . LE . HALF ) THEN F1 = F1 * F1 D2 = ZERO DO 30 I = 1 , 6 D2 = F1 * D2 + T ( I ) 30 CONTINUE D2 = F0 + F0 * F1 * D2 ELSE D2 = SINH ( F1 ) / ENU END IF F0 = D2 - ENU * D1 / ( T1 * P0 ) IF ( EX . LE . TINYX ) THEN C-------------------------------------------------------------------- C  X.LE.1.0E-10 C  Calculation of K(ALPHA,X) and X*K(ALPHA+1,X)/K(ALPHA,X) C-------------------------------------------------------------------- BK ( 1 ) = F0 + EX * F0 IF ( IZE . EQ . 1 ) BK ( 1 ) = BK ( 1 ) - EX * BK ( 1 ) RATIO = P0 / F0 C = EX * XINF IF ( K . NE . 0 ) THEN C-------------------------------------------------------------------- C  Calculation of K(ALPHA,X) and X*K(ALPHA+1,X)/K(ALPHA,X), C  ALPHA .GE. 1/2 C-------------------------------------------------------------------- NCALC = - 1 IF ( BK ( 1 ) . GE . C / RATIO ) GO TO 500 BK ( 1 ) = RATIO * BK ( 1 ) / EX TWONU = TWONU + TWO RATIO = TWONU END IF NCALC = 1 IF ( NB . EQ . 1 ) GO TO 500 C-------------------------------------------------------------------- C  Calculate  K(ALPHA+L,X)/K(ALPHA+L-1,X),  L  =  1, 2, ... , NB-1 C-------------------------------------------------------------------- NCALC = - 1 DO 80 I = 2 , NB IF ( RATIO . GE . C ) GO TO 500 BK ( I ) = RATIO / EX TWONU = TWONU + TWO RATIO = TWONU 80 CONTINUE NCALC = 1 GO TO 420 ELSE C-------------------------------------------------------------------- C  1.0E-10 .LT. X .LE. 1.0 C-------------------------------------------------------------------- C = ONE X2BY4 = EX * EX / FOUR P0 = HALF * P0 Q0 = HALF * Q0 D1 = - ONE D2 = ZERO BK1 = ZERO BK2 = ZERO F1 = F0 F2 = P0 100 D1 = D1 + TWO D2 = D2 + ONE D3 = D1 + D3 C = X2BY4 * C / D2 F0 = ( D2 * F0 + P0 + Q0 ) / D3 P0 = P0 / ( D2 - ENU ) Q0 = Q0 / ( D2 + ENU ) T1 = C * F0 T2 = C * ( P0 - D2 * F0 ) BK1 = BK1 + T1 BK2 = BK2 + T2 IF (( ABS ( T1 / ( F1 + BK1 )) . GT . EPS ) . OR . 1 ( ABS ( T2 / ( F2 + BK2 )) . GT . EPS )) GO TO 100 BK1 = F1 + BK1 BK2 = TWO * ( F2 + BK2 ) / EX IF ( IZE . EQ . 2 ) THEN D1 = EXP ( EX ) BK1 = BK1 * D1 BK2 = BK2 * D1 END IF WMINF = ESTF ( 1 ) * EX + ESTF ( 2 ) END IF ELSE IF ( EPS * EX . GT . ONE ) THEN C-------------------------------------------------------------------- C  X .GT. ONE/EPS C-------------------------------------------------------------------- NCALC = NB BK1 = ONE / ( D * SQRT ( EX )) DO 110 I = 1 , NB BK ( I ) = BK1 110 CONTINUE GO TO 500 ELSE C-------------------------------------------------------------------- C  X .GT. 1.0 C-------------------------------------------------------------------- TWOX = EX + EX BLPHA = ZERO RATIO = ZERO IF ( EX . LE . FOUR ) THEN C-------------------------------------------------------------------- C  Calculation of K(ALPHA+1,X)/K(ALPHA,X),  1.0 .LE. X .LE. 4.0 C-------------------------------------------------------------------- D2 = AINT ( ESTM ( 1 ) / EX + ESTM ( 2 )) M = INT ( D2 ) D1 = D2 + D2 D2 = D2 - HALF D2 = D2 * D2 DO 120 I = 2 , M D1 = D1 - TWO D2 = D2 - D1 RATIO = ( D3 + D2 ) / ( TWOX + D1 - RATIO ) 120 CONTINUE C-------------------------------------------------------------------- C  Calculation of I(|ALPHA|,X) and I(|ALPHA|+1,X) by backward C    recurrence and K(ALPHA,X) from the wronskian C-------------------------------------------------------------------- D2 = AINT ( ESTM ( 3 ) * EX + ESTM ( 4 )) M = INT ( D2 ) C = ABS ( ENU ) D3 = C + C D1 = D3 - ONE F1 = XMIN F0 = ( TWO * ( C + D2 ) / EX + HALF * EX / ( C + D2 + ONE )) * XMIN DO 130 I = 3 , M D2 = D2 - ONE F2 = ( D3 + D2 + D2 ) * F0 BLPHA = ( ONE + D1 / D2 ) * ( F2 + BLPHA ) F2 = F2 / EX + F1 F1 = F0 F0 = F2 130 CONTINUE F1 = ( D3 + TWO ) * F0 / EX + F1 D1 = ZERO T1 = ONE DO 140 I = 1 , 7 D1 = C * D1 + P ( I ) T1 = C * T1 + Q ( I ) 140 CONTINUE P0 = EXP ( C * ( A + C * ( P ( 8 ) - C * D1 / T1 ) - LOG ( EX ))) / EX F2 = ( C + HALF - RATIO ) * F1 / EX BK1 = P0 + ( D3 * F0 - F2 + F0 + BLPHA ) / ( F2 + F1 + F0 ) * P0 IF ( IZE . EQ . 1 ) BK1 = BK1 * EXP ( - EX ) WMINF = ESTF ( 3 ) * EX + ESTF ( 4 ) ELSE C-------------------------------------------------------------------- C  Calculation of K(ALPHA,X) and K(ALPHA+1,X)/K(ALPHA,X), by backward C  recurrence, for  X .GT. 4.0 C-------------------------------------------------------------------- DM = AINT ( ESTM ( 5 ) / EX + ESTM ( 6 )) M = INT ( DM ) D2 = DM - HALF D2 = D2 * D2 D1 = DM + DM DO 160 I = 2 , M DM = DM - ONE D1 = D1 - TWO D2 = D2 - D1 RATIO = ( D3 + D2 ) / ( TWOX + D1 - RATIO ) BLPHA = ( RATIO + RATIO * BLPHA ) / DM 160 CONTINUE BK1 = ONE / (( D + D * BLPHA ) * SQRT ( EX )) IF ( IZE . EQ . 1 ) BK1 = BK1 * EXP ( - EX ) WMINF = ESTF ( 5 ) * ( EX - ABS ( EX - ESTF ( 7 ))) + ESTF ( 6 ) END IF C-------------------------------------------------------------------- C  Calculation of K(ALPHA+1,X) from K(ALPHA,X) and C    K(ALPHA+1,X)/K(ALPHA,X) C-------------------------------------------------------------------- BK2 = BK1 + BK1 * ( ENU + HALF - RATIO ) / EX END IF C-------------------------------------------------------------------- C  Calculation of 'NCALC', K(ALPHA+I,X), I  =  0, 1, ... , NCALC-1, C  K(ALPHA+I,X)/K(ALPHA+I-1,X), I  =  NCALC, NCALC+1, ... , NB-1 C-------------------------------------------------------------------- NCALC = NB BK ( 1 ) = BK1 IF ( IEND . EQ . 0 ) GO TO 500 J = 2 - K IF ( J . GT . 0 ) BK ( J ) = BK2 IF ( IEND . EQ . 1 ) GO TO 500 M = MIN ( INT ( WMINF - ENU ), IEND ) DO 190 I = 2 , M T1 = BK1 BK1 = BK2 TWONU = TWONU + TWO IF ( EX . LT . ONE ) THEN IF ( BK1 . GE . ( XINF / TWONU ) * EX ) GO TO 195 GO TO 187 ELSE IF ( BK1 / EX . GE . XINF / TWONU ) GO TO 195 END IF 187 CONTINUE BK2 = TWONU / EX * BK1 + T1 ITEMP = I J = J + 1 IF ( J . GT . 0 ) BK ( J ) = BK2 190 CONTINUE 195 M = ITEMP IF ( M . EQ . IEND ) GO TO 500 RATIO = BK2 / BK1 MPLUS1 = M + 1 NCALC = - 1 DO 410 I = MPLUS1 , IEND TWONU = TWONU + TWO RATIO = TWONU / EX + ONE / RATIO J = J + 1 IF ( J . GT . 1 ) THEN BK ( J ) = RATIO ELSE IF ( BK2 . GE . XINF / RATIO ) GO TO 500 BK2 = RATIO * BK2 END IF 410 CONTINUE NCALC = MAX ( MPLUS1 - K , 1 ) IF ( NCALC . EQ . 1 ) BK ( 1 ) = BK2 IF ( NB . EQ . 1 ) GO TO 500 420 J = NCALC + 1 DO 430 I = J , NB IF ( BK ( NCALC ) . GE . XINF / BK ( I )) GO TO 500 BK ( I ) = BK ( NCALC ) * BK ( I ) NCALC = I 430 CONTINUE END IF 500 RETURN C---------- Last line of RKBESL ---------- END subroutine rkbesl end module rjk","tags":"","loc":"sourcefile/rkbesl.f.html"},{"title":"rybesl.f – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~rybesl.f~~AfferentGraph sourcefile~rybesl.f rybesl.f sourcefile~bessel.f90 bessel.f90 sourcefile~bessel.f90->sourcefile~rybesl.f sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rjy Source Code rybesl.f Source Code module rjy implicit none contains SUBROUTINE RYBESL ( X , ALPHA , NB , BY , NCALC ) C---------------------------------------------------------------------- C C  This routine calculates Bessel functions Y SUB(N+ALPHA) (X) C  for non-negative argument X, and non-negative order N+ALPHA. C C C Explanation of variables in the calling sequence C C X     - Working precision non-negative real argument for which C         Y's are to be calculated. C ALPHA - Working precision fractional part of order for which C         Y's are to be calculated.  0 .LE. ALPHA .LT. 1.0. C NB    - Integer number of functions to be calculated, NB .GT. 0. C         The first function calculated is of order ALPHA, and the C         last is of order (NB - 1 + ALPHA). C BY    - Working precision output vector of length NB.  If the C         routine terminates normally (NCALC=NB), the vector BY C         contains the functions Y(ALPHA,X), ... , Y(NB-1+ALPHA,X), C         If (0 .LT. NCALC .LT. NB), BY(I) contains correct function C         values for I .LE. NCALC, and contains the ratios C         Y(ALPHA+I-1,X)/Y(ALPHA+I-2,X) for the rest of the array. C NCALC - Integer output variable indicating possible errors. C         Before using the vector BY, the user should check that C         NCALC=NB, i.e., all orders have been calculated to C         the desired accuracy.  See error returns below. C C C******************************************************************* C******************************************************************* C C Explanation of machine-dependent constants C C   beta   = Radix for the floating-point system C   p      = Number of significant base-beta digits in the C            significand of a floating-point number C   minexp = Smallest representable power of beta C   maxexp = Smallest power of beta that overflows C   EPS    = beta ** (-p) C   DEL    = Machine number below which sin(x)/x = 1; approximately C            SQRT(EPS). C   XMIN   = Smallest acceptable argument for RBESY; approximately C            max(2*beta**minexp,2/XINF), rounded up C   XINF   = Largest positive machine number; approximately C            beta**maxexp C   THRESH = Lower bound for use of the asymptotic form; approximately C            AINT(-LOG10(EPS/2.0))+1.0 C   XLARGE = Upper bound on X; approximately 1/DEL, because the sine C            and cosine functions have lost about half of their C            precision at that point. C C C     Approximate values for some important machines are: C C                        beta    p     minexp      maxexp      EPS C C  CRAY-1        (S.P.)    2    48     -8193        8191    3.55E-15 C  Cyber 180/185 C    under NOS   (S.P.)    2    48      -975        1070    3.55E-15 C  IEEE (IBM/XT, C    SUN, etc.)  (S.P.)    2    24      -126         128    5.96E-8 C  IEEE (IBM/XT, C    SUN, etc.)  (D.P.)    2    53     -1022        1024    1.11D-16 C  IBM 3033      (D.P.)   16    14       -65          63    1.39D-17 C  VAX           (S.P.)    2    24      -128         127    5.96E-8 C  VAX D-Format  (D.P.)    2    56      -128         127    1.39D-17 C  VAX G-Format  (D.P.)    2    53     -1024        1023    1.11D-16 C C C                         DEL      XMIN      XINF     THRESH  XLARGE C C CRAY-1        (S.P.)  5.0E-8  3.67E-2466 5.45E+2465  15.0E0  2.0E7 C Cyber 180/855 C   under NOS   (S.P.)  5.0E-8  6.28E-294  1.26E+322   15.0E0  2.0E7 C IEEE (IBM/XT, C   SUN, etc.)  (S.P.)  1.0E-4  2.36E-38   3.40E+38     8.0E0  1.0E4 C IEEE (IBM/XT, C   SUN, etc.)  (D.P.)  1.0D-8  4.46D-308  1.79D+308   16.0D0  1.0D8 C IBM 3033      (D.P.)  1.0D-8  2.77D-76   7.23D+75    17.0D0  1.0D8 C VAX           (S.P.)  1.0E-4  1.18E-38   1.70E+38     8.0E0  1.0E4 C VAX D-Format  (D.P.)  1.0D-9  1.18D-38   1.70D+38    17.0D0  1.0D9 C VAX G-Format  (D.P.)  1.0D-8  2.23D-308  8.98D+307   16.0D0  1.0D8 C C******************************************************************* C******************************************************************* C C Error returns C C  In case of an error, NCALC .NE. NB, and not all Y's are C  calculated to the desired accuracy. C C  NCALC .LT. -1:  An argument is out of range. For example, C       NB .LE. 0, IZE is not 1 or 2, or IZE=1 and ABS(X) .GE. C       XMAX.  In this case, BY(1) = 0.0, the remainder of the C       BY-vector is not calculated, and NCALC is set to C       MIN0(NB,0)-2  so that NCALC .NE. NB. C  NCALC = -1:  Y(ALPHA,X) .GE. XINF.  The requested function C       values are set to 0.0. C  1 .LT. NCALC .LT. NB: Not all requested function values could C       be calculated accurately.  BY(I) contains correct function C       values for I .LE. NCALC, and and the remaining NB-NCALC C       array elements contain 0.0. C C C Intrinsic functions required are: C C     DBLE, EXP, INT, MAX, MIN, REAL, SQRT C C C Acknowledgement C C  This program draws heavily on Temme's Algol program for Y(a,x) C  and Y(a+1,x) and on Campbell's programs for Y_nu(x).  Temme's C  scheme is used for  x < THRESH, and Campbell's scheme is used C  in the asymptotic region.  Segments of code from both sources C  have been translated into Fortran 77, merged, and heavily modified. C  Modifications include parameterization of machine dependencies, C  use of a new approximation for ln(gamma(x)), and built-in C  protection against over/underflow. C C References: \"Bessel functions J_nu(x) and Y_nu(x) of real C              order and real argument,\" Campbell, J. B., C              Comp. Phy. Comm. 18, 1979, pp. 133-142. C C             \"On the numerical evaluation of the ordinary C              Bessel function of the second kind,\" Temme, C              N. M., J. Comput. Phys. 21, 1976, pp. 343-350. C C  Latest modification: March 19, 1990 C C  Modified by: W. J. Cody C               Applied Mathematics Division C               Argonne National Laboratory C               Argonne, IL  60439 C C---------------------------------------------------------------------- INTEGER I , K , NA , NB , NCALC CS    REAL CD    DOUBLE PRECISION double precision 1 ALFA , ALPHA , AYE , B , BY , C , CH , COSMU , D , DEL , DEN , DDIV , DIV , DMU , D1 , D2 , 2 E , EIGHT , EN , ENU , EN1 , EPS , EVEN , EX , F , FIVPI , G , GAMMA , H , HALF , ODD , 3 ONBPI , ONE , ONE5 , P , PA , PA1 , PI , PIBY2 , PIM5 , Q , QA , QA1 , Q0 , R , S , SINMU , 4 SQ2BPI , TEN9 , TERM , THREE , THRESH , TWO , TWOBYX , X , XINF , XLARGE , XMIN , 5 XNA , X2 , YA , YA1 , ZERO DIMENSION BY ( NB ), CH ( 21 ) C---------------------------------------------------------------------- C  Mathematical constants C    FIVPI = 5*PI C    PIM5 = 5*PI - 15 C    ONBPI = 1/PI C    PIBY2 = PI/2 C    SQ2BPI = SQUARE ROOT OF 2/PI C---------------------------------------------------------------------- CS    DATA ZERO,HALF,ONE,TWO,THREE/0.0E0,0.5E0,1.0E0,2.0E0,3.0E0/ CS    DATA EIGHT,ONE5,TEN9/8.0E0,15.0E0,1.9E1/ CS    DATA FIVPI,PIBY2/1.5707963267948966192E1,1.5707963267948966192E0/ CS    DATA PI,SQ2BPI/3.1415926535897932385E0,7.9788456080286535588E-1/ CS    DATA PIM5,ONBPI/7.0796326794896619231E-1,3.1830988618379067154E-1/ CD    DATA ZERO,HALF,ONE,TWO,THREE/0.0D0,0.5D0,1.0D0,2.0D0,3.0D0/ CD    DATA EIGHT,ONE5,TEN9/8.0D0,15.0D0,1.9D1/ CD    DATA FIVPI,PIBY2/1.5707963267948966192D1,1.5707963267948966192D0/ CD    DATA PI,SQ2BPI/3.1415926535897932385D0,7.9788456080286535588D-1/ CD    DATA PIM5,ONBPI/7.0796326794896619231D-1,3.1830988618379067154D-1/ C---------------------------------------------------------------------- C  Machine-dependent constants C---------------------------------------------------------------------- CS    DATA DEL,XMIN,XINF,EPS/1.0E-4,2.36E-38,3.40E38,5.96E-8/ CS    DATA THRESH,XLARGE/8.0E0,1.0E4/ CD    DATA DEL,XMIN,XINF,EPS/1.0D-8,4.46D-308,1.79D308,1.11D-16/ CD    DATA THRESH,XLARGE/16.0D0,1.0D8/ C---------------------------------------------------------------------- C  Coefficients for Chebyshev polynomial expansion of C         1/gamma(1-x), abs(x) .le. .5 C---------------------------------------------------------------------- CS    DATA CH/-0.67735241822398840964E-23,-0.61455180116049879894E-22, CS   1         0.29017595056104745456E-20, 0.13639417919073099464E-18, CS   2         0.23826220476859635824E-17,-0.90642907957550702534E-17, CS   3        -0.14943667065169001769E-14,-0.33919078305362211264E-13, CS   4        -0.17023776642512729175E-12, 0.91609750938768647911E-11, CS   5         0.24230957900482704055E-09, 0.17451364971382984243E-08, CS   6        -0.33126119768180852711E-07,-0.86592079961391259661E-06, CS   7        -0.49717367041957398581E-05, 0.76309597585908126618E-04, CS   8         0.12719271366545622927E-02, 0.17063050710955562222E-02, CS   9        -0.76852840844786673690E-01,-0.28387654227602353814E+00, CS   A         0.92187029365045265648E+00/ CD    DATA CH/-0.67735241822398840964D-23,-0.61455180116049879894D-22, CD   1         0.29017595056104745456D-20, 0.13639417919073099464D-18, CD   2         0.23826220476859635824D-17,-0.90642907957550702534D-17, CD   3        -0.14943667065169001769D-14,-0.33919078305362211264D-13, CD   4        -0.17023776642512729175D-12, 0.91609750938768647911D-11, CD   5         0.24230957900482704055D-09, 0.17451364971382984243D-08, CD   6        -0.33126119768180852711D-07,-0.86592079961391259661D-06, CD   7        -0.49717367041957398581D-05, 0.76309597585908126618D-04, CD   8         0.12719271366545622927D-02, 0.17063050710955562222D-02, CD   9        -0.76852840844786673690D-01,-0.28387654227602353814D+00, CD   A         0.92187029365045265648D+00/ C---------------------------------------------------------------------- EX = X ENU = ALPHA IF (( NB . GT . 0 ) . AND . ( X . GE . XMIN ) . AND . ( EX . LT . XLARGE ) 1 . AND . ( ENU . GE . ZERO ) . AND . ( ENU . LT . ONE )) THEN XNA = AINT ( ENU + HALF ) NA = INT ( XNA ) IF ( NA . EQ . 1 ) ENU = ENU - XNA IF ( ENU . EQ . - HALF ) THEN P = SQ2BPI / SQRT ( EX ) YA = P * SIN ( EX ) YA1 = - P * COS ( EX ) ELSE IF ( EX . LT . THREE ) THEN C---------------------------------------------------------------------- C  Use Temme's scheme for small X C---------------------------------------------------------------------- B = EX * HALF D = - LOG ( B ) F = ENU * D E = B ** ( - ENU ) IF ( ABS ( ENU ) . LT . DEL ) THEN C = ONBPI ELSE C = ENU / SIN ( ENU * PI ) END IF C---------------------------------------------------------------------- C  Computation of sinh(f)/f C---------------------------------------------------------------------- IF ( ABS ( F ) . LT . ONE ) THEN X2 = F * F EN = TEN9 S = ONE DO 80 I = 1 , 9 S = S * X2 / EN / ( EN - ONE ) + ONE EN = EN - TWO 80 CONTINUE ELSE S = ( E - ONE / E ) * HALF / F END IF C---------------------------------------------------------------------- C  Computation of 1/gamma(1-a) using Chebyshev polynomials C---------------------------------------------------------------------- X2 = ENU * ENU * EIGHT AYE = CH ( 1 ) EVEN = ZERO ALFA = CH ( 2 ) ODD = ZERO DO 40 I = 3 , 19 , 2 EVEN = - ( AYE + AYE + EVEN ) AYE = - EVEN * X2 - AYE + CH ( I ) ODD = - ( ALFA + ALFA + ODD ) ALFA = - ODD * X2 - ALFA + CH ( I + 1 ) 40 CONTINUE EVEN = ( EVEN * HALF + AYE ) * X2 - AYE + CH ( 21 ) ODD = ( ODD + ALFA ) * TWO GAMMA = ODD * ENU + EVEN C---------------------------------------------------------------------- C  End of computation of 1/gamma(1-a) C---------------------------------------------------------------------- G = E * GAMMA E = ( E + ONE / E ) * HALF F = TWO * C * ( ODD * E + EVEN * S * D ) E = ENU * ENU P = G * C Q = ONBPI / G C = ENU * PIBY2 IF ( ABS ( C ) . LT . DEL ) THEN R = ONE ELSE R = SIN ( C ) / C END IF R = PI * C * R * R C = ONE D = - B * B H = ZERO YA = F + R * Q YA1 = P EN = ZERO 100 EN = EN + ONE IF ( ABS ( G / ( ONE + ABS ( YA ))) 1 + ABS ( H / ( ONE + ABS ( YA1 ))) . GT . EPS ) THEN F = ( F * EN + P + Q ) / ( EN * EN - E ) C = C * D / EN P = P / ( EN - ENU ) Q = Q / ( EN + ENU ) G = C * ( F + R * Q ) H = C * P - EN * G YA = YA + G YA1 = YA1 + H GO TO 100 END IF YA = - YA YA1 = - YA1 / B ELSE IF ( EX . LT . THRESH ) THEN C---------------------------------------------------------------------- C  Use Temme's scheme for moderate X C---------------------------------------------------------------------- C = ( HALF - ENU ) * ( HALF + ENU ) B = EX + EX E = ( EX * ONBPI * COS ( ENU * PI ) / EPS ) E = E * E P = ONE Q = - EX R = ONE + EX * EX S = R EN = TWO 200 IF ( R * EN * EN . LT . E ) THEN EN1 = EN + ONE D = ( EN - ONE + C / EN ) / S P = ( EN + EN - P * D ) / EN1 Q = ( - B + Q * D ) / EN1 S = P * P + Q * Q R = R * S EN = EN1 GO TO 200 END IF F = P / S P = F G = - Q / S Q = G 220 EN = EN - ONE IF ( EN . GT . ZERO ) THEN R = EN1 * ( TWO - P ) - TWO S = B + EN1 * Q D = ( EN - ONE + C / EN ) / ( R * R + S * S ) P = D * R Q = D * S E = F + ONE F = P * E - G * Q G = Q * E + P * G EN1 = EN GO TO 220 END IF F = ONE + F D = F * F + G * G PA = F / D QA = - G / D D = ENU + HALF - P Q = Q + EX PA1 = ( PA * Q - QA * D ) / EX QA1 = ( QA * Q + PA * D ) / EX B = EX - PIBY2 * ( ENU + HALF ) C = COS ( B ) S = SIN ( B ) D = SQ2BPI / SQRT ( EX ) YA = D * ( PA * S + QA * C ) YA1 = D * ( QA1 * S - PA1 * C ) ELSE C---------------------------------------------------------------------- C  Use Campbell's asymptotic scheme. C---------------------------------------------------------------------- NA = 0 D1 = AINT ( EX / FIVPI ) I = INT ( D1 ) DMU = (( EX - ONE5 * D1 ) - D1 * PIM5 ) - ( ALPHA + HALF ) * PIBY2 IF ( I - 2 * ( I / 2 ) . EQ . 0 ) THEN COSMU = COS ( DMU ) SINMU = SIN ( DMU ) ELSE COSMU = - COS ( DMU ) SINMU = - SIN ( DMU ) END IF DDIV = EIGHT * EX DMU = ALPHA DEN = SQRT ( EX ) DO 350 K = 1 , 2 P = COSMU COSMU = SINMU SINMU = - P D1 = ( TWO * DMU - ONE ) * ( TWO * DMU + ONE ) D2 = ZERO DIV = DDIV P = ZERO Q = ZERO Q0 = D1 / DIV TERM = Q0 DO 310 I = 2 , 20 D2 = D2 + EIGHT D1 = D1 - D2 DIV = DIV + DDIV TERM = - TERM * D1 / DIV P = P + TERM D2 = D2 + EIGHT D1 = D1 - D2 DIV = DIV + DDIV TERM = TERM * D1 / DIV Q = Q + TERM IF ( ABS ( TERM ) . LE . EPS ) GO TO 320 310 CONTINUE 320 P = P + ONE Q = Q + Q0 IF ( K . EQ . 1 ) THEN YA = SQ2BPI * ( P * COSMU - Q * SINMU ) / DEN ELSE YA1 = SQ2BPI * ( P * COSMU - Q * SINMU ) / DEN END IF DMU = DMU + ONE 350 CONTINUE END IF IF ( NA . EQ . 1 ) THEN H = TWO * ( ENU + ONE ) / EX IF ( H . GT . ONE ) THEN IF ( ABS ( YA1 ) . GT . XINF / H ) THEN H = ZERO YA = ZERO END IF END IF H = H * YA1 - YA YA = YA1 YA1 = H END IF C---------------------------------------------------------------------- C  Now have first one or two Y's C---------------------------------------------------------------------- BY ( 1 ) = YA BY ( 2 ) = YA1 IF ( YA1 . EQ . ZERO ) THEN NCALC = 1 ELSE AYE = ONE + ALPHA TWOBYX = TWO / EX NCALC = 2 DO 400 I = 3 , NB IF ( TWOBYX . LT . ONE ) THEN IF ( ABS ( BY ( I - 1 )) * TWOBYX . GE . XINF / AYE ) 1 GO TO 450 ELSE IF ( ABS ( BY ( I - 1 )) . GE . XINF / AYE / TWOBYX ) 1 GO TO 450 END IF BY ( I ) = TWOBYX * AYE * BY ( I - 1 ) - BY ( I - 2 ) AYE = AYE + ONE NCALC = NCALC + 1 400 CONTINUE END IF 450 DO 460 I = NCALC + 1 , NB BY ( I ) = ZERO 460 CONTINUE ELSE BY ( 1 ) = ZERO NCALC = MIN ( NB , 0 ) - 1 END IF 900 RETURN C---------- Last line of RYBESL ---------- END subroutine rybesl end module rjy","tags":"","loc":"sourcefile/rybesl.f.html"},{"title":"stats.f90 – RPN calculator in Fortran","text":"This file depends on sourcefile~~stats.f90~~EfferentGraph sourcefile~stats.f90 stats.f90 sourcefile~reg.f90 reg.f90 sourcefile~stats.f90->sourcefile~reg.f90 sourcefile~rat.f90 rat.f90 sourcefile~stats.f90->sourcefile~rat.f90 sourcefile~rat.f90->sourcefile~reg.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~stats.f90~~AfferentGraph sourcefile~stats.f90 stats.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~stats.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stats Source Code stats.f90 Source Code module stats use assert , only : wp implicit none contains !*********************************************************************************************************************************** !  CNR ! !  Combinations of N things taken R at a time. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION CNR ( N , R ) RESULT ( Y ) INTEGER , INTENT ( IN ) :: N , R INTEGER :: I , J Y = 1._wp J = N DO I = N - R , 1 , - 1 Y = Y * real ( j , wp ) / real ( i , wp ) J = J - 1 END DO END FUNCTION CNR !*********************************************************************************************************************************** !  PNR ! !  Permutations of N things taken R at a time. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION PNR ( N , R ) RESULT ( Y ) INTEGER , INTENT ( IN ) :: N , R INTEGER :: I , J Y = 1._wp J = N DO I = N - R , 1 , - 1 Y = Y * real ( j , wp ) / real ( i , wp ) J = J - 1 END DO DO I = R , 1 , - 1 Y = Y * real ( i , wp ) END DO END FUNCTION PNR !*********************************************************************************************************************************** !  LINREG ! !  Real linear regression. !*********************************************************************************************************************************** elemental SUBROUTINE LINREG ( M , B , R ) USE GLOBAL real ( wp ), INTENT ( OUT ) :: M , B , R M = ( NN * SUMXY - SUMX * SUMY ) / ( NN * SUMX2 - SUMX ** 2 ) B = ( SUMY * SUMX2 - SUMX * SUMXY ) / ( NN * SUMX2 - SUMX ** 2 ) R = ( SUMXY - SUMX * SUMY / NN ) / SQRT (( SUMX2 - SUMX ** 2 / NN ) * ( SUMY2 - SUMY ** 2 / NN )) END SUBROUTINE LINREG !*********************************************************************************************************************************** !  CLINREG ! !  Complex linear regression. !*********************************************************************************************************************************** elemental SUBROUTINE CLINREG ( M , B , R ) USE GLOBAL , only : cnn , csumxy , csumx , csumx2 , csumy , csumy2 COMPLEX ( wp ), INTENT ( OUT ) :: M , B , R M = ( CNN * CSUMXY - CSUMX * CSUMY ) / ( CNN * CSUMX2 - CSUMX ** 2 ) B = ( CSUMY * CSUMX2 - CSUMX * CSUMXY ) / ( CNN * CSUMX2 - CSUMX ** 2 ) R = ( CSUMXY - CSUMX * CSUMY / CNN ) / SQRT (( CSUMX2 - CSUMX ** 2 / CNN ) * ( CSUMY2 - CSUMY ** 2 / CNN )) END SUBROUTINE CLINREG !*********************************************************************************************************************************** !  RLINREG ! !  Rational linear regression. !*********************************************************************************************************************************** elemental SUBROUTINE RLINREG ( NM , DM , NB , DB , R ) use rat , only : rmul , rsub , rdiv USE GLOBAL INTEGER , INTENT ( OUT ) :: NM , DM , NB , DB real ( wp ), INTENT ( OUT ) :: R INTEGER :: NUM , DEN , NUM2 , DEN2 , NUM3 , DEN3 , NUM4 , DEN4 real ( wp ) :: DNN , DSUMX , DSUMX2 , DSUMY , DSUMY2 , DSUMXY CALL RMUL ( RNNN , RDNN , RNSUMXY , RDSUMXY , NUM , DEN ) CALL RMUL ( RNSUMX , RDSUMX , RNSUMY , RDSUMY , NUM2 , DEN2 ) CALL RSUB ( NUM , DEN , NUM2 , DEN2 , NUM3 , DEN3 ) CALL RMUL ( RNNN , RDNN , RNSUMX2 , RDSUMX2 , NUM , DEN ) CALL RMUL ( RNSUMX , RDSUMX , RNSUMX , RDSUMX , NUM2 , DEN2 ) CALL RSUB ( NUM , DEN , NUM2 , DEN2 , NUM4 , DEN4 ) CALL RDIV ( NUM3 , DEN3 , NUM4 , DEN4 , NM , DM ) CALL RMUL ( RNSUMY , RDSUMY , RNSUMX2 , RDSUMX2 , NUM , DEN ) CALL RMUL ( RNSUMX , RDSUMX , RNSUMXY , RDSUMXY , NUM2 , DEN2 ) CALL RSUB ( NUM , DEN , NUM2 , DEN2 , NUM3 , DEN3 ) CALL RMUL ( RNNN , RDNN , RNSUMX2 , RDSUMX2 , NUM , DEN ) CALL RMUL ( RNSUMX , RDSUMX , RNSUMX , RDSUMX , NUM2 , DEN2 ) CALL RSUB ( NUM , DEN , NUM2 , DEN2 , NUM4 , DEN4 ) CALL RDIV ( NUM3 , DEN3 , NUM4 , DEN4 , NB , DB ) DNN = DBLE ( RNNN ) / DBLE ( RDNN ) DSUMX = DBLE ( RNSUMX ) / DBLE ( RDSUMX ) DSUMX2 = DBLE ( RNSUMX2 ) / DBLE ( RDSUMX2 ) DSUMY = DBLE ( RNSUMY ) / DBLE ( RDSUMY ) DSUMY2 = DBLE ( RNSUMY2 ) / DBLE ( RDSUMY2 ) DSUMXY = DBLE ( RNSUMXY ) / DBLE ( RDSUMXY ) R = ( DSUMXY - DSUMX * DSUMY / DNN ) / SQRT (( DSUMX2 - DSUMX ** 2 / DNN ) * ( DSUMY2 - DSUMY ** 2 / DNN )) END SUBROUTINE RLINREG end module stats","tags":"","loc":"sourcefile/stats.f90.html"},{"title":"trig.f90 – RPN calculator in Fortran","text":"Files dependent on this one sourcefile~~trig.f90~~AfferentGraph sourcefile~trig.f90 trig.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~funcs.f90->sourcefile~trig.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~funcs.f90 sourcefile~ui.f90 ui.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~funcs.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules trig Source Code trig.f90 Source Code module trig use assert , only : wp implicit none interface csc procedure csc_r , csc_c end interface csc interface acsc procedure acsc_r , acsc_c end interface acsc interface sec procedure sec_r , sec_c end interface sec interface asec procedure asec_r , asec_c end interface asec interface cot procedure cot_r , cot_c end interface cot interface acot procedure acot_r , acot_c end interface acot interface hav procedure hav_r , hav_c end interface hav interface ahav procedure ahav_r , ahav_c end interface ahav interface crd procedure crd_r , crd_c end interface crd contains !*********************************************************************************************************************************** !  SEC ! !  Secant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION SEC_r ( X ) RESULT ( sec ) real ( wp ), INTENT ( IN ) :: X sec = 1._wp / COS ( X ) END FUNCTION SEC_r elemental complex ( wp ) FUNCTION SEC_c ( Z ) result ( sec ) COMPLEX ( wp ), INTENT ( IN ) :: Z SEC = 1._wp / COS ( Z ) END FUNCTION SEC_c !*********************************************************************************************************************************** !  ASEC ! !  Inverse secant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ASEC_r ( Y ) RESULT ( X ) real ( wp ), INTENT ( IN ) :: Y X = ACOS ( 1._wp / Y ) END FUNCTION ASEC_r elemental complex ( wp ) FUNCTION ASEC_c ( Z ) RESULT ( Y ) COMPLEX ( wp ), INTENT ( IN ) :: Z Y = ACOS ( 1._wp / Z ) END FUNCTION ASEC_c !*********************************************************************************************************************************** !  CSC ! !  Cosecant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION CSC_r ( X ) result ( csc ) real ( wp ), INTENT ( IN ) :: X CSC = 1._wp / SIN ( X ) END FUNCTION CSC_r elemental complex ( wp ) FUNCTION CSC_c ( Z ) result ( csc ) COMPLEX ( wp ), INTENT ( IN ) :: Z CSC = 1._wp / SIN ( Z ) END FUNCTION CSC_c !*********************************************************************************************************************************** !  ACSC ! !  Inverse cosecant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ACSC_r ( Y ) result ( acsc ) real ( wp ), INTENT ( IN ) :: Y ACSC = ASIN ( 1._wp / Y ) END FUNCTION ACSC_r elemental complex ( wp ) FUNCTION ACSC_c ( Z ) RESULT ( acsc ) COMPLEX ( wp ), INTENT ( IN ) :: Z acsc = ASIN ( 1._wp / Z ) END FUNCTION ACSC_c !*********************************************************************************************************************************** !  COT ! !  Cotangent. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION COT_r ( X ) result ( cot ) real ( wp ), INTENT ( IN ) :: X COT = 1._wp / TAN ( X ) END FUNCTION COT_r elemental complex ( wp ) FUNCTION COT_c ( Z ) result ( cot ) COMPLEX ( wp ), INTENT ( IN ) :: Z COT = COS ( Z ) / SIN ( Z ) END FUNCTION COT_c !*********************************************************************************************************************************** !  ACOT ! !  Inverse cotangent. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ACOT_r ( Y ) result ( acot ) real ( wp ), INTENT ( IN ) :: Y ACOT = ATAN ( 1._wp / Y ) END FUNCTION ACOT_r elemental complex ( wp ) FUNCTION ACOT_c ( Y ) result ( Acot ) complex ( wp ), INTENT ( IN ) :: Y ACOT = ATAN ( 1._wp / Y ) END FUNCTION ACOT_c !*********************************************************************************************************************************** !  ACOT2 ! !  Inverse cotangent (two arguments). !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ACOT2 ( Y , Z ) real ( wp ), INTENT ( IN ) :: Y ! cotangent numerator real ( wp ), INTENT ( IN ) :: Z ! cotangent denominator ACOT2 = ATAN2 ( Z , Y ) END FUNCTION ACOT2 !*********************************************************************************************************************************** !  EXSEC ! !  Exsecant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION EXSEC ( X ) real ( wp ), INTENT ( IN ) :: X EXSEC = 1._wp / COS ( X ) - 1._wp END FUNCTION EXSEC !*********************************************************************************************************************************** !  CEXSEC ! !  Complex exsecant. !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CEXSEC ( Z ) COMPLEX ( wp ), INTENT ( IN ) :: Z cexsec = 1._wp / COS ( Z ) - 1._wp END FUNCTION CEXSEC !*********************************************************************************************************************************** !  AEXSEC ! !  Inverse exsecant. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION AEXSEC ( Y ) real ( wp ), INTENT ( IN ) :: Y AEXSEC = ACOS ( 1._wp / ( Y + 1._wp )) END FUNCTION AEXSEC !*********************************************************************************************************************************** !  CAEXSEC ! !  Complex inverse exsecant. !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CAEXSEC ( Y ) RESULT ( X ) COMPLEX ( wp ), INTENT ( IN ) :: Y X = ACOS ( 1._wp / ( Y + 1._wp )) END FUNCTION CAEXSEC !*********************************************************************************************************************************** !  VERS ! !  Versine. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION VERS ( X ) real ( wp ), INTENT ( IN ) :: X VERS = 1._wp - COS ( X ) END FUNCTION VERS !*********************************************************************************************************************************** !  CVERS ! !  Complex versine. !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CVERS ( Z ) COMPLEX ( wp ), INTENT ( IN ) :: Z CVERS = 1._wp - COS ( Z ) END FUNCTION CVERS !*********************************************************************************************************************************** !  AVERS ! !  Inverse versine. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION AVERS ( Y ) real ( wp ), INTENT ( IN ) :: Y AVERS = ACOS ( 1._wp - Y ) END FUNCTION AVERS !*********************************************************************************************************************************** !  CAVERS ! !  Complex inverse versine. !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CAVERS ( Y ) RESULT ( X ) COMPLEX ( wp ), INTENT ( IN ) :: Y X = acos ( 1._wp - Y ) END FUNCTION CAVERS !************************************************************************************************* !  COVERS ! !  Coversine. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION COVERS ( X ) RESULT ( Y ) real ( wp ), INTENT ( IN ) :: X Y = 1._wp - SIN ( X ) END FUNCTION COVERS !*********************************************************************************************************************************** !  CCOVERS ! !  Complex coversine. !*********************************************************************************************************************************** FUNCTION CCOVERS ( Z ) RESULT ( Y ) COMPLEX ( wp ), INTENT ( IN ) :: Z COMPLEX ( wp ) :: Y Y = 1._wp - SIN ( Z ) END FUNCTION CCOVERS !*********************************************************************************************************************************** !  ACOVERS ! !  Inverse coversine. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ACOVERS ( Y ) RESULT ( X ) real ( wp ), INTENT ( IN ) :: Y X = ASIN ( 1._wp - Y ) END FUNCTION ACOVERS !*********************************************************************************************************************************** !  CACOVERS ! !  Complex inverse coversine. !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CACOVERS ( Y ) RESULT ( X ) COMPLEX ( wp ), INTENT ( IN ) :: Y X = ASIN ( 1._wp - Y ) END FUNCTION CACOVERS !*********************************************************************************************************************************** !  HAV ! !  Haversine. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION HAV_r ( X ) RESULT ( Y ) real ( wp ), INTENT ( IN ) :: X Y = ( SIN ( 0.5_wp * X )) ** 2 END FUNCTION HAV_r elemental complex ( wp ) FUNCTION HAV_c ( Z ) RESULT ( Y ) COMPLEX ( wp ), INTENT ( IN ) :: Z Y = ( SIN ( 0.5_wp * Z )) ** 2 END FUNCTION HAV_c !*********************************************************************************************************************************** !  AHAV ! !  Inverse haversine. !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION AHAV_r ( Y ) RESULT ( X ) real ( wp ), INTENT ( IN ) :: Y X = 2._wp * ASIN ( SQRT ( Y )) END FUNCTION AHAV_r elemental complex ( wp ) FUNCTION AHAV_c ( Y ) RESULT ( X ) COMPLEX ( wp ), INTENT ( IN ) :: Y X = 2._wp * asin ( SQRT ( Y )) END FUNCTION AHAV_c !*********************************************************************************************************************************** !  CRD ! !  Chord (of Ptolemy). !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION CRD_r ( X ) result ( crd ) real ( wp ), INTENT ( IN ) :: X CRD = 2._wp * SIN ( 0.5_wp * X ) END FUNCTION CRD_r elemental complex ( wp ) FUNCTION CRD_c ( Z ) RESULT ( crd ) COMPLEX ( wp ), INTENT ( IN ) :: Z CRD = 2._wp * SIN ( 0.5_wp * Z ) END FUNCTION CRD_c !*********************************************************************************************************************************** !  ACRD ! !  Inverse chord (of Ptolemy). !*********************************************************************************************************************************** elemental real ( wp ) FUNCTION ACRD ( Y ) RESULT ( X ) real ( wp ), INTENT ( IN ) :: Y X = 2.0D0 * ASIN ( 0.5D0 * Y ) END FUNCTION ACRD !*********************************************************************************************************************************** !  CACRD ! !  Complex inverse chord (of Ptolemy). !*********************************************************************************************************************************** elemental complex ( wp ) FUNCTION CACRD ( Y ) RESULT ( X ) COMPLEX ( wp ), INTENT ( IN ) :: Y X = 2.0D0 * asin ( 0.5D0 * Y ) END FUNCTION CACRD end module trig","tags":"","loc":"sourcefile/trig.f90.html"},{"title":"ui.f90 – RPN calculator in Fortran","text":"This file depends on sourcefile~~ui.f90~~EfferentGraph sourcefile~ui.f90 ui.f90 sourcefile~funcs.f90 funcs.f90 sourcefile~ui.f90->sourcefile~funcs.f90 sourcefile~reg.f90 reg.f90 sourcefile~ui.f90->sourcefile~reg.f90 sourcefile~gamma.f90 gamma.f90 sourcefile~funcs.f90->sourcefile~gamma.f90 sourcefile~trig.f90 trig.f90 sourcefile~funcs.f90->sourcefile~trig.f90 sourcefile~rat.f90 rat.f90 sourcefile~funcs.f90->sourcefile~rat.f90 sourcefile~hyper.f90 hyper.F90 sourcefile~funcs.f90->sourcefile~hyper.f90 sourcefile~stats.f90 stats.f90 sourcefile~funcs.f90->sourcefile~stats.f90 sourcefile~bessel.f90 bessel.f90 sourcefile~funcs.f90->sourcefile~bessel.f90 sourcefile~gamma.f90->sourcefile~rat.f90 sourcefile~gamma.f90->sourcefile~hyper.f90 sourcefile~rat.f90->sourcefile~reg.f90 sourcefile~hyper.f90->sourcefile~reg.f90 sourcefile~hyper.f90->sourcefile~rat.f90 sourcefile~stats.f90->sourcefile~reg.f90 sourcefile~stats.f90->sourcefile~rat.f90 sourcefile~k1.f k1.f sourcefile~bessel.f90->sourcefile~k1.f sourcefile~ribesl.f ribesl.f sourcefile~bessel.f90->sourcefile~ribesl.f sourcefile~rybesl.f rybesl.f sourcefile~bessel.f90->sourcefile~rybesl.f sourcefile~k0.f k0.f sourcefile~bessel.f90->sourcefile~k0.f sourcefile~rkbesl.f rkbesl.f sourcefile~bessel.f90->sourcefile~rkbesl.f sourcefile~i0.f i0.f sourcefile~bessel.f90->sourcefile~i0.f sourcefile~i1.f i1.f sourcefile~bessel.f90->sourcefile~i1.f sourcefile~rjbesl.f rjbesl.f sourcefile~bessel.f90->sourcefile~rjbesl.f Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~ui.f90~~AfferentGraph sourcefile~ui.f90 ui.f90 sourcefile~calc.f90 calc.f90 sourcefile~calc.f90->sourcefile~ui.f90 sourcefile~eval.f90 eval.f90 sourcefile~calc.f90->sourcefile~eval.f90 sourcefile~eval.f90->sourcefile~ui.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules stackops Source Code ui.f90 Source Code module stackops use , intrinsic :: iso_fortran_env , only : stderr => error_unit use global use assert , only : wp , isclose use funcs implicit none interface push_stack procedure push_stack_r , cpush_stack , rpush_stack end interface push_stack interface printx procedure printx_r , cprintx , rprintx end interface complex ( wp ), parameter , private :: c0 = ( 0._wp , 0._wp ) contains !*********************************************************************************************************************************** !  PUSH_STACK ! !  Push a number onto the real stack. !*********************************************************************************************************************************** SUBROUTINE PUSH_STACK_r ( X ) real ( wp ), INTENT ( IN ) :: X stack = cshift ( stack , - 1 ) STACK ( 1 ) = X END SUBROUTINE PUSH_STACK_r !*********************************************************************************************************************************** !  push_stack ! !  Push a number onto the complex stack. !*********************************************************************************************************************************** SUBROUTINE CPUSH_STACK ( X ) COMPLEX ( wp ), INTENT ( IN ) :: X cstack = cshift ( cstack , - 1 ) CSTACK ( 1 ) = X END SUBROUTINE CPUSH_STACK !*********************************************************************************************************************************** !  RPUSH_STACK ! !  Push a number onto the rational stack. !*********************************************************************************************************************************** SUBROUTINE RPUSH_STACK ( RN , RD ) INTEGER , INTENT ( IN ) :: RN , RD rnstack = cshift ( rnstack , - 1 ) rdstack = cshift ( rdstack , - 1 ) RNSTACK ( 1 ) = RN RDSTACK ( 1 ) = RD END SUBROUTINE RPUSH_STACK !*********************************************************************************************************************************** !  DROP_STACK ! !  Drop a number from the real stack. !*********************************************************************************************************************************** SUBROUTINE DROP_STACK ( N ) INTEGER , INTENT ( IN ) :: N STACK ( N : stack_size - 1 ) = STACK ( N + 1 : stack_size ) stack ( stack_size ) = 0._wp END SUBROUTINE DROP_STACK !*********************************************************************************************************************************** !  CDROP_STACK ! !  Drop a number from the complex stack. !*********************************************************************************************************************************** SUBROUTINE CDROP_STACK ( N ) INTEGER , INTENT ( IN ) :: N CSTACK ( N : stack_size - 1 ) = CSTACK ( N + 1 : stack_size ) Cstack ( stack_size ) = 0._wp END SUBROUTINE CDROP_STACK !*********************************************************************************************************************************** !  RDROP_STACK ! !  Drop a number from the rational stack. !*********************************************************************************************************************************** SUBROUTINE RDROP_STACK ( N ) INTEGER , INTENT ( IN ) :: N RNSTACK ( N : stack_size - 1 ) = RNSTACK ( N + 1 : stack_size ) RDSTACK ( N : stack_size - 1 ) = RDSTACK ( N + 1 : stack_size ) RNstack ( stack_size ) = 0 RDstack ( stack_size ) = 0 END SUBROUTINE RDROP_STACK !*********************************************************************************************************************************** !  PRINTX ! !  Print a real number to a string. !*********************************************************************************************************************************** SUBROUTINE PRINTX_r ( X , NUMSTR ) real ( wp ), INTENT ( IN ) :: X CHARACTER ( 100 ), INTENT ( OUT ) :: NUMSTR real ( wp ) :: TMPX CHARACTER ( 9 ) :: F1 , F2 , F3 character ( 1 ) :: F write ( F , '(I1)' ) DISP_DIGITS F1 = '(4F15.' // F // ')' F2 = '(5ES15.' // F // ')' F3 = '(5EN15.' // F // ')' IF ( BASE_MODE == 10 ) THEN ! DEC mode SELECT CASE ( DISP_MODE ) CASE ( 1 ) ! print X (FIX) WRITE ( NUMSTR , F1 ) X IF ( INDEX ( NUMSTR , '*' ) /= 0 ) WRITE ( NUMSTR , F2 ) X READ ( NUMSTR , * ) TMPX IF (. not . isclose ( x , 0._wp ) . AND . isclose ( TMPX , 0._wp )) WRITE ( NUMSTR , F2 ) X !   disp. underflow CASE ( 2 ) ! print X (SCI) WRITE ( NUMSTR , F2 ) X CASE ( 3 ) ! print X (ENG) WRITE ( NUMSTR , F3 ) X CASE ( 4 ) ! print X (ALL) WRITE ( NUMSTR , '(1PG23.15)' ) X END SELECT ELSE SELECT CASE ( BASE_MODE ) CASE ( 2 ) ! print X (BIN) WRITE ( NUMSTR , '(B0)' ) INT ( X ) CASE ( 8 ) ! print X (OCT) WRITE ( NUMSTR , '(O0)' ) INT ( X ) CASE ( 16 ) ! print X (HEX) WRITE ( NUMSTR , '(Z0)' ) INT ( X ) END SELECT END IF END SUBROUTINE PRINTX_r !*********************************************************************************************************************************** !  CPRINTX ! !  Print a complex number to a string. !*********************************************************************************************************************************** SUBROUTINE CPRINTX ( X , NUMSTR ) COMPLEX ( wp ), INTENT ( IN ) :: X CHARACTER ( LEN = 100 ), INTENT ( OUT ) :: NUMSTR COMPLEX ( wp ) :: TMPX CHARACTER ( LEN = 100 ) :: FMTSTR IF ( BASE_MODE == 10 ) THEN ! DEC mode SELECT CASE ( DISP_MODE ) CASE ( 1 ) ! print X (FIX) WRITE ( UNIT = FMTSTR , FMT = 800 ) DISP_DIGITS , DISP_DIGITS 800 FORMAT ( \"(ES25.\" , I0 , \",SP,4X,F25.\" , I0 , \")\" ) WRITE ( UNIT = NUMSTR , FMT = FMTSTR ) REAL ( X , WP ), AIMAG ( X ) IF ( INDEX ( NUMSTR , '*' ) /= 0 ) THEN !   disp. overflow WRITE ( UNIT = FMTSTR , FMT = 810 ) DISP_DIGITS , DISP_DIGITS 810 FORMAT ( \"(EN25.\" , I0 , \",SP,4X,ES25.\" , I0 , \")\" ) WRITE ( UNIT = NUMSTR , FMT = FMTSTR ) REAL ( X , WP ), AIMAG ( X ) END IF READ ( UNIT = NUMSTR , FMT =* ) TMPX IF (. not . isclose ( x , C0 ) . AND . isclose ( TMPX , C0 )) THEN !   disp. underflow WRITE ( UNIT = FMTSTR , FMT = 820 ) DISP_DIGITS , DISP_DIGITS 820 FORMAT ( \"(EN25.\" , I0 , \",SP,4X,ES25.\" , I0 , \")\" ) WRITE ( UNIT = NUMSTR , FMT = FMTSTR ) REAL ( X , WP ), AIMAG ( X ) END IF CASE ( 2 ) ! print X (SCI) WRITE ( UNIT = FMTSTR , FMT = 830 ) DISP_DIGITS , DISP_DIGITS 830 FORMAT ( \"(ES25.\" , I0 , \",SP,4X,ES25.\" , I0 , \")\" ) WRITE ( UNIT = NUMSTR , FMT = FMTSTR ) REAL ( X , WP ), AIMAG ( X ) CASE ( 3 ) ! print X (ENG) WRITE ( UNIT = FMTSTR , FMT = 840 ) DISP_DIGITS , DISP_DIGITS 840 FORMAT ( \"(EN25.\" , I0 , \",SP,4X,ES25.\" , I0 , \")\" ) WRITE ( UNIT = NUMSTR , FMT = FMTSTR ) REAL ( X , WP ), AIMAG ( X ) CASE ( 4 ) ! print X (ALL) WRITE ( UNIT = FMTSTR , FMT = '(A)' ) '(1PG23.15,SP,4X,G23.15)' WRITE ( UNIT = NUMSTR , FMT = FMTSTR ) REAL ( X , WP ), AIMAG ( X ) END SELECT ELSE SELECT CASE ( BASE_MODE ) CASE ( 2 ) ! print X (BIN) WRITE ( UNIT = FMTSTR , FMT = '(A)' ) '(B0,4X,B0,2H i)' WRITE ( UNIT = NUMSTR , FMT = FMTSTR ) INT ( REAL ( X , WP )), INT ( AIMAG ( X )) CASE ( 8 ) ! print X (OCT) WRITE ( UNIT = FMTSTR , FMT = '(A)' ) '(O0,4X,O0,2H i)' WRITE ( UNIT = NUMSTR , FMT = FMTSTR ) INT ( REAL ( X , WP )), INT ( AIMAG ( X )) CASE ( 16 ) ! print X (HEX) WRITE ( UNIT = FMTSTR , FMT = '(A)' ) '(Z0,4X,Z0,2H i)' WRITE ( UNIT = NUMSTR , FMT = FMTSTR ) INT ( REAL ( X , WP )), INT ( AIMAG ( X )) END SELECT END IF END SUBROUTINE CPRINTX !*********************************************************************************************************************************** !  RPRINTX ! !  Print a rational number to a string. !*********************************************************************************************************************************** SUBROUTINE RPRINTX ( RN , RD , NUMSTR ) INTEGER , INTENT ( IN ) :: RN , RD CHARACTER ( LEN = 100 ), INTENT ( OUT ) :: NUMSTR INTEGER :: A1 , A2 , A3 SELECT CASE ( BASE_MODE ) CASE ( 2 ) ! print X (BIN) IF ( RD == 1 ) THEN WRITE ( UNIT = NUMSTR , FMT = '(B0)' ) RN ELSE SELECT CASE ( FRACTION_MODE ) CASE ( 1 ) WRITE ( UNIT = NUMSTR , FMT = '(B0,A3,B0)' ) RN , ' / ' , RD CASE ( 2 ) CALL FRAC_TO_MIXED ( RN , RD , A1 , A2 , A3 ) WRITE ( UNIT = NUMSTR , FMT = '(B0,3X,B0,A3,B0)' ) A1 , A2 , ' / ' , A3 END SELECT END IF CASE ( 8 ) ! print X (OCT) IF ( RD == 1 ) THEN WRITE ( UNIT = NUMSTR , FMT = '(O0)' ) RN ELSE SELECT CASE ( FRACTION_MODE ) CASE ( 1 ) WRITE ( UNIT = NUMSTR , FMT = '(O0,A3,O0)' ) RN , ' / ' , RD CASE ( 2 ) CALL FRAC_TO_MIXED ( RN , RD , A1 , A2 , A3 ) WRITE ( UNIT = NUMSTR , FMT = '(O0,3X,O0,A3,O0)' ) A1 , A2 , ' / ' , A3 END SELECT END IF CASE ( 10 ) ! print X (DEC) IF ( RD == 1 ) THEN WRITE ( UNIT = NUMSTR , FMT = '(I0)' ) RN ELSE SELECT CASE ( FRACTION_MODE ) CASE ( 1 ) WRITE ( UNIT = NUMSTR , FMT = '(I0,A3,I0)' ) RN , ' / ' , RD CASE ( 2 ) CALL FRAC_TO_MIXED ( RN , RD , A1 , A2 , A3 ) WRITE ( UNIT = NUMSTR , FMT = '(I0,3X,I0,A3,I0)' ) A1 , A2 , ' / ' , A3 END SELECT END IF CASE ( 16 ) ! print X (HEX) IF ( RD == 1 ) THEN WRITE ( UNIT = NUMSTR , FMT = '(Z0)' ) RN ELSE SELECT CASE ( FRACTION_MODE ) CASE ( 1 ) WRITE ( UNIT = NUMSTR , FMT = '(Z0,A3,Z0)' ) RN , ' / ' , RD CASE ( 2 ) CALL FRAC_TO_MIXED ( RN , RD , A1 , A2 , A3 ) WRITE ( UNIT = NUMSTR , FMT = '(Z0,3X,Z0,A3,Z0)' ) A1 , A2 , ' / ' , A3 END SELECT END IF !         CASE (16)                                                                  ! print X (HEX) !            IF (RD == 1) THEN !               WRITE (UNIT=NUMSTR, FMT='(Z0)') RN !            ELSE !               WRITE (UNIT=NUMSTR, FMT='(Z0,3H / ,Z0)') RN, RD !            END IF END SELECT END SUBROUTINE RPRINTX end module stackops","tags":"","loc":"sourcefile/ui.f90.html"},{"title":"jinc – RPN calculator in Fortran","text":"public elemental function jinc(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Calls proc~~jinc~~CallsGraph proc~jinc jinc isclose isclose proc~jinc->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/jinc.html"},{"title":"EVAL – RPN calculator in Fortran","text":"public recursive subroutine EVAL(STR) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: STR Calls proc~~eval~~CallsGraph proc~eval EVAL proc~eval->proc~eval proc~csinhc CSINHC proc~eval->proc~csinhc acoth acoth proc~eval->acoth acovers acovers proc~eval->acovers isfrac isfrac proc~eval->isfrac interface~push_stack push_stack proc~eval->interface~push_stack hav hav proc~eval->hav interface~cuberoot cuberoot proc~eval->interface~cuberoot proc~add add proc~eval->proc~add exsec exsec proc~eval->exsec jinc jinc proc~eval->jinc cexsec cexsec proc~eval->cexsec proc~sinhc SINHC proc~eval->proc~sinhc ribesl ribesl proc~eval->ribesl proc~hms2h HMS2H proc~eval->proc~hms2h acot2 acot2 proc~eval->acot2 hatan hatan proc~eval->hatan cgamma cgamma proc~eval->cgamma proc~tanhc TANHC proc~eval->proc~tanhc proc~multiply multiply proc~eval->proc~multiply interface~tanc tanc proc~eval->interface~tanc isclose isclose proc~eval->isclose cacovers cacovers proc~eval->cacovers gcd gcd proc~eval->gcd proc~rdrop_stack RDROP_STACK proc~eval->proc~rdrop_stack vers vers proc~eval->vers aexsec aexsec proc~eval->aexsec crd crd proc~eval->crd beta beta proc~eval->beta csc csc proc~eval->csc stack stack proc~eval->stack proc~clog10 CLOG10 proc~eval->proc~clog10 radd radd proc~eval->radd rdstack rdstack proc~eval->rdstack rmul rmul proc~eval->rmul proc~rnint RNINT proc~eval->proc~rnint switch_rat_to_real switch_rat_to_real proc~eval->switch_rat_to_real besi1 besi1 proc~eval->besi1 linreg linreg proc~eval->linreg rnreg rnreg proc~eval->rnreg rsub rsub proc~eval->rsub rybesl rybesl proc~eval->rybesl rdiv rdiv proc~eval->rdiv rkbesl rkbesl proc~eval->rkbesl isint isint proc~eval->isint proc~rint RINT proc~eval->proc~rint asec asec proc~eval->asec covers covers proc~eval->covers cot cot proc~eval->cot rnstack rnstack proc~eval->rnstack acsc acsc proc~eval->acsc cnr cnr proc~eval->cnr ccovers ccovers proc~eval->ccovers proc~bsj bsj proc~eval->proc~bsj psi psi proc~eval->psi besi0 besi0 proc~eval->besi0 proc~cmod CMOD proc~eval->proc~cmod sec sec proc~eval->sec sech sech proc~eval->sech proc~drop_stack DROP_STACK proc~eval->proc~drop_stack cacrd cacrd proc~eval->cacrd reg reg proc~eval->reg besk1 besk1 proc~eval->besk1 proc~cint CINT proc~eval->proc~cint proc~print_help print_help proc~eval->proc~print_help hacos hacos proc~eval->hacos lcm lcm proc~eval->lcm creg creg proc~eval->creg proc~rfrac RFRAC proc~eval->proc~rfrac proc~ctanhc CTANHC proc~eval->proc~ctanhc interface~sinc sinc proc~eval->interface~sinc acrd acrd proc~eval->acrd cbeta cbeta proc~eval->cbeta besk0 besk0 proc~eval->besk0 proc~kepler KEPLER proc~eval->proc~kepler cvers cvers proc~eval->cvers proc~rmod RMOD proc~eval->proc~rmod proc~subtract subtract proc~eval->proc~subtract caexsec caexsec proc~eval->caexsec asech asech proc~eval->asech proc~regops regops proc~eval->proc~regops proc~reduce REDUCE proc~eval->proc~reduce coth coth proc~eval->coth dec_to_frac dec_to_frac proc~eval->dec_to_frac clinreg clinreg proc~eval->clinreg rlinreg rlinreg proc~eval->rlinreg acot acot proc~eval->acot rbeta rbeta proc~eval->rbeta proc~riemannzeta RIEMANNZETA proc~eval->proc~riemannzeta proc~cdrop_stack CDROP_STACK proc~eval->proc~cdrop_stack interface~printx printx proc~eval->interface~printx hasin hasin proc~eval->hasin interface~frac frac proc~eval->interface~frac cstack cstack proc~eval->cstack proc~power power proc~eval->proc~power avers avers proc~eval->avers csch csch proc~eval->csch acsch acsch proc~eval->acsch proc~h2hmsd H2HMSD proc~eval->proc~h2hmsd proc~divide divide proc~eval->proc~divide ahav ahav proc~eval->ahav proc~bsy0 bsy0 proc~eval->proc~bsy0 rdreg rdreg proc~eval->rdreg pnr pnr proc~eval->pnr cavers cavers proc~eval->cavers proc~csinhc->isclose proc~cpush_stack CPUSH_STACK interface~push_stack->proc~cpush_stack proc~rpush_stack RPUSH_STACK interface~push_stack->proc~rpush_stack proc~push_stack_r PUSH_STACK_r interface~push_stack->proc~push_stack_r proc~cuberoot_c CUBEROOT_c interface~cuberoot->proc~cuberoot_c proc~cuberoot_r CUBEROOT_r interface~cuberoot->proc~cuberoot_r proc~add->proc~rdrop_stack proc~add->stack proc~add->radd proc~add->rdstack proc~add->rnstack proc~add->proc~drop_stack proc~add->proc~cdrop_stack proc~add->cstack proc~sinhc->isclose proc~multiply->proc~rdrop_stack proc~multiply->stack proc~multiply->rdstack proc~multiply->rmul proc~multiply->rnstack proc~multiply->proc~drop_stack proc~multiply->proc~cdrop_stack proc~multiply->cstack proc~tanc_c TANC_c interface~tanc->proc~tanc_c proc~tanc_r TANC_r interface~tanc->proc~tanc_r proc~rdrop_stack->rdstack proc~rdrop_stack->rnstack proc~rsub RSUB proc~rnint->proc~rsub proc~ratnorm RATNORM proc~rnint->proc~ratnorm proc~radd RADD proc~rnint->proc~radd proc~rint->proc~ratnorm proc~bsj->proc~drop_stack proc~bsj->interface~frac rjbesl rjbesl proc~bsj->rjbesl proc~cmod->proc~cint proc~drop_stack->stack proc~rfrac->proc~rint proc~rfrac->proc~rsub proc~rfrac->proc~ratnorm proc~sinc_c SINC_c interface~sinc->proc~sinc_c proc~sinc_r SINC_r interface~sinc->proc~sinc_r proc~kepler->proc~reduce proc~rmod->proc~rint proc~rmod->proc~rsub proc~rmod->proc~ratnorm proc~rdiv RDIV proc~rmod->proc~rdiv proc~rmul RMUL proc~rmod->proc~rmul proc~subtract->proc~rdrop_stack proc~subtract->stack proc~subtract->rdstack proc~subtract->rsub proc~subtract->rnstack proc~subtract->proc~drop_stack proc~subtract->proc~cdrop_stack proc~subtract->cstack proc~regops->interface~push_stack proc~regops->stack proc~regops->rdstack proc~regops->rnreg proc~regops->rnstack proc~regops->reg proc~regops->creg proc~regops->cstack proc~regops->rdreg proc~cdrop_stack->cstack proc~cprintx CPRINTX interface~printx->proc~cprintx proc~printx_r PRINTX_r interface~printx->proc~printx_r proc~rprintx RPRINTX interface~printx->proc~rprintx proc~frac_r FRAC_r interface~frac->proc~frac_r proc~frac_c FRAC_c interface~frac->proc~frac_c proc~power->proc~rdrop_stack proc~power->stack proc~power->rdstack proc~power->switch_rat_to_real proc~power->rnstack proc~power->proc~drop_stack proc~power->proc~cdrop_stack proc~power->cstack proc~divide->isclose proc~divide->proc~rdrop_stack proc~divide->stack proc~divide->rdstack proc~divide->rdiv proc~divide->rnstack proc~divide->proc~drop_stack proc~divide->proc~cdrop_stack proc~divide->cstack proc~tanc_c->isclose proc~cprintx->isclose proc~sinc_c->isclose proc~rsub->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd proc~printx_r->isclose frac_to_mixed frac_to_mixed proc~rprintx->frac_to_mixed proc~cpush_stack->cstack proc~rpush_stack->rdstack proc~rpush_stack->rnstack proc~rdiv->proc~ratnorm proc~radd->proc~ratnorm proc~sinc_r->isclose proc~push_stack_r->stack proc~tanc_r->isclose proc~rmul->proc~ratnorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~eval~~CalledByGraph proc~eval EVAL proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eval.html"},{"title":"regops – RPN calculator in Fortran","text":"private subroutine regops(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Calls proc~~regops~~CallsGraph proc~regops regops interface~push_stack push_stack proc~regops->interface~push_stack stack stack proc~regops->stack rnreg rnreg proc~regops->rnreg reg reg proc~regops->reg rdstack rdstack proc~regops->rdstack rnstack rnstack proc~regops->rnstack rdreg rdreg proc~regops->rdreg creg creg proc~regops->creg cstack cstack proc~regops->cstack proc~rpush_stack RPUSH_STACK interface~push_stack->proc~rpush_stack proc~cpush_stack CPUSH_STACK interface~push_stack->proc~cpush_stack proc~push_stack_r PUSH_STACK_r interface~push_stack->proc~push_stack_r proc~rpush_stack->rdstack proc~rpush_stack->rnstack proc~cpush_stack->cstack proc~push_stack_r->stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~regops~~CalledByGraph proc~regops regops proc~eval EVAL proc~eval->proc~regops proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/regops.html"},{"title":"add – RPN calculator in Fortran","text":"private subroutine add(mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode Calls proc~~add~~CallsGraph proc~add add stack stack proc~add->stack proc~drop_stack DROP_STACK proc~add->proc~drop_stack proc~cdrop_stack CDROP_STACK proc~add->proc~cdrop_stack radd radd proc~add->radd rdstack rdstack proc~add->rdstack proc~rdrop_stack RDROP_STACK proc~add->proc~rdrop_stack rnstack rnstack proc~add->rnstack cstack cstack proc~add->cstack proc~drop_stack->stack proc~cdrop_stack->cstack proc~rdrop_stack->rdstack proc~rdrop_stack->rnstack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~add~~CalledByGraph proc~add add proc~eval EVAL proc~eval->proc~add proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/add.html"},{"title":"subtract – RPN calculator in Fortran","text":"private subroutine subtract(mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode Calls proc~~subtract~~CallsGraph proc~subtract subtract stack stack proc~subtract->stack proc~drop_stack DROP_STACK proc~subtract->proc~drop_stack proc~cdrop_stack CDROP_STACK proc~subtract->proc~cdrop_stack rsub rsub proc~subtract->rsub rdstack rdstack proc~subtract->rdstack proc~rdrop_stack RDROP_STACK proc~subtract->proc~rdrop_stack rnstack rnstack proc~subtract->rnstack cstack cstack proc~subtract->cstack proc~drop_stack->stack proc~cdrop_stack->cstack proc~rdrop_stack->rdstack proc~rdrop_stack->rnstack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~subtract~~CalledByGraph proc~subtract subtract proc~eval EVAL proc~eval->proc~subtract proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/subtract.html"},{"title":"multiply – RPN calculator in Fortran","text":"private subroutine multiply(mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode Calls proc~~multiply~~CallsGraph proc~multiply multiply stack stack proc~multiply->stack proc~drop_stack DROP_STACK proc~multiply->proc~drop_stack proc~cdrop_stack CDROP_STACK proc~multiply->proc~cdrop_stack rdstack rdstack proc~multiply->rdstack proc~rdrop_stack RDROP_STACK proc~multiply->proc~rdrop_stack rmul rmul proc~multiply->rmul rnstack rnstack proc~multiply->rnstack cstack cstack proc~multiply->cstack proc~drop_stack->stack proc~cdrop_stack->cstack proc~rdrop_stack->rdstack proc~rdrop_stack->rnstack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~multiply~~CalledByGraph proc~multiply multiply proc~eval EVAL proc~eval->proc~multiply proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/multiply.html"},{"title":"divide – RPN calculator in Fortran","text":"private subroutine divide(mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode Calls proc~~divide~~CallsGraph proc~divide divide isclose isclose proc~divide->isclose stack stack proc~divide->stack proc~drop_stack DROP_STACK proc~divide->proc~drop_stack proc~cdrop_stack CDROP_STACK proc~divide->proc~cdrop_stack rdiv rdiv proc~divide->rdiv rdstack rdstack proc~divide->rdstack proc~rdrop_stack RDROP_STACK proc~divide->proc~rdrop_stack rnstack rnstack proc~divide->rnstack cstack cstack proc~divide->cstack proc~drop_stack->stack proc~cdrop_stack->cstack proc~rdrop_stack->rdstack proc~rdrop_stack->rnstack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~divide~~CalledByGraph proc~divide divide proc~eval EVAL proc~eval->proc~divide proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/divide.html"},{"title":"power – RPN calculator in Fortran","text":"private subroutine power(mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode Calls proc~~power~~CallsGraph proc~power power stack stack proc~power->stack proc~drop_stack DROP_STACK proc~power->proc~drop_stack proc~cdrop_stack CDROP_STACK proc~power->proc~cdrop_stack rdstack rdstack proc~power->rdstack proc~rdrop_stack RDROP_STACK proc~power->proc~rdrop_stack rnstack rnstack proc~power->rnstack switch_rat_to_real switch_rat_to_real proc~power->switch_rat_to_real cstack cstack proc~power->cstack proc~drop_stack->stack proc~cdrop_stack->cstack proc~rdrop_stack->rdstack proc~rdrop_stack->rnstack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~power~~CalledByGraph proc~power power proc~eval EVAL proc~eval->proc~power proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/power.html"},{"title":"bsj – RPN calculator in Fortran","text":"private subroutine bsj() Arguments None Calls proc~~bsj~~CallsGraph proc~bsj bsj rjbesl rjbesl proc~bsj->rjbesl interface~frac frac proc~bsj->interface~frac proc~drop_stack DROP_STACK proc~bsj->proc~drop_stack proc~frac_r FRAC_r interface~frac->proc~frac_r proc~frac_c FRAC_c interface~frac->proc~frac_c stack stack proc~drop_stack->stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~bsj~~CalledByGraph proc~bsj bsj proc~eval EVAL proc~eval->proc~bsj proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bsj.html"},{"title":"bsy0 – RPN calculator in Fortran","text":"private subroutine bsy0() Arguments None Called by proc~~bsy0~~CalledByGraph proc~bsy0 bsy0 proc~eval EVAL proc~eval->proc~bsy0 proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bsy0.html"},{"title":"FRAC_r – RPN calculator in Fortran","text":"public elemental function FRAC_r(X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~frac_r~~CalledByGraph proc~frac_r FRAC_r interface~frac frac interface~frac->proc~frac_r proc~eval EVAL proc~eval->interface~frac proc~eval->proc~eval proc~bsj bsj proc~eval->proc~bsj proc~bsj->interface~frac program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/frac_r.html"},{"title":"FRAC_c – RPN calculator in Fortran","text":"public elemental function FRAC_c(X) result(frac) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X Return Value complex(kind=wp) Called by proc~~frac_c~~CalledByGraph proc~frac_c FRAC_c interface~frac frac interface~frac->proc~frac_c proc~eval EVAL proc~eval->interface~frac proc~eval->proc~eval proc~bsj bsj proc~eval->proc~bsj proc~bsj->interface~frac program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/frac_c.html"},{"title":"CINT – RPN calculator in Fortran","text":"public elemental function CINT(X) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X Return Value complex(kind=wp) Called by proc~~cint~~CalledByGraph proc~cint CINT proc~eval EVAL proc~eval->proc~cint proc~eval->proc~eval proc~cmod CMOD proc~eval->proc~cmod proc~cmod->proc~cint program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cint.html"},{"title":"RINT – RPN calculator in Fortran","text":"public elemental function RINT(N, D) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: D Return Value integer Calls proc~~rint~~CallsGraph proc~rint RINT proc~ratnorm RATNORM proc~rint->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rint~~CalledByGraph proc~rint RINT proc~eval EVAL proc~eval->proc~rint proc~eval->proc~eval proc~rmod RMOD proc~eval->proc~rmod proc~rfrac RFRAC proc~eval->proc~rfrac proc~rmod->proc~rint proc~rfrac->proc~rint program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rint.html"},{"title":"CMOD – RPN calculator in Fortran","text":"public elemental function CMOD(X, Y) result(Z) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Calls proc~~cmod~~CallsGraph proc~cmod CMOD proc~cint CINT proc~cmod->proc~cint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cmod~~CalledByGraph proc~cmod CMOD proc~eval EVAL proc~eval->proc~cmod proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cmod.html"},{"title":"CUBEROOT_r – RPN calculator in Fortran","text":"public elemental function CUBEROOT_r(X) result(cuberoot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~cuberoot_r~~CalledByGraph proc~cuberoot_r CUBEROOT_r interface~cuberoot cuberoot interface~cuberoot->proc~cuberoot_r proc~eval EVAL proc~eval->interface~cuberoot proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cuberoot_r.html"},{"title":"CUBEROOT_c – RPN calculator in Fortran","text":"public elemental function CUBEROOT_c(Z) result(cuberoot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~cuberoot_c~~CalledByGraph proc~cuberoot_c CUBEROOT_c interface~cuberoot cuberoot interface~cuberoot->proc~cuberoot_c proc~eval EVAL proc~eval->interface~cuberoot proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cuberoot_c.html"},{"title":"CLOG10 – RPN calculator in Fortran","text":"public elemental function CLOG10(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X Return Value complex(kind=wp) Called by proc~~clog10~~CalledByGraph proc~clog10 CLOG10 proc~eval EVAL proc~eval->proc~clog10 proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/clog10.html"},{"title":"LOG1P – RPN calculator in Fortran","text":"public elemental function LOG1P(X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Contents None","tags":"","loc":"proc/log1p.html"},{"title":"SINC_r – RPN calculator in Fortran","text":"public elemental function SINC_r(X) result(sinc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Calls proc~~sinc_r~~CallsGraph proc~sinc_r SINC_r isclose isclose proc~sinc_r->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~sinc_r~~CalledByGraph proc~sinc_r SINC_r interface~sinc sinc interface~sinc->proc~sinc_r proc~eval EVAL proc~eval->interface~sinc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sinc_r.html"},{"title":"SINC_c – RPN calculator in Fortran","text":"public elemental function SINC_c(Z) result(sinc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Calls proc~~sinc_c~~CallsGraph proc~sinc_c SINC_c isclose isclose proc~sinc_c->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~sinc_c~~CalledByGraph proc~sinc_c SINC_c interface~sinc sinc interface~sinc->proc~sinc_c proc~eval EVAL proc~eval->interface~sinc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sinc_c.html"},{"title":"TANC_r – RPN calculator in Fortran","text":"public elemental function TANC_r(X) result(tanc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Calls proc~~tanc_r~~CallsGraph proc~tanc_r TANC_r isclose isclose proc~tanc_r->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~tanc_r~~CalledByGraph proc~tanc_r TANC_r interface~tanc tanc interface~tanc->proc~tanc_r proc~eval EVAL proc~eval->interface~tanc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tanc_r.html"},{"title":"TANC_c – RPN calculator in Fortran","text":"public elemental function TANC_c(Z) result(tanc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Calls proc~~tanc_c~~CallsGraph proc~tanc_c TANC_c isclose isclose proc~tanc_c->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~tanc_c~~CalledByGraph proc~tanc_c TANC_c interface~tanc tanc interface~tanc->proc~tanc_c proc~eval EVAL proc~eval->interface~tanc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tanc_c.html"},{"title":"SINHC – RPN calculator in Fortran","text":"public elemental function SINHC(X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Calls proc~~sinhc~~CallsGraph proc~sinhc SINHC isclose isclose proc~sinhc->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~sinhc~~CalledByGraph proc~sinhc SINHC proc~eval EVAL proc~eval->proc~sinhc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sinhc.html"},{"title":"CSINHC – RPN calculator in Fortran","text":"public elemental function CSINHC(Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Calls proc~~csinhc~~CallsGraph proc~csinhc CSINHC isclose isclose proc~csinhc->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~csinhc~~CalledByGraph proc~csinhc CSINHC proc~eval EVAL proc~eval->proc~csinhc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/csinhc.html"},{"title":"TANHC – RPN calculator in Fortran","text":"public elemental function TANHC(X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~tanhc~~CalledByGraph proc~tanhc TANHC proc~eval EVAL proc~eval->proc~tanhc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/tanhc.html"},{"title":"CTANHC – RPN calculator in Fortran","text":"public elemental function CTANHC(Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~ctanhc~~CalledByGraph proc~ctanhc CTANHC proc~eval EVAL proc~eval->proc~ctanhc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ctanhc.html"},{"title":"ERFCX – RPN calculator in Fortran","text":"public elemental function ERFCX(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Contents None","tags":"","loc":"proc/erfcx.html"},{"title":"RIEMANNZETA – RPN calculator in Fortran","text":"public elemental function RIEMANNZETA(S, EPS) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: S real(kind=wp), intent(in) :: EPS Return Value real(kind=wp) Called by proc~~riemannzeta~~CalledByGraph proc~riemannzeta RIEMANNZETA proc~eval EVAL proc~eval->proc~riemannzeta proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/riemannzeta.html"},{"title":"REDUCE – RPN calculator in Fortran","text":"public elemental function REDUCE(THETA, ANGLE_MIN) result(RHO) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: THETA real(kind=wp), intent(in) :: ANGLE_MIN Return Value real(kind=wp) Called by proc~~reduce~~CalledByGraph proc~reduce REDUCE proc~eval EVAL proc~eval->proc~reduce proc~eval->proc~eval proc~kepler KEPLER proc~eval->proc~kepler proc~kepler->proc~reduce program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/reduce.html"},{"title":"KEPLER – RPN calculator in Fortran","text":"public elemental function KEPLER(MA, ECC) result(E5) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: MA real(kind=wp), intent(in) :: ECC Return Value real(kind=wp) Calls proc~~kepler~~CallsGraph proc~kepler KEPLER proc~reduce REDUCE proc~kepler->proc~reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~kepler~~CalledByGraph proc~kepler KEPLER proc~eval EVAL proc~eval->proc~kepler proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kepler.html"},{"title":"toLower – RPN calculator in Fortran","text":"public elemental function toLower(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) Contents None","tags":"","loc":"proc/tolower.html"},{"title":"toUpper – RPN calculator in Fortran","text":"public elemental function toUpper(str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) Called by proc~~toupper~~CalledByGraph proc~toupper toUpper program~rpn RPN program~rpn->proc~toupper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/toupper.html"},{"title":"RFRAC – RPN calculator in Fortran","text":"public elemental subroutine RFRAC(N, D, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: D integer, intent(out) :: NR integer, intent(out) :: DR Calls proc~~rfrac~~CallsGraph proc~rfrac RFRAC proc~rsub RSUB proc~rfrac->proc~rsub proc~ratnorm RATNORM proc~rfrac->proc~ratnorm proc~rint RINT proc~rfrac->proc~rint proc~rsub->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd proc~rint->proc~ratnorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rfrac~~CalledByGraph proc~rfrac RFRAC proc~eval EVAL proc~eval->proc~rfrac proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rfrac.html"},{"title":"RNINT – RPN calculator in Fortran","text":"public elemental subroutine RNINT(N, D) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: N integer, intent(inout) :: D Calls proc~~rnint~~CallsGraph proc~rnint RNINT proc~radd RADD proc~rnint->proc~radd proc~rsub RSUB proc~rnint->proc~rsub proc~ratnorm RATNORM proc~rnint->proc~ratnorm proc~radd->proc~ratnorm proc~rsub->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rnint~~CalledByGraph proc~rnint RNINT proc~eval EVAL proc~eval->proc~rnint proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rnint.html"},{"title":"RMOD – RPN calculator in Fortran","text":"public elemental subroutine RMOD(N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR Calls proc~~rmod~~CallsGraph proc~rmod RMOD proc~ratnorm RATNORM proc~rmod->proc~ratnorm proc~rdiv RDIV proc~rmod->proc~rdiv proc~rsub RSUB proc~rmod->proc~rsub proc~rmul RMUL proc~rmod->proc~rmul proc~rint RINT proc~rmod->proc~rint proc~gcd GCD proc~ratnorm->proc~gcd proc~rdiv->proc~ratnorm proc~rsub->proc~ratnorm proc~rmul->proc~ratnorm proc~rint->proc~ratnorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmod~~CalledByGraph proc~rmod RMOD proc~eval EVAL proc~eval->proc~rmod proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmod.html"},{"title":"H2HMSD – RPN calculator in Fortran","text":"public elemental subroutine H2HMSD(DHR, IHR, IMIN, SEC) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: DHR integer, intent(out) :: IHR integer, intent(out) :: IMIN real(kind=wp), intent(out) :: SEC Called by proc~~h2hmsd~~CalledByGraph proc~h2hmsd H2HMSD proc~eval EVAL proc~eval->proc~h2hmsd proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/h2hmsd.html"},{"title":"HMS2H – RPN calculator in Fortran","text":"public elemental subroutine HMS2H(IHR, IMIN, SEC, DHR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: IHR integer, intent(in) :: IMIN real(kind=wp), intent(in) :: SEC real(kind=wp), intent(out) :: DHR Called by proc~~hms2h~~CalledByGraph proc~hms2h HMS2H proc~eval EVAL proc~eval->proc~hms2h proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hms2h.html"},{"title":"cuberoot – RPN calculator in Fortran","text":"public interface cuberoot Calls interface~~cuberoot~~CallsGraph interface~cuberoot cuberoot proc~cuberoot_c CUBEROOT_c interface~cuberoot->proc~cuberoot_c proc~cuberoot_r CUBEROOT_r interface~cuberoot->proc~cuberoot_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~cuberoot~~CalledByGraph interface~cuberoot cuberoot proc~eval EVAL proc~eval->interface~cuberoot proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures cuberoot_r cuberoot_c Module Procedures public elemental function CUBEROOT_r (X) result(cuberoot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CUBEROOT_c (Z) result(cuberoot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/cuberoot.html"},{"title":"frac – RPN calculator in Fortran","text":"public interface frac Calls interface~~frac~~CallsGraph interface~frac frac proc~frac_r FRAC_r interface~frac->proc~frac_r proc~frac_c FRAC_c interface~frac->proc~frac_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~frac~~CalledByGraph interface~frac frac proc~eval EVAL proc~eval->interface~frac proc~eval->proc~eval proc~bsj bsj proc~eval->proc~bsj proc~bsj->interface~frac program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures frac_r frac_c Module Procedures public elemental function FRAC_r (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function FRAC_c (X) result(frac) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X Return Value complex(kind=wp)","tags":"","loc":"interface/frac.html"},{"title":"sinc – RPN calculator in Fortran","text":"public interface sinc Calls interface~~sinc~~CallsGraph interface~sinc sinc proc~sinc_c SINC_c interface~sinc->proc~sinc_c proc~sinc_r SINC_r interface~sinc->proc~sinc_r isclose isclose proc~sinc_c->isclose proc~sinc_r->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~sinc~~CalledByGraph interface~sinc sinc proc~eval EVAL proc~eval->interface~sinc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sinc_r sinc_c Module Procedures public elemental function SINC_r (X) result(sinc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SINC_c (Z) result(sinc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/sinc.html"},{"title":"tanc – RPN calculator in Fortran","text":"public interface tanc Calls interface~~tanc~~CallsGraph interface~tanc tanc proc~tanc_c TANC_c interface~tanc->proc~tanc_c proc~tanc_r TANC_r interface~tanc->proc~tanc_r isclose isclose proc~tanc_c->isclose proc~tanc_r->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~tanc~~CalledByGraph interface~tanc tanc proc~eval EVAL proc~eval->interface~tanc proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures tanc_r tanc_c Module Procedures public elemental function TANC_r (X) result(tanc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function TANC_c (Z) result(tanc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/tanc.html"},{"title":"PSI – RPN calculator in Fortran","text":"public function PSI(XX) Explanation of machine-dependent constants XINF   = largest positive machine number\n   XMAX1  = beta (p-1), where beta is the radix for the\n            floating-point system, and p is the number of base-beta\n            digits in the floating-point significand.  This is an\n            upper bound on non-integral floating-point numbers, and\n            the negative of the lower bound on acceptable negative\n            arguments for PSI.  If rounding is necessary, round this\n            value down.\n   XMIN1  = the smallest in magnitude acceptable argument.  We\n            recommend XMIN1 = MAX(1/XINF,xmin) rounded up, where\n            xmin is the smallest positive floating-point number.\n   XSMALL = absolute argument below which  PI COTAN(PI X)  may be\n            represented by 1/X.  We recommend XSMALL < sqrt(3 eps)/pi,\n            where eps is the smallest positive number such that\n            1+eps > 1.\n   XLARGE = argument beyond which PSI(X) may be represented by\n            LOG(X).  The solution to the equation\n               x*ln(x) = beta p\n            is a safe value. Approximate values for some important machines are beta p eps xmin XINF CDC 7600      (S.P.)    2  48  7.11E-15  3.13E-294  1.26E+322\n  CRAY-1        (S.P.)    2  48  7.11E-15  4.58E-2467 5.45E+2465\n  IEEE (IBM/XT,\n    SUN, etc.)  (S.P.)    2  24  1.19E-07  1.18E-38   3.40E+38\n  IEEE (IBM/XT,\n    SUN, etc.)  (D.P.)    2  53  1.11D-16  2.23E-308  1.79D+308\n  IBM 3033      (D.P.)   16  14  1.11D-16  5.40D-79   7.23D+75\n  SUN 3/160     (D.P.)    2  53  1.11D-16  2.23D-308  1.79D+308\n  VAX 11/780    (S.P.)    2  24  5.96E-08  2.94E-39   1.70E+38\n                (D.P.)    2  56  1.39D-17  2.94D-39   1.70D+38\n   (G Format)   (D.P.)    2  53  1.11D-16  5.57D-309  8.98D+307 XMIN1 XMAX1 XSMALL XLARGE CDC 7600      (S.P.)  3.13E-294  1.40E+14  4.64E-08  9.42E+12\n  CRAY-1        (S.P.)  1.84E-2466 1.40E+14  4.64E-08  9.42E+12\n  IEEE (IBM/XT,\n    SUN, etc.)  (S.P.)  1.18E-38   8.38E+06  1.90E-04  1.20E+06\n  IEEE (IBM/XT,\n    SUN, etc.)  (D.P.)  2.23D-308  4.50D+15  5.80D-09  2.71D+14\n  IBM 3033      (D.P.)  1.39D-76   4.50D+15  5.80D-09  2.05D+15\n  SUN 3/160     (D.P.)  2.23D-308  4.50D+15  5.80D-09  2.71D+14\n  VAX 11/780    (S.P.)  5.89E-39   8.38E+06  1.35E-04  1.20E+06\n                (D.P.)  5.89D-39   3.60D+16  2.05D-09  2.05D+15\n   (G Format)   (D.P.)  1.12D-308  4.50D+15  5.80D-09  2.71D+14 Error Returns The program returns XINF for  X < -XMAX1, for X zero or a negative\n    integer, or when X lies in (-XMIN1, 0), and returns -XINF\n    when X lies in (0, XMIN1). Intrinsic functions required are: ABS , AINT , DBLE , INT , LOG , REAL , TAN Author: W. J. Cody\n          Mathematics and Computer Science Division\n          Argonne National Laboratory\n          Argonne, IL 60439 Latest modification: June 8, 1988 Arguments Type Intent Optional Attributes Name real(kind=wp) :: XX Return Value real(kind=wp) Called by proc~~psi~~CalledByGraph proc~psi PSI proc~cgamma CGAMMA proc~cgamma->proc~psi proc~cbeta CBETA proc~cbeta->proc~cgamma Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/psi.html"},{"title":"CGAMMA – RPN calculator in Fortran","text":"public function CGAMMA(Z) result(R) Uses hyper proc~~cgamma~~UsesGraph proc~cgamma CGAMMA module~hyper hyper proc~cgamma->module~hyper assert assert module~hyper->assert iso_fortran_env iso_fortran_env module~hyper->iso_fortran_env ieee_arithmetic ieee_arithmetic module~hyper->ieee_arithmetic module~rat rat module~hyper->module~rat module~global GLOBAL module~hyper->module~global module~rat->assert module~rat->iso_fortran_env module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Calls proc~~cgamma~~CallsGraph proc~cgamma CGAMMA interface~csch csch proc~cgamma->interface~csch proc~psi PSI proc~cgamma->proc~psi proc~csch_c CSCH_c interface~csch->proc~csch_c proc~csch_r CSCH_r interface~csch->proc~csch_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cgamma~~CalledByGraph proc~cgamma CGAMMA proc~cbeta CBETA proc~cbeta->proc~cgamma Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cgamma.html"},{"title":"BETA – RPN calculator in Fortran","text":"public elemental function BETA(X, Y) result(R) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Contents None","tags":"","loc":"proc/beta.html"},{"title":"CBETA – RPN calculator in Fortran","text":"public function CBETA(X, Y) result(R) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Calls proc~~cbeta~~CallsGraph proc~cbeta CBETA proc~cgamma CGAMMA proc~cbeta->proc~cgamma interface~csch csch proc~cgamma->interface~csch proc~psi PSI proc~cgamma->proc~psi proc~csch_c CSCH_c interface~csch->proc~csch_c proc~csch_r CSCH_r interface~csch->proc~csch_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cbeta.html"},{"title":"RBETA – RPN calculator in Fortran","text":"public elemental subroutine RBETA(X, Y, N, D) Uses rat proc~~rbeta~~UsesGraph proc~rbeta RBETA module~rat rat proc~rbeta->module~rat iso_fortran_env iso_fortran_env module~rat->iso_fortran_env assert assert module~rat->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: X integer, intent(in) :: Y integer, intent(out) :: N integer, intent(out) :: D Calls proc~~rbeta~~CallsGraph proc~rbeta RBETA proc~ratnorm RATNORM proc~rbeta->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rbeta.html"},{"title":"print_help – RPN calculator in Fortran","text":"public subroutine print_help() Arguments None Called by proc~~print_help~~CalledByGraph proc~print_help print_help proc~eval EVAL proc~eval->proc~print_help proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_help.html"},{"title":"SECH_r – RPN calculator in Fortran","text":"public elemental function SECH_r(X) result(sech) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~sech_r~~CalledByGraph proc~sech_r SECH_r interface~sech sech interface~sech->proc~sech_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sech_r.html"},{"title":"SECH_c – RPN calculator in Fortran","text":"public elemental function SECH_c(Z) result(sech) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~sech_c~~CalledByGraph proc~sech_c SECH_c interface~sech sech interface~sech->proc~sech_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sech_c.html"},{"title":"ASECH_r – RPN calculator in Fortran","text":"public elemental function ASECH_r(Y) result(asech) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Called by proc~~asech_r~~CalledByGraph proc~asech_r ASECH_r interface~asech asech interface~asech->proc~asech_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/asech_r.html"},{"title":"ASECH_c – RPN calculator in Fortran","text":"public elemental function ASECH_c(Y) result(asech) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Called by proc~~asech_c~~CalledByGraph proc~asech_c ASECH_c interface~asech asech interface~asech->proc~asech_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/asech_c.html"},{"title":"CSCH_r – RPN calculator in Fortran","text":"public elemental function CSCH_r(X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~csch_r~~CalledByGraph proc~csch_r CSCH_r interface~csch csch interface~csch->proc~csch_r proc~cgamma CGAMMA proc~cgamma->interface~csch proc~cbeta CBETA proc~cbeta->proc~cgamma Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/csch_r.html"},{"title":"CSCH_c – RPN calculator in Fortran","text":"public elemental function CSCH_c(Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~csch_c~~CalledByGraph proc~csch_c CSCH_c interface~csch csch interface~csch->proc~csch_c proc~cgamma CGAMMA proc~cgamma->interface~csch proc~cbeta CBETA proc~cbeta->proc~cgamma Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/csch_c.html"},{"title":"ACSCH_r – RPN calculator in Fortran","text":"public elemental function ACSCH_r(Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Called by proc~~acsch_r~~CalledByGraph proc~acsch_r ACSCH_r interface~acsch acsch interface~acsch->proc~acsch_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acsch_r.html"},{"title":"ACSCH_c – RPN calculator in Fortran","text":"public elemental function ACSCH_c(Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Called by proc~~acsch_c~~CalledByGraph proc~acsch_c ACSCH_c interface~acsch acsch interface~acsch->proc~acsch_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acsch_c.html"},{"title":"COTH_r – RPN calculator in Fortran","text":"public elemental function COTH_r(X) result(coth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~coth_r~~CalledByGraph proc~coth_r COTH_r interface~coth coth interface~coth->proc~coth_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/coth_r.html"},{"title":"COTH_c – RPN calculator in Fortran","text":"public elemental function COTH_c(Z) result(coth) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~coth_c~~CalledByGraph proc~coth_c COTH_c interface~coth coth interface~coth->proc~coth_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/coth_c.html"},{"title":"ACOTH_r – RPN calculator in Fortran","text":"public elemental function ACOTH_r(Y) result(acoth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Called by proc~~acoth_r~~CalledByGraph proc~acoth_r ACOTH_r interface~acoth acoth interface~acoth->proc~acoth_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acoth_r.html"},{"title":"ACOTH_c – RPN calculator in Fortran","text":"public elemental function ACOTH_c(Z) result(acoth) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~acoth_c~~CalledByGraph proc~acoth_c ACOTH_c interface~acoth acoth interface~acoth->proc~acoth_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acoth_c.html"},{"title":"hasin – RPN calculator in Fortran","text":"public subroutine hasin(domain_mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: domain_mode Calls proc~~hasin~~CallsGraph proc~hasin hasin stack stack proc~hasin->stack proc~switch_rat_to_real SWITCH_RAT_TO_REAL proc~hasin->proc~switch_rat_to_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hasin.html"},{"title":"hacos – RPN calculator in Fortran","text":"public subroutine hacos(domain_mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: domain_mode Calls proc~~hacos~~CallsGraph proc~hacos hacos stack stack proc~hacos->stack rnstack rnstack proc~hacos->rnstack rdstack rdstack proc~hacos->rdstack proc~switch_rat_to_real SWITCH_RAT_TO_REAL proc~hacos->proc~switch_rat_to_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hacos.html"},{"title":"hatan – RPN calculator in Fortran","text":"public subroutine hatan(domain_mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: domain_mode Calls proc~~hatan~~CallsGraph proc~hatan hatan stack stack proc~hatan->stack rnstack rnstack proc~hatan->rnstack rdstack rdstack proc~hatan->rdstack proc~switch_rat_to_real SWITCH_RAT_TO_REAL proc~hatan->proc~switch_rat_to_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hatan.html"},{"title":"sech – RPN calculator in Fortran","text":"public interface sech Calls interface~~sech~~CallsGraph interface~sech sech proc~sech_r SECH_r interface~sech->proc~sech_r proc~sech_c SECH_c interface~sech->proc~sech_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sech_r sech_c Module Procedures public elemental function SECH_r (X) result(sech) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SECH_c (Z) result(sech) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/sech.html"},{"title":"asech – RPN calculator in Fortran","text":"public interface asech Calls interface~~asech~~CallsGraph interface~asech asech proc~asech_c ASECH_c interface~asech->proc~asech_c proc~asech_r ASECH_r interface~asech->proc~asech_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures asech_r asech_c Module Procedures public elemental function ASECH_r (Y) result(asech) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ASECH_c (Y) result(asech) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp)","tags":"","loc":"interface/asech.html"},{"title":"csch – RPN calculator in Fortran","text":"public interface csch Calls interface~~csch~~CallsGraph interface~csch csch proc~csch_c CSCH_c interface~csch->proc~csch_c proc~csch_r CSCH_r interface~csch->proc~csch_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~csch~~CalledByGraph interface~csch csch proc~cgamma CGAMMA proc~cgamma->interface~csch proc~cbeta CBETA proc~cbeta->proc~cgamma Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures csch_r csch_c Module Procedures public elemental function CSCH_r (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CSCH_c (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/csch.html"},{"title":"acsch – RPN calculator in Fortran","text":"public interface acsch Calls interface~~acsch~~CallsGraph interface~acsch acsch proc~acsch_c ACSCH_c interface~acsch->proc~acsch_c proc~acsch_r ACSCH_r interface~acsch->proc~acsch_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures acsch_r acsch_c Module Procedures public elemental function ACSCH_r (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACSCH_c (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp)","tags":"","loc":"interface/acsch.html"},{"title":"coth – RPN calculator in Fortran","text":"public interface coth Calls interface~~coth~~CallsGraph interface~coth coth proc~coth_r COTH_r interface~coth->proc~coth_r proc~coth_c COTH_c interface~coth->proc~coth_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures coth_r coth_c Module Procedures public elemental function COTH_r (X) result(coth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function COTH_c (Z) result(coth) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/coth.html"},{"title":"acoth – RPN calculator in Fortran","text":"public interface acoth Calls interface~~acoth~~CallsGraph interface~acoth acoth proc~acoth_c ACOTH_c interface~acoth->proc~acoth_c proc~acoth_r ACOTH_r interface~acoth->proc~acoth_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures acoth_r acoth_c Module Procedures public elemental function ACOTH_r (Y) result(acoth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACOTH_c (Z) result(acoth) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/acoth.html"},{"title":"BESI0 – RPN calculator in Fortran","text":"public function BESI0(X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Calls proc~~besi0~~CallsGraph proc~besi0 BESI0 proc~calci0 CALCI0 proc~besi0->proc~calci0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/besi0.html"},{"title":"BESEI0 – RPN calculator in Fortran","text":"private function BESEI0(X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Calls proc~~besei0~~CallsGraph proc~besei0 BESEI0 proc~calci0 CALCI0 proc~besei0->proc~calci0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/besei0.html"},{"title":"CALCI0 – RPN calculator in Fortran","text":"private subroutine CALCI0(ARG, RESULT, JINT) Explanation of machine-dependent constants beta   = Radix for the floating-point system\n   maxexp = Smallest power of beta that overflows\n   XSMALL = Positive argument such that 1.0 - X = 1.0 to\n            machine precision for all ABS(X) .LE. XSMALL.\n   XINF =   Largest positive machine number; approximately\n            beta maxexp\n   XMAX =   Largest argument acceptable to BESI0;  Solution to\n            equation: W(X) * (1+1/(8 X)+9/(128 X 2) = beta maxexp\n            where  W(X) = EXP(X)/SQRT(2 PI X) Approximate values for some important machines are : beta maxexp XSMALL CRAY-1        (S.P.)       2         8191       3.55E-15\n Cyber 180/855\n   under NOS   (S.P.)       2         1070       3.55E-15\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)       2          128       2.98E-8\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)       2         1024       5.55D-17\n IBM 3033      (D.P.)      16           63       6.95D-18\n VAX           (S.P.)       2          127       2.98E-8\n VAX D-Format  (D.P.)       2          127       6.95D-18\n VAX G-Format  (D.P.)       2         1023       5.55D-17 XINF XMAX CRAY-1        (S.P.)       5.45E+2465     5682.810\n Cyber 180/855\n   under NOS   (S.P.)       1.26E+322       745.893\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)       3.40E+38         91.900\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)       1.79D+308       713.986\n IBM 3033      (D.P.)       7.23D+75        178.182\n VAX           (S.P.)       1.70D+38         91.203\n VAX D-Format  (D.P.)       1.70D+38         91.203\n VAX G-Format  (D.P.)       8.98D+307       713.293 Error returns The program returns XINF for BESI0 for ABS(ARG) .GT. XMAX. Intrinsic functions required are: ABS , SQRT , EXP Authors: W. J. Cody and L. Stoltz\n           Mathematics and Computer Science Division\n           Argonne National Laboratory\n           Argonne, IL 60439 Latest modification: June 7, 1988 Arguments Type Intent Optional Attributes Name double precision :: ARG double precision :: RESULT integer :: JINT Called by proc~~calci0~~CalledByGraph proc~calci0 CALCI0 proc~besi0 BESI0 proc~besi0->proc~calci0 proc~besei0 BESEI0 proc~besei0->proc~calci0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calci0.html"},{"title":"BESI1 – RPN calculator in Fortran","text":"public function BESI1(X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Calls proc~~besi1~~CallsGraph proc~besi1 BESI1 proc~calci1 CALCI1 proc~besi1->proc~calci1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/besi1.html"},{"title":"BESEI1 – RPN calculator in Fortran","text":"private function BESEI1(X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Calls proc~~besei1~~CallsGraph proc~besei1 BESEI1 proc~calci1 CALCI1 proc~besei1->proc~calci1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/besei1.html"},{"title":"CALCI1 – RPN calculator in Fortran","text":"private subroutine CALCI1(ARG, RESULT, JINT) Explanation of machine-dependent constants beta   = Radix for the floating-point system\n   maxexp = Smallest power of beta that overflows\n   XSMALL = Positive argument such that 1.0 - X = 1.0 to\n            machine precision for all ABS(X) .LE. XSMALL.\n   XINF =   Largest positive machine number; approximately\n            beta maxexp\n   XMAX =   Largest argument acceptable to BESI1;  Solution to\n            equation: \n               EXP(X) * (1-3/(8 X)) / SQRT(2 PI*X) = beta maxexp Approximate values for some important machines are : beta maxexp XSMALL CRAY-1        (S.P.)       2         8191       3.55E-15\n Cyber 180/855\n   under NOS   (S.P.)       2         1070       3.55E-15\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)       2          128       2.98E-8\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)       2         1024       5.55D-17\n IBM 3033      (D.P.)      16           63       6.95D-18\n VAX           (S.P.)       2          127       2.98E-8\n VAX D-Format  (D.P.)       2          127       6.95D-18\n VAX G-Format  (D.P.)       2         1023       5.55D-17 XINF XMAX CRAY-1        (S.P.)       5.45E+2465     5682.810\n Cyber 180/855\n   under NOS   (S.P.)       1.26E+322       745.894\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)       3.40E+38         91.906\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)       1.79D+308       713.987\n IBM 3033      (D.P.)       7.23D+75        178.185\n VAX           (S.P.)       1.70D+38         91.209\n VAX D-Format  (D.P.)       1.70D+38         91.209\n VAX G-Format  (D.P.)       8.98D+307       713.293 Error returns The program returns the value XINF for ABS(ARG) .GT. XMAX. Intrinsic functions required are: ABS , SQRT , EXP Authors: W. J. Cody and L. Stoltz\n           Mathematics and Computer Science Division\n           Argonne National Laboratory\n           Argonne, IL  60439 Latest modification: May 31, 1989 Arguments Type Intent Optional Attributes Name double precision :: ARG double precision :: RESULT integer :: JINT Called by proc~~calci1~~CalledByGraph proc~calci1 CALCI1 proc~besi1 BESI1 proc~besi1->proc~calci1 proc~besei1 BESEI1 proc~besei1->proc~calci1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calci1.html"},{"title":"BESK0 – RPN calculator in Fortran","text":"public function BESK0(X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Calls proc~~besk0~~CallsGraph proc~besk0 BESK0 proc~calck0 CALCK0 proc~besk0->proc~calck0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/besk0.html"},{"title":"BESEK0 – RPN calculator in Fortran","text":"private function BESEK0(X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Calls proc~~besek0~~CallsGraph proc~besek0 BESEK0 proc~calck0 CALCK0 proc~besek0->proc~calck0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/besek0.html"},{"title":"CALCK0 – RPN calculator in Fortran","text":"private subroutine CALCK0(ARG, RESULT, JINT) Explanation of machine-dependent constants beta   = Radix for the floating-point system\n   minexp = Smallest representable power of beta\n   maxexp = Smallest power of beta that overflows\n   XSMALL = Argument below which BESK0 and BESEK0 may\n            each be represented by a constant and a log.\n            largest X such that  1.0 + X = 1.0  to machine\n            precision.\n   XINF   = Largest positive machine number; approximately\n            beta maxexp\n   XMAX   = Largest argument acceptable to BESK0;  Solution to\n            equation: \n               W(X) * (1-1/8X+9/128X 2) = beta* minexp\n            where  W(X) = EXP(-X) SQRT(PI/2X) Approximate values for some important machines are : beta minexp maxexp CRAY-1        (S.P.)       2        -8193         8191\n  Cyber 180/185 \n    under NOS   (S.P.)       2         -975         1070\n  IEEE (IBM/XT,\n    SUN, etc.)  (S.P.)       2         -126          128\n  IEEE (IBM/XT,\n    SUN, etc.)  (D.P.)       2        -1022         1024\n  IBM 3033      (D.P.)      16          -65           63\n  VAX D-Format  (D.P.)       2         -128          127\n  VAX G-Format  (D.P.)       2        -1024         1023 XSMALL XINF XMAX CRAY-1        (S.P.)    3.55E-15   5.45E+2465    5674.858\n Cyber 180/855\n   under NOS   (S.P.)    1.77E-15   1.26E+322      672.788\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)    5.95E-8    3.40E+38        85.337\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)    1.11D-16   1.79D+308      705.342\n IBM 3033      (D.P.)    1.11D-16   7.23D+75       177.852\n VAX D-Format  (D.P.)    6.95D-18   1.70D+38        86.715\n VAX G-Format  (D.P.)    5.55D-17   8.98D+307      706.728 Error returns The program returns the value XINF for ARG .LE. 0.0, and the\n  BESK0 entry returns the value 0.0 for ARG .GT. XMAX. Intrinsic functions required are: EXP , LOG , SQRT Latest modification: March 19, 1990 Authors: W. J. Cody and Laura Stoltz\n           Mathematics and Computer Science Division\n           Argonne National Laboratory\n           Argonne, IL 60439 Arguments Type Intent Optional Attributes Name double precision :: ARG double precision :: RESULT integer :: JINT Called by proc~~calck0~~CalledByGraph proc~calck0 CALCK0 proc~besk0 BESK0 proc~besk0->proc~calck0 proc~besek0 BESEK0 proc~besek0->proc~calck0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calck0.html"},{"title":"BESK1 – RPN calculator in Fortran","text":"public function BESK1(X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Calls proc~~besk1~~CallsGraph proc~besk1 BESK1 proc~calck1 CALCK1 proc~besk1->proc~calck1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/besk1.html"},{"title":"BESEK1 – RPN calculator in Fortran","text":"private function BESEK1(X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Calls proc~~besek1~~CallsGraph proc~besek1 BESEK1 proc~calck1 CALCK1 proc~besek1->proc~calck1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/besek1.html"},{"title":"CALCK1 – RPN calculator in Fortran","text":"private subroutine CALCK1(ARG, RESULT, JINT) Explanation of machine-dependent constants beta   = Radix for the floating-point system\n   minexp = Smallest representable power of beta\n   maxexp = Smallest power of beta that overflows\n   XLEAST = Smallest acceptable argument, i.e., smallest machine\n            number X such that 1/X is machine representable.\n   XSMALL = Argument below which BESK1(X) and BESEK1(X) may\n            each be represented by 1/X.  A safe value is the\n            largest X such that  1.0 + X = 1.0  to machine\n            precision.\n   XINF   = Largest positive machine number; approximately\n            beta maxexp\n   XMAX   = Largest argument acceptable to BESK1;  Solution to\n            equation: W(X) * (1+3/8X-15/128X 2) = beta* minexp\n            where  W(X) = EXP(-X) SQRT(PI/2X) Approximate values for some important machines are : beta minexp maxexp CRAY-1        (S.P.)       2        -8193         8191\n  Cyber 180/185 \n    under NOS   (S.P.)       2         -975         1070\n  IEEE (IBM/XT,\n    SUN, etc.)  (S.P.)       2         -126          128\n  IEEE (IBM/XT,\n    SUN, etc.)  (D.P.)       2        -1022         1024\n  IBM 3033      (D.P.)      16          -65           63\n  VAX D-Format  (D.P.)       2         -128          127\n  VAX G-Format  (D.P.)       2        -1024         1023 XLEAST XSMALL XINF XMAX CRAY-1                1.84E-2466  3.55E-15  5.45E+2465  5674.858 \n Cyber 180/855\n   under NOS   (S.P.)  3.14E-294   1.77E-15  1.26E+322    672.789\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)  1.18E-38    5.95E-8   3.40E+38      85.343\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)  2.23D-308   1.11D-16  1.79D+308    705.343\n IBM 3033      (D.P.)  1.39D-76    1.11D-16  7.23D+75     177.855\n VAX D-Format  (D.P.)  5.88D-39    6.95D-18  1.70D+38      86.721\n VAX G-Format  (D.P.)  1.12D-308   5.55D-17  8.98D+307    706.728 Error returns The program returns the value XINF for ARG .LE. 0.0 and the\n   BESK1 entry returns the value 0.0 for ARG .GT. XMAX. Intrinsic functions required are: LOG , SQRT , EXP Authors: W. J. Cody and Laura Stoltz\n           Mathematics and Computer Science Division\n           Argonne National Laboratory\n           Argonne, IL 60439 Latest modification: January 28, 1988 Arguments Type Intent Optional Attributes Name double precision :: ARG double precision :: RESULT integer :: JINT Called by proc~~calck1~~CalledByGraph proc~calck1 CALCK1 proc~besk1 BESK1 proc~besk1->proc~calck1 proc~besek1 BESEK1 proc~besek1->proc~calck1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/calck1.html"},{"title":"ISDIGIT – RPN calculator in Fortran","text":"public elemental function ISDIGIT(CH) Arguments Type Intent Optional Attributes Name character, intent(in) :: CH Return Value logical Called by proc~~isdigit~~CalledByGraph proc~isdigit ISDIGIT proc~isreal ISREAL proc~isreal->proc~isdigit proc~isrational ISRATIONAL proc~isrational->proc~isdigit proc~iscomplex ISCOMPLEX proc~iscomplex->proc~isdigit Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/isdigit.html"},{"title":"ISPM – RPN calculator in Fortran","text":"public elemental function ISPM(CH) Arguments Type Intent Optional Attributes Name character, intent(in) :: CH Return Value logical Called by proc~~ispm~~CalledByGraph proc~ispm ISPM proc~isreal ISREAL proc~isreal->proc~ispm proc~isrational ISRATIONAL proc~isrational->proc~ispm proc~iscomplex ISCOMPLEX proc~iscomplex->proc~ispm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ispm.html"},{"title":"ISHEX – RPN calculator in Fortran","text":"public elemental function ISHEX(CH) Arguments Type Intent Optional Attributes Name character, intent(in) :: CH Return Value logical Called by proc~~ishex~~CalledByGraph proc~ishex ISHEX proc~isreal ISREAL proc~isreal->proc~ishex proc~isrational ISRATIONAL proc~isrational->proc~ishex proc~iscomplex ISCOMPLEX proc~iscomplex->proc~ishex Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ishex.html"},{"title":"ISREAL – RPN calculator in Fortran","text":"public function ISREAL(STR, X) result(NUM_FLAG) Uses GLOBAL proc~~isreal~~UsesGraph proc~isreal ISREAL module~global GLOBAL proc~isreal->module~global assert assert module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: STR real(kind=wp), intent(out) :: X Return Value logical Calls proc~~isreal~~CallsGraph proc~isreal ISREAL proc~ishex ISHEX proc~isreal->proc~ishex proc~isdigit ISDIGIT proc~isreal->proc~isdigit proc~ispm ISPM proc~isreal->proc~ispm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/isreal.html"},{"title":"ISCOMPLEX – RPN calculator in Fortran","text":"public function ISCOMPLEX(STR, X) result(NUM_FLAG) Uses GLOBAL proc~~iscomplex~~UsesGraph proc~iscomplex ISCOMPLEX module~global GLOBAL proc~iscomplex->module~global assert assert module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: STR complex(kind=wp), intent(out) :: X Return Value logical Calls proc~~iscomplex~~CallsGraph proc~iscomplex ISCOMPLEX proc~ishex ISHEX proc~iscomplex->proc~ishex proc~isdigit ISDIGIT proc~iscomplex->proc~isdigit proc~ispm ISPM proc~iscomplex->proc~ispm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/iscomplex.html"},{"title":"ISRATIONAL – RPN calculator in Fortran","text":"public function ISRATIONAL(STR, NUM, DEN) result(NUM_FLAG) Uses GLOBAL proc~~isrational~~UsesGraph proc~isrational ISRATIONAL module~global GLOBAL proc~isrational->module~global assert assert module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: STR integer, intent(out) :: NUM integer, intent(out) :: DEN Return Value logical Calls proc~~isrational~~CallsGraph proc~isrational ISRATIONAL proc~ishex ISHEX proc~isrational->proc~ishex proc~ratnorm RATNORM proc~isrational->proc~ratnorm proc~isdigit ISDIGIT proc~isrational->proc~isdigit proc~ispm ISPM proc~isrational->proc~ispm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/isrational.html"},{"title":"ISFRAC – RPN calculator in Fortran","text":"public elemental function ISFRAC(X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value logical Contents None","tags":"","loc":"proc/isfrac.html"},{"title":"ISINT – RPN calculator in Fortran","text":"public elemental function ISINT(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value logical Contents None","tags":"","loc":"proc/isint.html"},{"title":"GCD – RPN calculator in Fortran","text":"public elemental function GCD(A, B) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A integer, intent(in) :: B Return Value integer Called by proc~~gcd~~CalledByGraph proc~gcd GCD proc~lcm LCM proc~lcm->proc~gcd proc~ratnorm RATNORM proc~ratnorm->proc~gcd proc~rmod RMOD proc~rmod->proc~ratnorm proc~rdiv RDIV proc~rmod->proc~rdiv proc~rsub RSUB proc~rmod->proc~rsub proc~rint RINT proc~rmod->proc~rint proc~rmul RMUL proc~rmod->proc~rmul proc~rdiv->proc~ratnorm proc~isrational ISRATIONAL proc~isrational->proc~ratnorm proc~rnint RNINT proc~rnint->proc~ratnorm proc~rnint->proc~rsub proc~radd RADD proc~rnint->proc~radd proc~rsub->proc~ratnorm proc~frac_to_mixed FRAC_TO_MIXED proc~frac_to_mixed->proc~ratnorm proc~rint->proc~ratnorm proc~radd->proc~ratnorm proc~rmul->proc~ratnorm proc~rbeta RBETA proc~rbeta->proc~ratnorm proc~rfrac RFRAC proc~rfrac->proc~ratnorm proc~rfrac->proc~rsub proc~rfrac->proc~rint proc~eval EVAL proc~eval->proc~rmod proc~eval->proc~rnint proc~eval->proc~rint proc~eval->proc~rfrac proc~eval->proc~eval proc~rlinreg RLINREG proc~rlinreg->proc~rdiv proc~rlinreg->proc~rsub proc~rlinreg->proc~rmul program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gcd.html"},{"title":"LCM – RPN calculator in Fortran","text":"public elemental function LCM(A, B) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A integer, intent(in) :: B Return Value integer Calls proc~~lcm~~CallsGraph proc~lcm LCM proc~gcd GCD proc~lcm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lcm.html"},{"title":"SWITCH_RAT_TO_REAL – RPN calculator in Fortran","text":"public subroutine SWITCH_RAT_TO_REAL() Uses GLOBAL proc~~switch_rat_to_real~~UsesGraph proc~switch_rat_to_real SWITCH_RAT_TO_REAL module~global GLOBAL proc~switch_rat_to_real->module~global assert assert module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Called by proc~~switch_rat_to_real~~CalledByGraph proc~switch_rat_to_real SWITCH_RAT_TO_REAL proc~hasin hasin proc~hasin->proc~switch_rat_to_real proc~hatan hatan proc~hatan->proc~switch_rat_to_real proc~hacos hacos proc~hacos->proc~switch_rat_to_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/switch_rat_to_real.html"},{"title":"FRAC_TO_MIXED – RPN calculator in Fortran","text":"public elemental subroutine FRAC_TO_MIXED(AN, AD, A1, A2, A3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: AN integer, intent(in) :: AD integer, intent(out) :: A1 integer, intent(out) :: A2 integer, intent(out) :: A3 Calls proc~~frac_to_mixed~~CallsGraph proc~frac_to_mixed FRAC_TO_MIXED proc~ratnorm RATNORM proc~frac_to_mixed->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/frac_to_mixed.html"},{"title":"RATNORM – RPN calculator in Fortran","text":"public elemental subroutine RATNORM(NUM, DEN) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: NUM integer, intent(inout) :: DEN Calls proc~~ratnorm~~CallsGraph proc~ratnorm RATNORM proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ratnorm~~CalledByGraph proc~ratnorm RATNORM proc~rmod RMOD proc~rmod->proc~ratnorm proc~rdiv RDIV proc~rmod->proc~rdiv proc~rsub RSUB proc~rmod->proc~rsub proc~rint RINT proc~rmod->proc~rint proc~rmul RMUL proc~rmod->proc~rmul proc~rdiv->proc~ratnorm proc~isrational ISRATIONAL proc~isrational->proc~ratnorm proc~rnint RNINT proc~rnint->proc~ratnorm proc~rnint->proc~rsub proc~radd RADD proc~rnint->proc~radd proc~rsub->proc~ratnorm proc~frac_to_mixed FRAC_TO_MIXED proc~frac_to_mixed->proc~ratnorm proc~rint->proc~ratnorm proc~radd->proc~ratnorm proc~rmul->proc~ratnorm proc~rbeta RBETA proc~rbeta->proc~ratnorm proc~rfrac RFRAC proc~rfrac->proc~ratnorm proc~rfrac->proc~rsub proc~rfrac->proc~rint proc~eval EVAL proc~eval->proc~rmod proc~eval->proc~rnint proc~eval->proc~rint proc~eval->proc~rfrac proc~eval->proc~eval proc~rlinreg RLINREG proc~rlinreg->proc~rdiv proc~rlinreg->proc~rsub proc~rlinreg->proc~rmul program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ratnorm.html"},{"title":"RADD – RPN calculator in Fortran","text":"public elemental subroutine RADD(N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR Calls proc~~radd~~CallsGraph proc~radd RADD proc~ratnorm RATNORM proc~radd->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~radd~~CalledByGraph proc~radd RADD proc~rnint RNINT proc~rnint->proc~radd proc~eval EVAL proc~eval->proc~rnint proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/radd.html"},{"title":"RSUB – RPN calculator in Fortran","text":"public elemental subroutine RSUB(N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR Calls proc~~rsub~~CallsGraph proc~rsub RSUB proc~ratnorm RATNORM proc~rsub->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rsub~~CalledByGraph proc~rsub RSUB proc~rmod RMOD proc~rmod->proc~rsub proc~rnint RNINT proc~rnint->proc~rsub proc~rlinreg RLINREG proc~rlinreg->proc~rsub proc~rfrac RFRAC proc~rfrac->proc~rsub proc~eval EVAL proc~eval->proc~rmod proc~eval->proc~rnint proc~eval->proc~rfrac proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rsub.html"},{"title":"RMUL – RPN calculator in Fortran","text":"public elemental subroutine RMUL(N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR Calls proc~~rmul~~CallsGraph proc~rmul RMUL proc~ratnorm RATNORM proc~rmul->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rmul~~CalledByGraph proc~rmul RMUL proc~rmod RMOD proc~rmod->proc~rmul proc~rlinreg RLINREG proc~rlinreg->proc~rmul proc~eval EVAL proc~eval->proc~rmod proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rmul.html"},{"title":"RDIV – RPN calculator in Fortran","text":"public elemental subroutine RDIV(N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR Calls proc~~rdiv~~CallsGraph proc~rdiv RDIV proc~ratnorm RATNORM proc~rdiv->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rdiv~~CalledByGraph proc~rdiv RDIV proc~rmod RMOD proc~rmod->proc~rdiv proc~rlinreg RLINREG proc~rlinreg->proc~rdiv proc~eval EVAL proc~eval->proc~rmod proc~eval->proc~eval program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rdiv.html"},{"title":"DEC_TO_FRAC – RPN calculator in Fortran","text":"public subroutine DEC_TO_FRAC(X, NUM, DEN, TOL) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X integer, intent(out) :: NUM integer, intent(out) :: DEN real(kind=wp), intent(in), optional :: TOL Calls proc~~dec_to_frac~~CallsGraph proc~dec_to_frac DEC_TO_FRAC isclose isclose proc~dec_to_frac->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dec_to_frac.html"},{"title":"init_stack – RPN calculator in Fortran","text":"public subroutine init_stack() Arguments None Called by proc~~init_stack~~CalledByGraph proc~init_stack init_stack program~rpn RPN program~rpn->proc~init_stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/init_stack.html"},{"title":"RIBESL – RPN calculator in Fortran","text":"public subroutine RIBESL(X, ALPHA, NB, IZE, B, NCALC) Explanation of machine-dependent constants beta   = Radix for the floating-point system\n   minexp = Smallest representable power of beta\n   maxexp = Smallest power of beta that overflows\n   it     = Number of bits in the mantissa of a working precision\n            variable\n   NSIG   = Decimal significance desired.  Should be set to\n            INT(LOG10(2) it+1).  Setting NSIG lower will result\n            in decreased accuracy while setting NSIG higher will\n            increase CPU time without increasing accuracy.  The\n            truncation error is limited to a relative error of\n            T=.5 10 (-NSIG).\n   ENTEN  = 10.0 K, where K is the largest integer such that\n            ENTEN is machine-representable in working precision\n   ENSIG  = 10.0 NSIG\n   RTNSIG = 10.0 (-K) for the smallest integer K such that\n            K .GE. NSIG/4\n   ENMTEN = Smallest ABS(X) such that X/4 does not underflow\n   XLARGE = Upper limit on the magnitude of X when IZE=2.  Bear\n            in mind that if ABS(X)=N, then at least N iterations\n            of the backward recursion will be executed.  The value\n            of 10.0 4 is used on every machine.\n   EXPARG = Largest working precision argument that the library\n            EXP routine can handle and upper limit on the\n            magnitude of X when IZE=1; approximately\n            LOG(beta maxexp) Approximate values for some important machines are : beta minexp maxexp it CRAY-1        (S.P.)    2        -8193        8191        48\n  Cyber 180/855\n    under NOS   (S.P.)    2         -975        1070        48\n  IEEE (IBM/XT,\n    SUN, etc.)  (S.P.)    2         -126         128        24\n  IEEE (IBM/XT,\n    SUN, etc.)  (D.P.)    2        -1022        1024        53\n  IBM 3033      (D.P.)   16          -65          63        14\n  VAX           (S.P.)    2         -128         127        24\n  VAX D-Format  (D.P.)    2         -128         127        56\n  VAX G-Format  (D.P.)    2        -1024        1023        53 NSIG ENTEN ENSIG RTNSIG CRAY-1        (S.P.)    15       1.0E+2465   1.0E+15     1.0E-4\n Cyber 180/855\n   under NOS   (S.P.)    15       1.0E+322    1.0E+15     1.0E-4\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)     8       1.0E+38     1.0E+8      1.0E-2\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)    16       1.0D+308    1.0D+16     1.0D-4\n IBM 3033      (D.P.)     5       1.0D+75     1.0D+5      1.0D-2\n VAX           (S.P.)     8       1.0E+38     1.0E+8      1.0E-2\n VAX D-Format  (D.P.)    17       1.0D+38     1.0D+17     1.0D-5\n VAX G-Format  (D.P.)    16       1.0D+307    1.0D+16     1.0D-4 ENMTEN XLARGE EXPARG CRAY-1        (S.P.)   1.84E-2466   1.0E+4    5677\n Cyber 180/855\n   under NOS   (S.P.)   1.25E-293    1.0E+4     741\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)   4.70E-38     1.0E+4      88\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)   8.90D-308    1.0D+4     709\n IBM 3033      (D.P.)   2.16D-78     1.0D+4     174\n VAX           (S.P.)   1.17E-38     1.0E+4      88\n VAX D-Format  (D.P.)   1.17D-38     1.0D+4      88\n VAX G-Format  (D.P.)   2.22D-308    1.0D+4     709 Error returns In case of an error,  NCALC .NE. NB, and not all I's are\n  calculated to the desired accuracy. NCALC .LT. 0:  An argument is out of range. For example,\n     NB .LE. 0, IZE is not 1 or 2, or IZE=1 and ABS(X) .GE. EXPARG.\n     In this case, the B-vector is not calculated, and NCALC is\n     set to MIN0(NB,0)-1 so that NCALC .NE. NB. NB .GT. NCALC .GT. 0: Not all requested function values could\n     be calculated accurately.  This usually occurs because NB is\n     much larger than ABS(X).  In this case, B(N) is calculated\n     to the desired accuracy for N .LE. NCALC, but precision\n     is lost for NCALC .LT. N .LE. NB.  If B(N) does not vanish\n     for N .GT. NCALC (because it is too small to be represented),\n     and B(N)/B(NCALC) = 10**(-K), then only the first NSIG-K\n     significant figures of B(N) can be trusted. Intrinsic functions required are: DBLE , EXP , DGAMMA , GAMMA , INT , MAX , MIN , REAL , SQRT Acknowledgement This program is based on a program written by David J.\n  Sookne (2) that computes values of the Bessel functions J or\n  I of real argument and integer order.  Modifications include\n  the restriction of the computation to the I Bessel function\n  of non-negative real argument, the extension of the computation\n  to arbitrary positive order, the inclusion of optional\n  exponential scaling, and the elimination of most underflow.\n  An earlier version was published in (3). References: \"A Note on Backward Recurrence Algorithms,\" Olver,\n              F. W. J., and Sookne, D. J., Math. Comp. 26, 1972,\n              pp 941-947. \"Bessel Functions of Real Argument and Integer Order,\" Sookne , D . J ., NBS Jour . of Res . B . 77 B , 1973 , pp 125 - 132 . \"ALGORITHM 597, Sequence of Modified Bessel Functions of the First Kind,\" Cody , W . J ., Trans . Math . Soft ., 1983 , pp . 242 - 245 . Latest modification: May 30, 1989 Modified by: W. J. Cody and L. Stoltz\n               Applied Mathematics Division\n               Argonne National Laboratory\n               Argonne, IL  60439 Arguments Type Intent Optional Attributes Name double precision :: X double precision :: ALPHA integer, intent(in) :: NB integer :: IZE double precision, intent(out) :: B (NB) integer, intent(out) :: NCALC Contents None","tags":"","loc":"proc/ribesl.html"},{"title":"RJBESL – RPN calculator in Fortran","text":"public subroutine RJBESL(X, ALPHA, NB, B, NCALC) Explanation of machine-dependent constants it     = Number of bits in the mantissa of a working precision\n            variable\n   NSIG   = Decimal significance desired.  Should be set to\n            INT(LOG10(2) it+1).  Setting NSIG lower will result\n            in decreased accuracy while setting NSIG higher will\n            increase CPU time without increasing accuracy.  The\n            truncation error is limited to a relative error of\n            T=.5 10 (-NSIG).\n   ENTEN  = 10.0 K, where K is the largest integer such that\n            ENTEN is machine-representable in working precision\n   ENSIG  = 10.0 NSIG\n   RTNSIG = 10.0 (-K) for the smallest integer K such that\n            K .GE. NSIG/4\n   ENMTEN = Smallest ABS(X) such that X/4 does not underflow\n   XLARGE = Upper limit on the magnitude of X.  If ABS(X)=N,\n            then at least N iterations of the backward recursion\n            will be executed.  The value of 10.0 ** 4 is used on\n            every machine. Approximate values for some important machines are : it NSIG ENTEN ENSIG CRAY-1        (S.P.)     48     15    1.0E+2465   1.0E+15\n   Cyber 180/855\n     under NOS   (S.P.)     48     15    1.0E+322    1.0E+15\n   IEEE (IBM/XT,\n     SUN, etc.)  (S.P.)     24      8    1.0E+38     1.0E+8\n   IEEE (IBM/XT,\n     SUN, etc.)  (D.P.)     53     16    1.0D+308    1.0D+16\n   IBM 3033      (D.P.)     14      5    1.0D+75     1.0D+5\n   VAX           (S.P.)     24      8    1.0E+38     1.0E+8\n   VAX D-Format  (D.P.)     56     17    1.0D+38     1.0D+17\n   VAX G-Format  (D.P.)     53     16    1.0D+307    1.0D+16 RTNSIG ENMTEN XLARGE CRAY-1        (S.P.)    1.0E-4    1.84E-2466   1.0E+4\n   Cyber 180/855\n     under NOS   (S.P.)    1.0E-4    1.25E-293    1.0E+4\n   IEEE (IBM/XT,\n     SUN, etc.)  (S.P.)    1.0E-2    4.70E-38     1.0E+4\n   IEEE (IBM/XT,\n     SUN, etc.)  (D.P.)    1.0E-4    8.90D-308    1.0D+4\n   IBM 3033      (D.P.)    1.0E-2    2.16D-78     1.0D+4\n   VAX           (S.P.)    1.0E-2    1.17E-38     1.0E+4\n   VAX D-Format  (D.P.)    1.0E-5    1.17D-38     1.0D+4\n   VAX G-Format  (D.P.)    1.0E-4    2.22D-308    1.0D+4 Error returns In case of an error , NCALC . NE . NB , and not all J ' s are calculated to the desired accuracy . NCALC . LT . 0 : An argument is out of range . For example , NBES . LE . 0 , ALPHA . LT . 0 or . GT . 1 , or X is too large . In this case , B ( 1 ) is set to zero , the remainder of the B - vector is not calculated , and NCALC is set to MIN ( NB , 0 ) - 1 so that NCALC . NE . NB . NB . GT . NCALC . GT . 0 : Not all requested function values could be calculated accurately . This usually occurs because NB is much larger than ABS ( X ) . In this case , B ( N ) is calculated to the desired accuracy for N . LE . NCALC , but precision is lost for NCALC . LT . N . LE . NB . If B ( N ) does not vanish for N . GT . NCALC ( because it is too small to be represented ) , and B ( N ) / B ( NCALC ) = 10 ** ( - K ) , then only the first NSIG - K significant figures of B ( N ) can be trusted . Intrinsic and other functions required are: ABS , AINT , COS , DBLE , GAMMA ( or DGAMMA ), INT , MAX , MIN , REAL , SIN , SQRT Acknowledgement This program is based on a program written by David J. Sookne\n   (2) that computes values of the Bessel functions J or I of real\n   argument and integer order.  Modifications include the restriction\n   of the computation to the J Bessel function of non-negative real\n   argument, the extension of the computation to arbitrary positive\n   order, and the elimination of most underflow. References: \"A Note on Backward Recurrence Algorithms,\" Olver,\n               F. W. J., and Sookne, D. J., Math. Comp. 26, 1972,\n               pp 941-947. \"Bessel Functions of Real Argument and Integer Order,\" Sookne , D . J ., NBS Jour . of Res . B . 77 B , 1973 , pp 125 - 132 . Latest modification: March 19, 1990 Author: W. J. Cody\n          Applied Mathematics Division\n          Argonne National Laboratory\n          Argonne, IL  60439 Arguments Type Intent Optional Attributes Name double precision :: X double precision :: ALPHA integer :: NB double precision :: B integer :: NCALC Contents None","tags":"","loc":"proc/rjbesl.html"},{"title":"RKBESL – RPN calculator in Fortran","text":"public subroutine RKBESL(X, ALPHA, NB, IZE, BK, NCALC) Explanation of machine-dependent constants beta   = Radix for the floating-point system\n   minexp = Smallest representable power of beta\n   maxexp = Smallest power of beta that overflows\n   EPS    = The smallest positive floating-point number such that \n            1.0+EPS .GT. 1.0\n   XMAX   = Upper limit on the magnitude of X when IZE=1;  Solution \n            to equation:\n               W(X) * (1-1/8X+9/128X 2) = beta minexp\n            where  W(X) = EXP(-X) SQRT(PI/2X)\n   SQXMIN = Square root of beta minexp\n   XINF   = Largest positive machine number; approximately\n            beta maxexp\n   XMIN   = Smallest positive machine number; approximately\n            beta *minexp Approximate values for some important machines are : beta minexp maxexp EPS CRAY-1        (S.P.)      2        -8193        8191    7.11E-15\n  Cyber 180/185 \n    under NOS   (S.P.)      2         -975        1070    3.55E-15\n  IEEE (IBM/XT,\n    SUN, etc.)  (S.P.)      2         -126         128    1.19E-7\n  IEEE (IBM/XT,\n    SUN, etc.)  (D.P.)      2        -1022        1024    2.22D-16\n  IBM 3033      (D.P.)     16          -65          63    2.22D-16\n  VAX           (S.P.)      2         -128         127    5.96E-8\n  VAX D-Format  (D.P.)      2         -128         127    1.39D-17\n  VAX G-Format  (D.P.)      2        -1024        1023    1.11D-16 SQXMIN XINF XMIN XMAX CRAY-1        (S.P.)  6.77E-1234  5.45E+2465  4.59E-2467 5674.858\n Cyber 180/855\n   under NOS   (S.P.)  1.77E-147   1.26E+322   3.14E-294   672.788\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)  1.08E-19    3.40E+38    1.18E-38     85.337\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)  1.49D-154   1.79D+308   2.23D-308   705.342\n IBM 3033      (D.P.)  7.35D-40    7.23D+75    5.40D-79    177.852\n VAX           (S.P.)  5.42E-20    1.70E+38    2.94E-39     86.715\n VAX D-Format  (D.P.)  5.42D-20    1.70D+38    2.94D-39     86.715\n VAX G-Format  (D.P.)  7.46D-155   8.98D+307   5.57D-309   706.728 Error returns In case of an error, NCALC .NE. NB, and not all K's are\n  calculated to the desired accuracy. NCALC .LT. -1:  An argument is out of range. For example,\n       NB .LE. 0, IZE is not 1 or 2, or IZE=1 and ABS(X) .GE.\n       XMAX.  In this case, the B-vector is not calculated,\n       and NCALC is set to MIN0(NB,0)-2  so that NCALC .NE. NB.\n  NCALC = -1:  Either  K(ALPHA,X) .GE. XINF  or\n       K(ALPHA+NB-1,X)/K(ALPHA+NB-2,X) .GE. XINF.  In this case,\n       the B-vector is not calculated.  Note that again \n       NCALC .NE. NB. 0 .LT. NCALC .LT. NB: Not all requested function values could\n       be calculated accurately.  BK(I) contains correct function\n       values for I .LE. NCALC, and contains the ratios\n       K(ALPHA+I-1,X)/K(ALPHA+I-2,X) for the rest of the array. Intrinsic functions required are: ABS , AINT , EXP , INT , LOG , MAX , MIN , SINH , SQRT Acknowledgement This program is based on a program written by J. B. Campbell\n  (2) that computes values of the Bessel functions K of real\n  argument and real order.  Modifications include the addition\n  of non-scaled functions, parameterization of machine\n  dependencies, and the use of more accurate approximations\n  for SINH and SIN. References: \"On Temme's Algorithm for the Modified Bessel\n              Functions of the Third Kind,\" Campbell, J. B.,\n              TOMS 6(4), Dec. 1980, pp. 581-586. \" A FORTRAN IV Subroutine for the Modified Bessel Functions of the Third Kind of Real Order and Real Argument , \" Campbell, J. B., Report NRC/ERB-925, National Research Council , Canada . Latest modification: May 30, 1989 Modified by: W. J. Cody and L. Stoltz\n               Applied Mathematics Division\n               Argonne National Laboratory\n               Argonne, IL  60439 Arguments Type Intent Optional Attributes Name double precision :: X double precision :: ALPHA integer :: NB integer :: IZE double precision :: BK integer :: NCALC Contents None","tags":"","loc":"proc/rkbesl.html"},{"title":"RYBESL – RPN calculator in Fortran","text":"public subroutine RYBESL(X, ALPHA, NB, BY, NCALC) Explanation of machine-dependent constants beta   = Radix for the floating-point system\n   p      = Number of significant base-beta digits in the\n            significand of a floating-point number\n   minexp = Smallest representable power of beta\n   maxexp = Smallest power of beta that overflows\n   EPS    = beta (-p)\n   DEL    = Machine number below which sin(x)/x = 1; approximately\n            SQRT(EPS).\n   XMIN   = Smallest acceptable argument for RBESY; approximately\n            max(2*beta minexp,2/XINF), rounded up\n   XINF   = Largest positive machine number; approximately\n            beta**maxexp\n   THRESH = Lower bound for use of the asymptotic form; approximately\n            AINT(-LOG10(EPS/2.0))+1.0\n   XLARGE = Upper bound on X; approximately 1/DEL, because the sine\n            and cosine functions have lost about half of their \n            precision at that point. Approximate values for some important machines are : beta p minexp maxexp EPS CRAY-1        (S.P.)    2    48     -8193        8191    3.55E-15\n  Cyber 180/185 \n    under NOS   (S.P.)    2    48      -975        1070    3.55E-15\n  IEEE (IBM/XT,\n    SUN, etc.)  (S.P.)    2    24      -126         128    5.96E-8\n  IEEE (IBM/XT,\n    SUN, etc.)  (D.P.)    2    53     -1022        1024    1.11D-16\n  IBM 3033      (D.P.)   16    14       -65          63    1.39D-17\n  VAX           (S.P.)    2    24      -128         127    5.96E-8\n  VAX D-Format  (D.P.)    2    56      -128         127    1.39D-17\n  VAX G-Format  (D.P.)    2    53     -1024        1023    1.11D-16 DEL XMIN XINF THRESH XLARGE CRAY-1        (S.P.)  5.0E-8  3.67E-2466 5.45E+2465  15.0E0  2.0E7\n Cyber 180/855\n   under NOS   (S.P.)  5.0E-8  6.28E-294  1.26E+322   15.0E0  2.0E7\n IEEE (IBM/XT,\n   SUN, etc.)  (S.P.)  1.0E-4  2.36E-38   3.40E+38     8.0E0  1.0E4\n IEEE (IBM/XT,\n   SUN, etc.)  (D.P.)  1.0D-8  4.46D-308  1.79D+308   16.0D0  1.0D8\n IBM 3033      (D.P.)  1.0D-8  2.77D-76   7.23D+75    17.0D0  1.0D8\n VAX           (S.P.)  1.0E-4  1.18E-38   1.70E+38     8.0E0  1.0E4\n VAX D-Format  (D.P.)  1.0D-9  1.18D-38   1.70D+38    17.0D0  1.0D9\n VAX G-Format  (D.P.)  1.0D-8  2.23D-308  8.98D+307   16.0D0  1.0D8 Error returns In case of an error, NCALC .NE. NB, and not all Y's are\n  calculated to the desired accuracy. NCALC .LT. -1:  An argument is out of range. For example,\n       NB .LE. 0, IZE is not 1 or 2, or IZE=1 and ABS(X) .GE.\n       XMAX.  In this case, BY(1) = 0.0, the remainder of the\n       BY-vector is not calculated, and NCALC is set to\n       MIN0(NB,0)-2  so that NCALC .NE. NB.\n  NCALC = -1:  Y(ALPHA,X) .GE. XINF.  The requested function\n       values are set to 0.0.\n  1 .LT. NCALC .LT. NB: Not all requested function values could\n       be calculated accurately.  BY(I) contains correct function\n       values for I .LE. NCALC, and and the remaining NB-NCALC\n       array elements contain 0.0. Intrinsic functions required are: DBLE , EXP , INT , MAX , MIN , REAL , SQRT Acknowledgement This program draws heavily on Temme's Algol program for Y(a,x)\n  and Y(a+1,x) and on Campbell's programs for Y_nu(x).  Temme's\n  scheme is used for  x < THRESH, and Campbell's scheme is used\n  in the asymptotic region.  Segments of code from both sources\n  have been translated into Fortran 77, merged, and heavily modified.\n  Modifications include parameterization of machine dependencies,\n  use of a new approximation for ln(gamma(x)), and built-in\n  protection against over/underflow. References: \"Bessel functions J_nu(x) and Y_nu(x) of real\n              order and real argument,\" Campbell, J. B.,\n              Comp. Phy. Comm. 18, 1979, pp. 133-142. \"On the numerical evaluation of the ordinary Bessel function of the second kind,\" Temme , N . M ., J . Comput . Phys . 21 , 1976 , pp . 343 - 350 . Latest modification: March 19, 1990 Modified by: W. J. Cody\n               Applied Mathematics Division\n               Argonne National Laboratory\n               Argonne, IL  60439 Arguments Type Intent Optional Attributes Name double precision :: X double precision :: ALPHA integer :: NB double precision :: BY integer :: NCALC Contents None","tags":"","loc":"proc/rybesl.html"},{"title":"CNR – RPN calculator in Fortran","text":"public elemental function CNR(N, R) result(Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: R Return Value real(kind=wp) Contents None","tags":"","loc":"proc/cnr.html"},{"title":"PNR – RPN calculator in Fortran","text":"public elemental function PNR(N, R) result(Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: R Return Value real(kind=wp) Contents None","tags":"","loc":"proc/pnr.html"},{"title":"LINREG – RPN calculator in Fortran","text":"public elemental subroutine LINREG(M, B, R) Uses GLOBAL proc~~linreg~~UsesGraph proc~linreg LINREG module~global GLOBAL proc~linreg->module~global assert assert module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: M real(kind=wp), intent(out) :: B real(kind=wp), intent(out) :: R Contents None","tags":"","loc":"proc/linreg.html"},{"title":"CLINREG – RPN calculator in Fortran","text":"public elemental subroutine CLINREG(M, B, R) Uses GLOBAL proc~~clinreg~~UsesGraph proc~clinreg CLINREG module~global GLOBAL proc~clinreg->module~global assert assert module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(out) :: M complex(kind=wp), intent(out) :: B complex(kind=wp), intent(out) :: R Contents None","tags":"","loc":"proc/clinreg.html"},{"title":"RLINREG – RPN calculator in Fortran","text":"public elemental subroutine RLINREG(NM, DM, NB, DB, R) Uses rat GLOBAL proc~~rlinreg~~UsesGraph proc~rlinreg RLINREG module~rat rat proc~rlinreg->module~rat module~global GLOBAL proc~rlinreg->module~global iso_fortran_env iso_fortran_env module~rat->iso_fortran_env assert assert module~rat->assert module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(out) :: NM integer, intent(out) :: DM integer, intent(out) :: NB integer, intent(out) :: DB real(kind=wp), intent(out) :: R Calls proc~~rlinreg~~CallsGraph proc~rlinreg RLINREG proc~rsub RSUB proc~rlinreg->proc~rsub proc~rmul RMUL proc~rlinreg->proc~rmul proc~rdiv RDIV proc~rlinreg->proc~rdiv proc~ratnorm RATNORM proc~rsub->proc~ratnorm proc~rmul->proc~ratnorm proc~rdiv->proc~ratnorm proc~gcd GCD proc~ratnorm->proc~gcd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rlinreg.html"},{"title":"SEC_r – RPN calculator in Fortran","text":"public elemental function SEC_r(X) result(sec) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~sec_r~~CalledByGraph proc~sec_r SEC_r interface~sec sec interface~sec->proc~sec_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sec_r.html"},{"title":"SEC_c – RPN calculator in Fortran","text":"public elemental function SEC_c(Z) result(sec) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~sec_c~~CalledByGraph proc~sec_c SEC_c interface~sec sec interface~sec->proc~sec_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sec_c.html"},{"title":"ASEC_r – RPN calculator in Fortran","text":"public elemental function ASEC_r(Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Called by proc~~asec_r~~CalledByGraph proc~asec_r ASEC_r interface~asec asec interface~asec->proc~asec_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/asec_r.html"},{"title":"ASEC_c – RPN calculator in Fortran","text":"public elemental function ASEC_c(Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~asec_c~~CalledByGraph proc~asec_c ASEC_c interface~asec asec interface~asec->proc~asec_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/asec_c.html"},{"title":"CSC_r – RPN calculator in Fortran","text":"public elemental function CSC_r(X) result(csc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~csc_r~~CalledByGraph proc~csc_r CSC_r interface~csc csc interface~csc->proc~csc_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/csc_r.html"},{"title":"CSC_c – RPN calculator in Fortran","text":"public elemental function CSC_c(Z) result(csc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~csc_c~~CalledByGraph proc~csc_c CSC_c interface~csc csc interface~csc->proc~csc_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/csc_c.html"},{"title":"ACSC_r – RPN calculator in Fortran","text":"public elemental function ACSC_r(Y) result(acsc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Called by proc~~acsc_r~~CalledByGraph proc~acsc_r ACSC_r interface~acsc acsc interface~acsc->proc~acsc_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acsc_r.html"},{"title":"ACSC_c – RPN calculator in Fortran","text":"public elemental function ACSC_c(Z) result(acsc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~acsc_c~~CalledByGraph proc~acsc_c ACSC_c interface~acsc acsc interface~acsc->proc~acsc_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acsc_c.html"},{"title":"COT_r – RPN calculator in Fortran","text":"public elemental function COT_r(X) result(cot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~cot_r~~CalledByGraph proc~cot_r COT_r interface~cot cot interface~cot->proc~cot_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cot_r.html"},{"title":"COT_c – RPN calculator in Fortran","text":"public elemental function COT_c(Z) result(cot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~cot_c~~CalledByGraph proc~cot_c COT_c interface~cot cot interface~cot->proc~cot_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cot_c.html"},{"title":"ACOT_r – RPN calculator in Fortran","text":"public elemental function ACOT_r(Y) result(acot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Called by proc~~acot_r~~CalledByGraph proc~acot_r ACOT_r interface~acot acot interface~acot->proc~acot_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acot_r.html"},{"title":"ACOT_c – RPN calculator in Fortran","text":"public elemental function ACOT_c(Y) result(Acot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Called by proc~~acot_c~~CalledByGraph proc~acot_c ACOT_c interface~acot acot interface~acot->proc~acot_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/acot_c.html"},{"title":"ACOT2 – RPN calculator in Fortran","text":"public elemental function ACOT2(Y, Z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y real(kind=wp), intent(in) :: Z Return Value real(kind=wp) Contents None","tags":"","loc":"proc/acot2.html"},{"title":"EXSEC – RPN calculator in Fortran","text":"public elemental function EXSEC(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Contents None","tags":"","loc":"proc/exsec.html"},{"title":"CEXSEC – RPN calculator in Fortran","text":"public elemental function CEXSEC(Z) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Contents None","tags":"","loc":"proc/cexsec.html"},{"title":"AEXSEC – RPN calculator in Fortran","text":"public elemental function AEXSEC(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Contents None","tags":"","loc":"proc/aexsec.html"},{"title":"CAEXSEC – RPN calculator in Fortran","text":"public elemental function CAEXSEC(Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Contents None","tags":"","loc":"proc/caexsec.html"},{"title":"VERS – RPN calculator in Fortran","text":"public elemental function VERS(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Contents None","tags":"","loc":"proc/vers.html"},{"title":"CVERS – RPN calculator in Fortran","text":"public elemental function CVERS(Z) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Contents None","tags":"","loc":"proc/cvers.html"},{"title":"AVERS – RPN calculator in Fortran","text":"public elemental function AVERS(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Contents None","tags":"","loc":"proc/avers.html"},{"title":"CAVERS – RPN calculator in Fortran","text":"public elemental function CAVERS(Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Contents None","tags":"","loc":"proc/cavers.html"},{"title":"COVERS – RPN calculator in Fortran","text":"public elemental function COVERS(X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Contents None","tags":"","loc":"proc/covers.html"},{"title":"CCOVERS – RPN calculator in Fortran","text":"public function CCOVERS(Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Contents None","tags":"","loc":"proc/ccovers.html"},{"title":"ACOVERS – RPN calculator in Fortran","text":"public elemental function ACOVERS(Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Contents None","tags":"","loc":"proc/acovers.html"},{"title":"CACOVERS – RPN calculator in Fortran","text":"public elemental function CACOVERS(Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Contents None","tags":"","loc":"proc/cacovers.html"},{"title":"HAV_r – RPN calculator in Fortran","text":"public elemental function HAV_r(X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~hav_r~~CalledByGraph proc~hav_r HAV_r interface~hav hav interface~hav->proc~hav_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hav_r.html"},{"title":"HAV_c – RPN calculator in Fortran","text":"public elemental function HAV_c(Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~hav_c~~CalledByGraph proc~hav_c HAV_c interface~hav hav interface~hav->proc~hav_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hav_c.html"},{"title":"AHAV_r – RPN calculator in Fortran","text":"public elemental function AHAV_r(Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Called by proc~~ahav_r~~CalledByGraph proc~ahav_r AHAV_r interface~ahav ahav interface~ahav->proc~ahav_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ahav_r.html"},{"title":"AHAV_c – RPN calculator in Fortran","text":"public elemental function AHAV_c(Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Called by proc~~ahav_c~~CalledByGraph proc~ahav_c AHAV_c interface~ahav ahav interface~ahav->proc~ahav_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ahav_c.html"},{"title":"CRD_r – RPN calculator in Fortran","text":"public elemental function CRD_r(X) result(crd) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) Called by proc~~crd_r~~CalledByGraph proc~crd_r CRD_r interface~crd crd interface~crd->proc~crd_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/crd_r.html"},{"title":"CRD_c – RPN calculator in Fortran","text":"public elemental function CRD_c(Z) result(crd) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Called by proc~~crd_c~~CalledByGraph proc~crd_c CRD_c interface~crd crd interface~crd->proc~crd_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/crd_c.html"},{"title":"ACRD – RPN calculator in Fortran","text":"public elemental function ACRD(Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) Contents None","tags":"","loc":"proc/acrd.html"},{"title":"CACRD – RPN calculator in Fortran","text":"public elemental function CACRD(Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Contents None","tags":"","loc":"proc/cacrd.html"},{"title":"csc – RPN calculator in Fortran","text":"public interface csc Calls interface~~csc~~CallsGraph interface~csc csc proc~csc_r CSC_r interface~csc->proc~csc_r proc~csc_c CSC_c interface~csc->proc~csc_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures csc_r csc_c Module Procedures public elemental function CSC_r (X) result(csc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CSC_c (Z) result(csc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/csc.html"},{"title":"acsc – RPN calculator in Fortran","text":"public interface acsc Calls interface~~acsc~~CallsGraph interface~acsc acsc proc~acsc_r ACSC_r interface~acsc->proc~acsc_r proc~acsc_c ACSC_c interface~acsc->proc~acsc_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures acsc_r acsc_c Module Procedures public elemental function ACSC_r (Y) result(acsc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACSC_c (Z) result(acsc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/acsc.html"},{"title":"sec – RPN calculator in Fortran","text":"public interface sec Calls interface~~sec~~CallsGraph interface~sec sec proc~sec_r SEC_r interface~sec->proc~sec_r proc~sec_c SEC_c interface~sec->proc~sec_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures sec_r sec_c Module Procedures public elemental function SEC_r (X) result(sec) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SEC_c (Z) result(sec) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/sec.html"},{"title":"asec – RPN calculator in Fortran","text":"public interface asec Calls interface~~asec~~CallsGraph interface~asec asec proc~asec_r ASEC_r interface~asec->proc~asec_r proc~asec_c ASEC_c interface~asec->proc~asec_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures asec_r asec_c Module Procedures public elemental function ASEC_r (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ASEC_c (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/asec.html"},{"title":"cot – RPN calculator in Fortran","text":"public interface cot Calls interface~~cot~~CallsGraph interface~cot cot proc~cot_c COT_c interface~cot->proc~cot_c proc~cot_r COT_r interface~cot->proc~cot_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures cot_r cot_c Module Procedures public elemental function COT_r (X) result(cot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function COT_c (Z) result(cot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/cot.html"},{"title":"acot – RPN calculator in Fortran","text":"public interface acot Calls interface~~acot~~CallsGraph interface~acot acot proc~acot_r ACOT_r interface~acot->proc~acot_r proc~acot_c ACOT_c interface~acot->proc~acot_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures acot_r acot_c Module Procedures public elemental function ACOT_r (Y) result(acot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACOT_c (Y) result(Acot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp)","tags":"","loc":"interface/acot.html"},{"title":"hav – RPN calculator in Fortran","text":"public interface hav Calls interface~~hav~~CallsGraph interface~hav hav proc~hav_r HAV_r interface~hav->proc~hav_r proc~hav_c HAV_c interface~hav->proc~hav_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures hav_r hav_c Module Procedures public elemental function HAV_r (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function HAV_c (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/hav.html"},{"title":"ahav – RPN calculator in Fortran","text":"public interface ahav Calls interface~~ahav~~CallsGraph interface~ahav ahav proc~ahav_r AHAV_r interface~ahav->proc~ahav_r proc~ahav_c AHAV_c interface~ahav->proc~ahav_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures ahav_r ahav_c Module Procedures public elemental function AHAV_r (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function AHAV_c (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp)","tags":"","loc":"interface/ahav.html"},{"title":"crd – RPN calculator in Fortran","text":"public interface crd Calls interface~~crd~~CallsGraph interface~crd crd proc~crd_c CRD_c interface~crd->proc~crd_c proc~crd_r CRD_r interface~crd->proc~crd_r Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures crd_r crd_c Module Procedures public elemental function CRD_r (X) result(crd) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CRD_c (Z) result(crd) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp)","tags":"","loc":"interface/crd.html"},{"title":"PUSH_STACK_r – RPN calculator in Fortran","text":"public subroutine PUSH_STACK_r(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Calls proc~~push_stack_r~~CallsGraph proc~push_stack_r PUSH_STACK_r stack stack proc~push_stack_r->stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~push_stack_r~~CalledByGraph proc~push_stack_r PUSH_STACK_r interface~push_stack push_stack interface~push_stack->proc~push_stack_r proc~eval EVAL proc~eval->interface~push_stack proc~eval->proc~eval proc~regops regops proc~eval->proc~regops program~rpn RPN program~rpn->interface~push_stack program~rpn->proc~eval proc~regops->interface~push_stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/push_stack_r.html"},{"title":"CPUSH_STACK – RPN calculator in Fortran","text":"public subroutine CPUSH_STACK(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X Calls proc~~cpush_stack~~CallsGraph proc~cpush_stack CPUSH_STACK cstack cstack proc~cpush_stack->cstack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cpush_stack~~CalledByGraph proc~cpush_stack CPUSH_STACK interface~push_stack push_stack interface~push_stack->proc~cpush_stack proc~eval EVAL proc~eval->interface~push_stack proc~eval->proc~eval proc~regops regops proc~eval->proc~regops program~rpn RPN program~rpn->interface~push_stack program~rpn->proc~eval proc~regops->interface~push_stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cpush_stack.html"},{"title":"RPUSH_STACK – RPN calculator in Fortran","text":"public subroutine RPUSH_STACK(RN, RD) Arguments Type Intent Optional Attributes Name integer, intent(in) :: RN integer, intent(in) :: RD Calls proc~~rpush_stack~~CallsGraph proc~rpush_stack RPUSH_STACK rnstack rnstack proc~rpush_stack->rnstack rdstack rdstack proc~rpush_stack->rdstack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rpush_stack~~CalledByGraph proc~rpush_stack RPUSH_STACK interface~push_stack push_stack interface~push_stack->proc~rpush_stack proc~eval EVAL proc~eval->interface~push_stack proc~eval->proc~eval proc~regops regops proc~eval->proc~regops program~rpn RPN program~rpn->interface~push_stack program~rpn->proc~eval proc~regops->interface~push_stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rpush_stack.html"},{"title":"DROP_STACK – RPN calculator in Fortran","text":"public subroutine DROP_STACK(N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Calls proc~~drop_stack~~CallsGraph proc~drop_stack DROP_STACK stack stack proc~drop_stack->stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~drop_stack~~CalledByGraph proc~drop_stack DROP_STACK proc~multiply multiply proc~multiply->proc~drop_stack proc~power power proc~power->proc~drop_stack proc~divide divide proc~divide->proc~drop_stack proc~subtract subtract proc~subtract->proc~drop_stack proc~eval EVAL proc~eval->proc~drop_stack proc~eval->proc~multiply proc~eval->proc~power proc~eval->proc~divide proc~eval->proc~subtract proc~eval->proc~eval proc~add add proc~eval->proc~add proc~bsj bsj proc~eval->proc~bsj proc~add->proc~drop_stack proc~bsj->proc~drop_stack program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/drop_stack.html"},{"title":"CDROP_STACK – RPN calculator in Fortran","text":"public subroutine CDROP_STACK(N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Calls proc~~cdrop_stack~~CallsGraph proc~cdrop_stack CDROP_STACK cstack cstack proc~cdrop_stack->cstack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cdrop_stack~~CalledByGraph proc~cdrop_stack CDROP_STACK proc~power power proc~power->proc~cdrop_stack proc~divide divide proc~divide->proc~cdrop_stack proc~subtract subtract proc~subtract->proc~cdrop_stack proc~eval EVAL proc~eval->proc~cdrop_stack proc~eval->proc~power proc~eval->proc~divide proc~eval->proc~subtract proc~eval->proc~eval proc~add add proc~eval->proc~add proc~multiply multiply proc~eval->proc~multiply proc~add->proc~cdrop_stack proc~multiply->proc~cdrop_stack program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cdrop_stack.html"},{"title":"RDROP_STACK – RPN calculator in Fortran","text":"public subroutine RDROP_STACK(N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Calls proc~~rdrop_stack~~CallsGraph proc~rdrop_stack RDROP_STACK rnstack rnstack proc~rdrop_stack->rnstack rdstack rdstack proc~rdrop_stack->rdstack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rdrop_stack~~CalledByGraph proc~rdrop_stack RDROP_STACK proc~power power proc~power->proc~rdrop_stack proc~divide divide proc~divide->proc~rdrop_stack proc~subtract subtract proc~subtract->proc~rdrop_stack proc~eval EVAL proc~eval->proc~rdrop_stack proc~eval->proc~power proc~eval->proc~divide proc~eval->proc~subtract proc~eval->proc~eval proc~add add proc~eval->proc~add proc~multiply multiply proc~eval->proc~multiply proc~add->proc~rdrop_stack proc~multiply->proc~rdrop_stack program~rpn RPN program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rdrop_stack.html"},{"title":"PRINTX_r – RPN calculator in Fortran","text":"public subroutine PRINTX_r(X, NUMSTR) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X character(len=100), intent(out) :: NUMSTR Calls proc~~printx_r~~CallsGraph proc~printx_r PRINTX_r isclose isclose proc~printx_r->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~printx_r~~CalledByGraph proc~printx_r PRINTX_r interface~printx printx interface~printx->proc~printx_r proc~eval EVAL proc~eval->interface~printx proc~eval->proc~eval program~rpn RPN program~rpn->interface~printx program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/printx_r.html"},{"title":"CPRINTX – RPN calculator in Fortran","text":"public subroutine CPRINTX(X, NUMSTR) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X character(len=100), intent(out) :: NUMSTR Calls proc~~cprintx~~CallsGraph proc~cprintx CPRINTX isclose isclose proc~cprintx->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~cprintx~~CalledByGraph proc~cprintx CPRINTX interface~printx printx interface~printx->proc~cprintx proc~eval EVAL proc~eval->interface~printx proc~eval->proc~eval program~rpn RPN program~rpn->interface~printx program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cprintx.html"},{"title":"RPRINTX – RPN calculator in Fortran","text":"public subroutine RPRINTX(RN, RD, NUMSTR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: RN integer, intent(in) :: RD character(len=100), intent(out) :: NUMSTR Calls proc~~rprintx~~CallsGraph proc~rprintx RPRINTX frac_to_mixed frac_to_mixed proc~rprintx->frac_to_mixed Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rprintx~~CalledByGraph proc~rprintx RPRINTX interface~printx printx interface~printx->proc~rprintx proc~eval EVAL proc~eval->interface~printx proc~eval->proc~eval program~rpn RPN program~rpn->interface~printx program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rprintx.html"},{"title":"push_stack – RPN calculator in Fortran","text":"public interface push_stack Calls interface~~push_stack~~CallsGraph interface~push_stack push_stack proc~rpush_stack RPUSH_STACK interface~push_stack->proc~rpush_stack proc~cpush_stack CPUSH_STACK interface~push_stack->proc~cpush_stack proc~push_stack_r PUSH_STACK_r interface~push_stack->proc~push_stack_r rnstack rnstack proc~rpush_stack->rnstack rdstack rdstack proc~rpush_stack->rdstack cstack cstack proc~cpush_stack->cstack stack stack proc~push_stack_r->stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~push_stack~~CalledByGraph interface~push_stack push_stack proc~eval EVAL proc~eval->interface~push_stack proc~eval->proc~eval proc~regops regops proc~eval->proc~regops program~rpn RPN program~rpn->interface~push_stack program~rpn->proc~eval proc~regops->interface~push_stack Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures push_stack_r cpush_stack rpush_stack Module Procedures public subroutine PUSH_STACK_r (X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X public subroutine CPUSH_STACK (X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X public subroutine RPUSH_STACK (RN, RD) Arguments Type Intent Optional Attributes Name integer, intent(in) :: RN integer, intent(in) :: RD","tags":"","loc":"interface/push_stack.html"},{"title":"printx – RPN calculator in Fortran","text":"public interface printx Calls interface~~printx~~CallsGraph interface~printx printx proc~printx_r PRINTX_r interface~printx->proc~printx_r proc~rprintx RPRINTX interface~printx->proc~rprintx proc~cprintx CPRINTX interface~printx->proc~cprintx isclose isclose proc~printx_r->isclose frac_to_mixed frac_to_mixed proc~rprintx->frac_to_mixed proc~cprintx->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~printx~~CalledByGraph interface~printx printx proc~eval EVAL proc~eval->interface~printx proc~eval->proc~eval program~rpn RPN program~rpn->interface~printx program~rpn->proc~eval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures printx_r cprintx rprintx Module Procedures public subroutine PRINTX_r (X, NUMSTR) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X character(len=100), intent(out) :: NUMSTR public subroutine CPRINTX (X, NUMSTR) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X character(len=100), intent(out) :: NUMSTR public subroutine RPRINTX (RN, RD, NUMSTR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: RN integer, intent(in) :: RD character(len=100), intent(out) :: NUMSTR","tags":"","loc":"interface/printx.html"},{"title":"bessel – RPN calculator in Fortran","text":"Uses rjy rjb assert k0 i1 rjk k1 i0 rji module~~bessel~~UsesGraph module~bessel bessel module~rjk rjk module~bessel->module~rjk module~i1 i1 module~bessel->module~i1 assert assert module~bessel->assert module~k0 k0 module~bessel->module~k0 module~rjb rjb module~bessel->module~rjb module~i0 i0 module~bessel->module~i0 module~k1 k1 module~bessel->module~k1 module~rjy rjy module~bessel->module~rjy module~rji rji module~bessel->module~rji Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~bessel~~UsedByGraph module~bessel bessel module~funcs funcs module~funcs->module~bessel program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions jinc Functions public elemental function jinc (X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp)","tags":"","loc":"module/bessel.html"},{"title":"evals – RPN calculator in Fortran","text":"EVAL Evaluate a operation. Uses funcs assert help GLOBAL stackops module~~evals~~UsesGraph module~evals evals module~help help module~evals->module~help assert assert module~evals->assert module~funcs funcs module~evals->module~funcs module~stackops stackops module~evals->module~stackops module~global GLOBAL module~evals->module~global iso_fortran_env iso_fortran_env module~help->iso_fortran_env module~funcs->assert module~bessel bessel module~funcs->module~bessel module~stats stats module~funcs->module~stats module~funcs->iso_fortran_env module~fgamma fgamma module~funcs->module~fgamma module~hyper hyper module~funcs->module~hyper module~trig trig module~funcs->module~trig module~rat rat module~funcs->module~rat module~stackops->assert module~stackops->module~funcs module~stackops->module~global module~stackops->iso_fortran_env module~global->assert module~bessel->assert module~rjk rjk module~bessel->module~rjk module~i1 i1 module~bessel->module~i1 module~k0 k0 module~bessel->module~k0 module~rjb rjb module~bessel->module~rjb module~i0 i0 module~bessel->module~i0 module~k1 k1 module~bessel->module~k1 module~rjy rjy module~bessel->module~rjy module~rji rji module~bessel->module~rji module~stats->assert module~fgamma->assert module~hyper->assert module~hyper->module~global module~hyper->iso_fortran_env module~hyper->module~rat ieee_arithmetic ieee_arithmetic module~hyper->ieee_arithmetic module~trig->assert module~rat->assert module~rat->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~evals~~UsedByGraph module~evals evals program~rpn RPN program~rpn->module~evals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables C0 Subroutines EVAL regops add subtract multiply divide power bsj bsy0 Variables Type Visibility Attributes Name Initial complex(kind=wp), private, parameter :: C0 = (0._wp, 0._wp) Subroutines public recursive subroutine EVAL (STR) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: STR private subroutine regops (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str private subroutine add (mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode private subroutine subtract (mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode private subroutine multiply (mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode private subroutine divide (mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode private subroutine power (mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode private subroutine bsj () Arguments None private subroutine bsy0 () Arguments None","tags":"","loc":"module/evals.html"},{"title":"funcs – RPN calculator in Fortran","text":"FRAC Fractional part of a number. RFRAC Rational FRAC. CINT Complex INT. RINT Rational INT. RNINT Rational NINT. CMOD Complex MOD. RMOD Rational MOD. CUBEROOT Computes the cube root. CLOG10 Complex common logarithm. TANHC Tanhc function. CTANHC Complex tanhc function. ERROR FUNCTIONS From http://www.netlib.org/specfun DERFCX H2HMSD Convert decimal hours to hours, minutes, and seconds. Seconds are returned as a real value. HMS2H Convert hours, minutes, and seconds to decimal hours. RIEMANNZETA Riemann zeta function. Algorithm from \"Atlas for Computing Mathematical Functions\" by W.J. Thompson, Wiley, 1997. REDUCE Reduce an angle to the range [angle_min, angle_max). KEPLER Solves the elliptical Kepler's equation by the Markley method. Uses stats iso_fortran_env assert hyper fgamma trig rat bessel module~~funcs~~UsesGraph module~funcs funcs module~bessel bessel module~funcs->module~bessel module~stats stats module~funcs->module~stats assert assert module~funcs->assert iso_fortran_env iso_fortran_env module~funcs->iso_fortran_env module~hyper hyper module~funcs->module~hyper module~fgamma fgamma module~funcs->module~fgamma module~trig trig module~funcs->module~trig module~rat rat module~funcs->module~rat module~bessel->assert module~rjk rjk module~bessel->module~rjk module~i1 i1 module~bessel->module~i1 module~k0 k0 module~bessel->module~k0 module~rjb rjb module~bessel->module~rjb module~i0 i0 module~bessel->module~i0 module~k1 k1 module~bessel->module~k1 module~rjy rjy module~bessel->module~rjy module~rji rji module~bessel->module~rji module~stats->assert module~hyper->assert module~hyper->iso_fortran_env module~hyper->module~rat ieee_arithmetic ieee_arithmetic module~hyper->ieee_arithmetic module~global GLOBAL module~hyper->module~global module~fgamma->assert module~trig->assert module~rat->assert module~rat->iso_fortran_env module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~funcs~~UsedByGraph module~funcs funcs program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables xinf xmax xmin c0 Interfaces cuberoot frac sinc tanc Functions FRAC_r FRAC_c CINT RINT CMOD CUBEROOT_r CUBEROOT_c CLOG10 LOG1P SINC_r SINC_c TANC_r TANC_c SINHC CSINHC TANHC CTANHC ERFCX RIEMANNZETA REDUCE KEPLER toLower toUpper Subroutines RFRAC RNINT RMOD H2HMSD HMS2H Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: xinf = huge(0._wp) real(kind=wp), private, parameter :: xmax = xinf real(kind=wp), private, parameter :: xmin = tiny(0._wp) complex(kind=wp), private, parameter :: c0 = (0._wp, 0._wp) Interfaces public interface cuberoot public elemental function CUBEROOT_r (X) result(cuberoot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CUBEROOT_c (Z) result(cuberoot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface frac public elemental function FRAC_r (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function FRAC_c (X) result(frac) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X Return Value complex(kind=wp) public interface sinc public elemental function SINC_r (X) result(sinc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SINC_c (Z) result(sinc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface tanc public elemental function TANC_r (X) result(tanc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function TANC_c (Z) result(tanc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Functions public elemental function FRAC_r (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function FRAC_c (X) result(frac) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X Return Value complex(kind=wp) public elemental function CINT (X) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X Return Value complex(kind=wp) public elemental function RINT (N, D) result(R) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: D Return Value integer public elemental function CMOD (X, Y) result(Z) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public elemental function CUBEROOT_r (X) result(cuberoot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CUBEROOT_c (Z) result(cuberoot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function CLOG10 (X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X Return Value complex(kind=wp) public elemental function LOG1P (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SINC_r (X) result(sinc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SINC_c (Z) result(sinc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function TANC_r (X) result(tanc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function TANC_c (Z) result(tanc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function SINHC (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CSINHC (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function TANHC (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CTANHC (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function ERFCX (X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function RIEMANNZETA (S, EPS) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: S real(kind=wp), intent(in) :: EPS Return Value real(kind=wp) public elemental function REDUCE (THETA, ANGLE_MIN) result(RHO) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: THETA real(kind=wp), intent(in) :: ANGLE_MIN Return Value real(kind=wp) public elemental function KEPLER (MA, ECC) result(E5) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: MA real(kind=wp), intent(in) :: ECC Return Value real(kind=wp) public elemental function toLower (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) public elemental function toUpper (str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len(str)) Subroutines public elemental subroutine RFRAC (N, D, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: D integer, intent(out) :: NR integer, intent(out) :: DR public elemental subroutine RNINT (N, D) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: N integer, intent(inout) :: D public elemental subroutine RMOD (N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR public elemental subroutine H2HMSD (DHR, IHR, IMIN, SEC) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: DHR integer, intent(out) :: IHR integer, intent(out) :: IMIN real(kind=wp), intent(out) :: SEC public elemental subroutine HMS2H (IHR, IMIN, SEC, DHR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: IHR integer, intent(in) :: IMIN real(kind=wp), intent(in) :: SEC real(kind=wp), intent(out) :: DHR","tags":"","loc":"module/funcs.html"},{"title":"fgamma – RPN calculator in Fortran","text":"PSI Returns the digamma function of the argument XX.  XX cannot be 0 or a negative integer. From http://www.netlib.org/specfun/gamma CGAMMA Complex gamma function.\n  Formulae from \"An Atlas of Functions\" by Spanier and Oldham, Sect. 43:11. BETA Beta function. CBETA Complex beta function. RBETA Rational beta function. Uses assert module~~fgamma~~UsesGraph module~fgamma fgamma assert assert module~fgamma->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fgamma~~UsedByGraph module~fgamma fgamma module~funcs funcs module~funcs->module~fgamma program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions PSI CGAMMA BETA CBETA Subroutines RBETA Functions public function PSI (XX) Explanation of machine-dependent constants Read more… Arguments Type Intent Optional Attributes Name real(kind=wp) :: XX Return Value real(kind=wp) public function CGAMMA (Z) result(R) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function BETA (X, Y) result(R) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public function CBETA (X, Y) result(R) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) Subroutines public elemental subroutine RBETA (X, Y, N, D) Arguments Type Intent Optional Attributes Name integer, intent(in) :: X integer, intent(in) :: Y integer, intent(out) :: N integer, intent(out) :: D","tags":"","loc":"module/fgamma.html"},{"title":"help – RPN calculator in Fortran","text":"Uses iso_fortran_env module~~help~~UsesGraph module~help help iso_fortran_env iso_fortran_env module~help->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~help~~UsedByGraph module~help help module~evals evals module~evals->module~help program~rpn RPN program~rpn->module~evals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines print_help Subroutines public subroutine print_help () Arguments None","tags":"","loc":"module/help.html"},{"title":"hyper – RPN calculator in Fortran","text":"SECH Hyperbolic secant. ASECH Inverse hyperbolic secant. CSCH Hyperbolic cosecant. ACSCH Inverse hyperbolic cosecant. COTH Hyperbolic cotangent. ACOTH Inverse hyperbolic cotangent. Uses iso_fortran_env assert ieee_arithmetic GLOBAL rat module~~hyper~~UsesGraph module~hyper hyper assert assert module~hyper->assert iso_fortran_env iso_fortran_env module~hyper->iso_fortran_env ieee_arithmetic ieee_arithmetic module~hyper->ieee_arithmetic module~rat rat module~hyper->module~rat module~global GLOBAL module~hyper->module~global module~rat->assert module~rat->iso_fortran_env module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~hyper~~UsedByGraph module~hyper hyper proc~cgamma CGAMMA proc~cgamma->module~hyper module~funcs funcs module~funcs->module~hyper program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces sech asech csch acsch coth acoth Functions SECH_r SECH_c ASECH_r ASECH_c CSCH_r CSCH_c ACSCH_r ACSCH_c COTH_r COTH_c ACOTH_r ACOTH_c Subroutines hasin hacos hatan Interfaces public interface sech public elemental function SECH_r (X) result(sech) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SECH_c (Z) result(sech) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface asech public elemental function ASECH_r (Y) result(asech) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ASECH_c (Y) result(asech) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public interface csch public elemental function CSCH_r (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CSCH_c (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface acsch public elemental function ACSCH_r (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACSCH_c (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public interface coth public elemental function COTH_r (X) result(coth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function COTH_c (Z) result(coth) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface acoth public elemental function ACOTH_r (Y) result(acoth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACOTH_c (Z) result(acoth) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Functions public elemental function SECH_r (X) result(sech) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SECH_c (Z) result(sech) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function ASECH_r (Y) result(asech) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ASECH_c (Y) result(asech) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public elemental function CSCH_r (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CSCH_c (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function ACSCH_r (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACSCH_c (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public elemental function COTH_r (X) result(coth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function COTH_c (Z) result(coth) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function ACOTH_r (Y) result(acoth) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACOTH_c (Z) result(acoth) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Subroutines public subroutine hasin (domain_mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: domain_mode public subroutine hacos (domain_mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: domain_mode public subroutine hatan (domain_mode) Arguments Type Intent Optional Attributes Name integer, intent(in) :: domain_mode","tags":"","loc":"module/hyper.html"},{"title":"i0 – RPN calculator in Fortran","text":"Used by module~~i0~~UsedByGraph module~i0 i0 module~bessel bessel module~bessel->module~i0 module~funcs funcs module~funcs->module~bessel program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions BESI0 BESEI0 Subroutines CALCI0 Functions public function BESI0 (X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision private function BESEI0 (X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Subroutines private subroutine CALCI0 (ARG, RESULT, JINT) Explanation of machine-dependent constants Read more… Arguments Type Intent Optional Attributes Name double precision :: ARG double precision :: RESULT integer :: JINT","tags":"","loc":"module/i0.html"},{"title":"i1 – RPN calculator in Fortran","text":"Used by module~~i1~~UsedByGraph module~i1 i1 module~bessel bessel module~bessel->module~i1 module~funcs funcs module~funcs->module~bessel program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions BESI1 BESEI1 Subroutines CALCI1 Functions public function BESI1 (X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision private function BESEI1 (X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Subroutines private subroutine CALCI1 (ARG, RESULT, JINT) Explanation of machine-dependent constants Read more… Arguments Type Intent Optional Attributes Name double precision :: ARG double precision :: RESULT integer :: JINT","tags":"","loc":"module/i1.html"},{"title":"k0 – RPN calculator in Fortran","text":"Used by module~~k0~~UsedByGraph module~k0 k0 module~bessel bessel module~bessel->module~k0 module~funcs funcs module~funcs->module~bessel program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions BESK0 BESEK0 Subroutines CALCK0 Functions public function BESK0 (X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision private function BESEK0 (X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Subroutines private subroutine CALCK0 (ARG, RESULT, JINT) Explanation of machine-dependent constants Read more… Arguments Type Intent Optional Attributes Name double precision :: ARG double precision :: RESULT integer :: JINT","tags":"","loc":"module/k0.html"},{"title":"k1 – RPN calculator in Fortran","text":"Used by module~~k1~~UsedByGraph module~k1 k1 module~bessel bessel module~bessel->module~k1 module~funcs funcs module~funcs->module~bessel program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions BESK1 BESEK1 Subroutines CALCK1 Functions public function BESK1 (X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision private function BESEK1 (X) Arguments Type Intent Optional Attributes Name double precision :: X Return Value doubleprecision Subroutines private subroutine CALCK1 (ARG, RESULT, JINT) Explanation of machine-dependent constants Read more… Arguments Type Intent Optional Attributes Name double precision :: ARG double precision :: RESULT integer :: JINT","tags":"","loc":"module/k1.html"},{"title":"rat – RPN calculator in Fortran","text":"ISDIGIT Determines whether the input character is a digit (0-9). ISPM Determines whether the input character is a + or - sign. ISHEX Determines whether the input character is a valid hexadecimal digit ISREAL Determines whether the input string is a number.  If it is, it will also return its value. In decimal mode, the input string is a number if it satisfies all of these criteria: 1 . The first non - blank character is a digit , + , - , or decimal point (.). 2 . It contains , at most , one decimal point . 3 . It contains , at most , one occurrence of E . 4 . Any decimal point occurs before any E . 5 . The E may be followed by an optional + or - . 6 . A letter E must be followed by at least one digit ( after the optional + or - ). 7 . + or - may only be the first non - blank character , or the character immediately following E . 8 . It contains no other characters besides : digits , + , - , decimal point (.), and E . If not in decimal mode, the input string is a number if it satisfies these criteria: 1 . BIN : digits 0 and 1 only 2 . OCT : digits 0 - 7 only 3 . HEX : digits 0 - 9 and A - F only Uses functions:  ISDIGIT, ISPM, ISHEX ISCOMPLEX Determines whether the input string is a complex number.  If it is, it will also return its value.\n  A complex number consists of two real numbers separated by a comma (no space).  For example:  2.0,5.0E2 In decimal mode, the input string is a number if it satisfies all of these criteria: 1 . The first non - blank character is a digit , + , - , or decimal point (.). 2 . It contains , at most , one decimal point . 3 . It contains , at most , one occurrence of E . 4 . Any decimal point occurs before any E . 5 . The E may be followed by an optional + or - . 6 . A letter E must be followed by at least one digit ( after the optional + or - ). 7 . + or - may only be the first non - blank character , or the character immediately following E . 8 . It contains no other characters besides : digits , + , - , decimal point (.), and E . If not in decimal mode, the input string is a number if it satisfies these criteria: 1 . BIN : digits 0 and 1 only 2 . OCT : digits 0 - 7 only 3 . HEX : digits 0 - 9 and A - F only Uses functions:  ISDIGIT, ISPM, ISHEX ISRATIONAL Determines whether the input string is a rational number.  If it is, it will also return its value.\n  A rational number consists of two integers separated by a slash (no space).  For example:  2/5 In decimal mode, the input string is a number if it satisfies all of these criteria: 1 . The first non - blank character is a digit , + , or - . 2 . It contains no other characters besides : digits , + , and - . If not in decimal mode, the input string is a number if it satisfies these criteria: 1 . BIN : digits 0 and 1 only 2 . OCT : digits 0 - 7 only 3 . HEX : digits 0 - 9 and A - F only Uses functions:  ISDIGIT, ISPM, ISHEX SWITCH_RAT_TO_REAL ISFRAC Returns .TRUE. if X has a fractional part (i.e. if X is not an integer) ISINT Returns .TRUE. if X has no fractional part (i.e. if X is an integer) FRAC_TO_MIXED Convert a fraction from improper format to mixed format. MATHEMATICAL FUNCTIONS GCD Greatest common divisor.\n  Find the greatest common divisor of two integers using Euclid's algorithm. LCM Least common multiple.\n  Find the least common multiple of two integers. RATNORM Normalize a rational number\n  Check for a denominator or numerator of 0; make the denominator positive; and reduce the fraction. RADD Add two rational numbers. RSUB Subtract two rational numbers. RMUL Multiply two rational numbers. RDIV Multiply two rational numbers. DEC_TO_FRAC Converts a decimal number to a fraction.\n  Algorithm from \"An Atlas of Functions\" by Spanier and Oldham, Springer-Verlag, 1987, pp. 665-667. Uses iso_fortran_env assert module~~rat~~UsesGraph module~rat rat iso_fortran_env iso_fortran_env module~rat->iso_fortran_env assert assert module~rat->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~rat~~UsedByGraph module~rat rat proc~rlinreg RLINREG proc~rlinreg->module~rat module~hyper hyper module~hyper->module~rat proc~rbeta RBETA proc~rbeta->module~rat module~funcs funcs module~funcs->module~rat module~funcs->module~hyper program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals proc~cgamma CGAMMA proc~cgamma->module~hyper module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions ISDIGIT ISPM ISHEX ISREAL ISCOMPLEX ISRATIONAL ISFRAC ISINT GCD LCM Subroutines SWITCH_RAT_TO_REAL FRAC_TO_MIXED RATNORM RADD RSUB RMUL RDIV DEC_TO_FRAC Functions public elemental function ISDIGIT (CH) Arguments Type Intent Optional Attributes Name character, intent(in) :: CH Return Value logical public elemental function ISPM (CH) Arguments Type Intent Optional Attributes Name character, intent(in) :: CH Return Value logical public elemental function ISHEX (CH) Arguments Type Intent Optional Attributes Name character, intent(in) :: CH Return Value logical public function ISREAL (STR, X) result(NUM_FLAG) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: STR real(kind=wp), intent(out) :: X Return Value logical public function ISCOMPLEX (STR, X) result(NUM_FLAG) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: STR complex(kind=wp), intent(out) :: X Return Value logical public function ISRATIONAL (STR, NUM, DEN) result(NUM_FLAG) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: STR integer, intent(out) :: NUM integer, intent(out) :: DEN Return Value logical public elemental function ISFRAC (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value logical public elemental function ISINT (X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value logical public elemental function GCD (A, B) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A integer, intent(in) :: B Return Value integer public elemental function LCM (A, B) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A integer, intent(in) :: B Return Value integer Subroutines public subroutine SWITCH_RAT_TO_REAL () Arguments None public elemental subroutine FRAC_TO_MIXED (AN, AD, A1, A2, A3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: AN integer, intent(in) :: AD integer, intent(out) :: A1 integer, intent(out) :: A2 integer, intent(out) :: A3 public elemental subroutine RATNORM (NUM, DEN) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: NUM integer, intent(inout) :: DEN public elemental subroutine RADD (N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR public elemental subroutine RSUB (N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR public elemental subroutine RMUL (N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR public elemental subroutine RDIV (N1, D1, N2, D2, NR, DR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N1 integer, intent(in) :: D1 integer, intent(in) :: N2 integer, intent(in) :: D2 integer, intent(out) :: NR integer, intent(out) :: DR public subroutine DEC_TO_FRAC (X, NUM, DEN, TOL) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X integer, intent(out) :: NUM integer, intent(out) :: DEN real(kind=wp), intent(in), optional :: TOL","tags":"","loc":"module/rat.html"},{"title":"GLOBAL – RPN calculator in Fortran","text":"Uses assert module~~global~~UsesGraph module~global GLOBAL assert assert module~global->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~global~~UsedByGraph module~global GLOBAL module~stackops stackops module~stackops->module~global module~funcs funcs module~stackops->module~funcs proc~isrational ISRATIONAL proc~isrational->module~global module~hyper hyper module~hyper->module~global proc~switch_rat_to_real SWITCH_RAT_TO_REAL proc~switch_rat_to_real->module~global proc~iscomplex ISCOMPLEX proc~iscomplex->module~global proc~isreal ISREAL proc~isreal->module~global proc~linreg LINREG proc~linreg->module~global proc~clinreg CLINREG proc~clinreg->module~global proc~rlinreg RLINREG proc~rlinreg->module~global module~evals evals module~evals->module~global module~evals->module~stackops module~evals->module~funcs program~rpn RPN program~rpn->module~global program~rpn->module~stackops program~rpn->module~evals program~rpn->module~funcs proc~cgamma CGAMMA proc~cgamma->module~hyper module~funcs->module~hyper Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables VERSION STACK_SIZE REG_SIZE STACK REG CSTACK CREG RNSTACK RDSTACK RNREG RDREG LASTX CLASTX RNLASTX RDLASTX NN SUMX SUMX2 SUMY SUMY2 SUMXY CNN CSUMX CSUMX2 CSUMY CSUMY2 CSUMXY RNNN RNSUMX RNSUMX2 RNSUMY RNSUMY2 RNSUMXY RDNN RDSUMX RDSUMX2 RDSUMY RDSUMY2 RDSUMXY ANGLE_FACTOR FRACTOL ANGLE_MODE DISP_MODE DISP_DIGITS BASE_MODE DOMAIN_MODE FRACTION_MODE INITIAL_ANGLE_MODE INITIAL_DISP_MODE INITIAL_DISP_DIGITS INITIAL_DOMAIN_MODE INITIAL_BASE_MODE INITIAL_FRACTION_MODE INITIAL_FRACTOL Subroutines init_stack Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: VERSION = '1.1.7' integer, public :: STACK_SIZE integer, public, parameter :: REG_SIZE = 10 real(kind=wp), public, allocatable :: STACK (:) real(kind=wp), public, DIMENSION (0:REG_SIZE-1) :: REG complex(kind=wp), public, allocatable :: CSTACK (:) complex(kind=wp), public, DIMENSION (0:REG_SIZE-1) :: CREG integer, public, allocatable :: RNSTACK (:) integer, public, allocatable :: RDSTACK (:) integer, public, DIMENSION (0:REG_SIZE-1) :: RNREG integer, public, DIMENSION (0:REG_SIZE-1) :: RDREG real(kind=wp), public :: LASTX complex(kind=wp), public :: CLASTX integer, public :: RNLASTX integer, public :: RDLASTX real(kind=wp), public :: NN real(kind=wp), public :: SUMX real(kind=wp), public :: SUMX2 real(kind=wp), public :: SUMY real(kind=wp), public :: SUMY2 real(kind=wp), public :: SUMXY complex(kind=wp), public :: CNN complex(kind=wp), public :: CSUMX complex(kind=wp), public :: CSUMX2 complex(kind=wp), public :: CSUMY complex(kind=wp), public :: CSUMY2 complex(kind=wp), public :: CSUMXY integer, public :: RNNN integer, public :: RNSUMX integer, public :: RNSUMX2 integer, public :: RNSUMY integer, public :: RNSUMY2 integer, public :: RNSUMXY integer, public :: RDNN integer, public :: RDSUMX integer, public :: RDSUMX2 integer, public :: RDSUMY integer, public :: RDSUMY2 integer, public :: RDSUMXY real(kind=wp), public :: ANGLE_FACTOR real(kind=wp), public :: FRACTOL integer, public :: ANGLE_MODE integer, public :: DISP_MODE integer, public :: DISP_DIGITS integer, public :: BASE_MODE integer, public :: DOMAIN_MODE integer, public :: FRACTION_MODE integer, public, parameter :: INITIAL_ANGLE_MODE = 1 integer, public, parameter :: INITIAL_DISP_MODE = 4 integer, public, parameter :: INITIAL_DISP_DIGITS = 4 integer, public, parameter :: INITIAL_DOMAIN_MODE = 1 integer, public, parameter :: INITIAL_BASE_MODE = 10 integer, public, parameter :: INITIAL_FRACTION_MODE = 1 real(kind=wp), public, parameter :: INITIAL_FRACTOL = 1.0D-4 Subroutines public subroutine init_stack () Arguments None","tags":"","loc":"module/global.html"},{"title":"rji – RPN calculator in Fortran","text":"Used by module~~rji~~UsedByGraph module~rji rji module~bessel bessel module~bessel->module~rji module~funcs funcs module~funcs->module~bessel program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines RIBESL Subroutines public subroutine RIBESL (X, ALPHA, NB, IZE, B, NCALC) Explanation of machine-dependent constants Read more… Arguments Type Intent Optional Attributes Name double precision :: X double precision :: ALPHA integer, intent(in) :: NB integer :: IZE double precision, intent(out) :: B (NB) integer, intent(out) :: NCALC","tags":"","loc":"module/rji.html"},{"title":"rjb – RPN calculator in Fortran","text":"Used by module~~rjb~~UsedByGraph module~rjb rjb module~bessel bessel module~bessel->module~rjb module~funcs funcs module~funcs->module~bessel program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines RJBESL Subroutines public subroutine RJBESL (X, ALPHA, NB, B, NCALC) Explanation of machine-dependent constants Read more… Arguments Type Intent Optional Attributes Name double precision :: X double precision :: ALPHA integer :: NB double precision :: B integer :: NCALC","tags":"","loc":"module/rjb.html"},{"title":"rjk – RPN calculator in Fortran","text":"Used by module~~rjk~~UsedByGraph module~rjk rjk module~bessel bessel module~bessel->module~rjk module~funcs funcs module~funcs->module~bessel program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines RKBESL Subroutines public subroutine RKBESL (X, ALPHA, NB, IZE, BK, NCALC) Explanation of machine-dependent constants Read more… Arguments Type Intent Optional Attributes Name double precision :: X double precision :: ALPHA integer :: NB integer :: IZE double precision :: BK integer :: NCALC","tags":"","loc":"module/rjk.html"},{"title":"rjy – RPN calculator in Fortran","text":"Used by module~~rjy~~UsedByGraph module~rjy rjy module~bessel bessel module~bessel->module~rjy module~funcs funcs module~funcs->module~bessel program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines RYBESL Subroutines public subroutine RYBESL (X, ALPHA, NB, BY, NCALC) Explanation of machine-dependent constants Read more… Arguments Type Intent Optional Attributes Name double precision :: X double precision :: ALPHA integer :: NB double precision :: BY integer :: NCALC","tags":"","loc":"module/rjy.html"},{"title":"stats – RPN calculator in Fortran","text":"CNR Combinations of N things taken R at a time. PNR Permutations of N things taken R at a time. LINREG Real linear regression. CLINREG Complex linear regression. RLINREG Rational linear regression. Uses assert module~~stats~~UsesGraph module~stats stats assert assert module~stats->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~stats~~UsedByGraph module~stats stats module~funcs funcs module~funcs->module~stats program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions CNR PNR Subroutines LINREG CLINREG RLINREG Functions public elemental function CNR (N, R) result(Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: R Return Value real(kind=wp) public elemental function PNR (N, R) result(Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N integer, intent(in) :: R Return Value real(kind=wp) Subroutines public elemental subroutine LINREG (M, B, R) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: M real(kind=wp), intent(out) :: B real(kind=wp), intent(out) :: R public elemental subroutine CLINREG (M, B, R) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(out) :: M complex(kind=wp), intent(out) :: B complex(kind=wp), intent(out) :: R public elemental subroutine RLINREG (NM, DM, NB, DB, R) Arguments Type Intent Optional Attributes Name integer, intent(out) :: NM integer, intent(out) :: DM integer, intent(out) :: NB integer, intent(out) :: DB real(kind=wp), intent(out) :: R","tags":"","loc":"module/stats.html"},{"title":"trig – RPN calculator in Fortran","text":"SEC Secant. ASEC Inverse secant. CSC Cosecant. ACSC Inverse cosecant. COT Cotangent. ACOT Inverse cotangent. ACOT2 Inverse cotangent (two arguments). EXSEC Exsecant. CEXSEC Complex exsecant. AEXSEC Inverse exsecant. CAEXSEC Complex inverse exsecant. VERS Versine. CVERS Complex versine. AVERS Inverse versine. CAVERS Complex inverse versine. COVERS Coversine. CCOVERS Complex coversine. ACOVERS Inverse coversine. CACOVERS Complex inverse coversine. HAV Haversine. AHAV Inverse haversine. CRD Chord (of Ptolemy). ACRD Inverse chord (of Ptolemy). CACRD Complex inverse chord (of Ptolemy). Uses assert module~~trig~~UsesGraph module~trig trig assert assert module~trig->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~trig~~UsedByGraph module~trig trig module~funcs funcs module~funcs->module~trig program~rpn RPN program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~stackops->module~funcs module~evals->module~funcs module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces csc acsc sec asec cot acot hav ahav crd Functions SEC_r SEC_c ASEC_r ASEC_c CSC_r CSC_c ACSC_r ACSC_c COT_r COT_c ACOT_r ACOT_c ACOT2 EXSEC CEXSEC AEXSEC CAEXSEC VERS CVERS AVERS CAVERS COVERS CCOVERS ACOVERS CACOVERS HAV_r HAV_c AHAV_r AHAV_c CRD_r CRD_c ACRD CACRD Interfaces public interface csc public elemental function CSC_r (X) result(csc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CSC_c (Z) result(csc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface acsc public elemental function ACSC_r (Y) result(acsc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACSC_c (Z) result(acsc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface sec public elemental function SEC_r (X) result(sec) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SEC_c (Z) result(sec) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface asec public elemental function ASEC_r (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ASEC_c (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface cot public elemental function COT_r (X) result(cot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function COT_c (Z) result(cot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface acot public elemental function ACOT_r (Y) result(acot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACOT_c (Y) result(Acot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public interface hav public elemental function HAV_r (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function HAV_c (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public interface ahav public elemental function AHAV_r (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function AHAV_c (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public interface crd public elemental function CRD_r (X) result(crd) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CRD_c (Z) result(crd) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) Functions public elemental function SEC_r (X) result(sec) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function SEC_c (Z) result(sec) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function ASEC_r (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ASEC_c (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function CSC_r (X) result(csc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CSC_c (Z) result(csc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function ACSC_r (Y) result(acsc) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACSC_c (Z) result(acsc) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function COT_r (X) result(cot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function COT_c (Z) result(cot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function ACOT_r (Y) result(acot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function ACOT_c (Y) result(Acot) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public elemental function ACOT2 (Y, Z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y real(kind=wp), intent(in) :: Z Return Value real(kind=wp) public elemental function EXSEC (X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CEXSEC (Z) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function AEXSEC (Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function CAEXSEC (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public elemental function VERS (X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CVERS (Z) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function AVERS (Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function CAVERS (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public elemental function COVERS (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public function CCOVERS (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function ACOVERS (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function CACOVERS (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public elemental function HAV_r (X) result(Y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function HAV_c (Z) result(Y) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function AHAV_r (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function AHAV_c (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp) public elemental function CRD_r (X) result(crd) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X Return Value real(kind=wp) public elemental function CRD_c (Z) result(crd) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Z Return Value complex(kind=wp) public elemental function ACRD (Y) result(X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: Y Return Value real(kind=wp) public elemental function CACRD (Y) result(X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: Y Return Value complex(kind=wp)","tags":"","loc":"module/trig.html"},{"title":"stackops – RPN calculator in Fortran","text":"PUSH_STACK Push a number onto the real stack. push_stack Push a number onto the complex stack. RPUSH_STACK Push a number onto the rational stack. DROP_STACK Drop a number from the real stack. CDROP_STACK Drop a number from the complex stack. RDROP_STACK Drop a number from the rational stack. PRINTX Print a real number to a string. CPRINTX Print a complex number to a string. RPRINTX Print a rational number to a string. Uses funcs assert iso_fortran_env GLOBAL module~~stackops~~UsesGraph module~stackops stackops iso_fortran_env iso_fortran_env module~stackops->iso_fortran_env module~funcs funcs module~stackops->module~funcs module~global GLOBAL module~stackops->module~global assert assert module~stackops->assert module~funcs->iso_fortran_env module~funcs->assert module~bessel bessel module~funcs->module~bessel module~stats stats module~funcs->module~stats module~fgamma fgamma module~funcs->module~fgamma module~hyper hyper module~funcs->module~hyper module~trig trig module~funcs->module~trig module~rat rat module~funcs->module~rat module~global->assert module~bessel->assert module~rjk rjk module~bessel->module~rjk module~i1 i1 module~bessel->module~i1 module~k0 k0 module~bessel->module~k0 module~rjb rjb module~bessel->module~rjb module~i0 i0 module~bessel->module~i0 module~k1 k1 module~bessel->module~k1 module~rjy rjy module~bessel->module~rjy module~rji rji module~bessel->module~rji module~stats->assert module~fgamma->assert module~hyper->iso_fortran_env module~hyper->module~global module~hyper->assert module~hyper->module~rat ieee_arithmetic ieee_arithmetic module~hyper->ieee_arithmetic module~trig->assert module~rat->iso_fortran_env module~rat->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~stackops~~UsedByGraph module~stackops stackops program~rpn RPN program~rpn->module~stackops module~evals evals program~rpn->module~evals module~evals->module~stackops Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables c0 Interfaces push_stack printx Subroutines PUSH_STACK_r CPUSH_STACK RPUSH_STACK DROP_STACK CDROP_STACK RDROP_STACK PRINTX_r CPRINTX RPRINTX Variables Type Visibility Attributes Name Initial complex(kind=wp), private, parameter :: c0 = (0._wp, 0._wp) Interfaces public interface push_stack public subroutine PUSH_STACK_r (X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X public subroutine CPUSH_STACK (X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X public subroutine RPUSH_STACK (RN, RD) Arguments Type Intent Optional Attributes Name integer, intent(in) :: RN integer, intent(in) :: RD public interface printx public subroutine PRINTX_r (X, NUMSTR) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X character(len=100), intent(out) :: NUMSTR public subroutine CPRINTX (X, NUMSTR) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X character(len=100), intent(out) :: NUMSTR public subroutine RPRINTX (RN, RD, NUMSTR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: RN integer, intent(in) :: RD character(len=100), intent(out) :: NUMSTR Subroutines public subroutine PUSH_STACK_r (X) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X public subroutine CPUSH_STACK (X) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X public subroutine RPUSH_STACK (RN, RD) Arguments Type Intent Optional Attributes Name integer, intent(in) :: RN integer, intent(in) :: RD public subroutine DROP_STACK (N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N public subroutine CDROP_STACK (N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N public subroutine RDROP_STACK (N) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N public subroutine PRINTX_r (X, NUMSTR) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: X character(len=100), intent(out) :: NUMSTR public subroutine CPRINTX (X, NUMSTR) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: X character(len=100), intent(out) :: NUMSTR public subroutine RPRINTX (RN, RD, NUMSTR) Arguments Type Intent Optional Attributes Name integer, intent(in) :: RN integer, intent(in) :: RD character(len=100), intent(out) :: NUMSTR","tags":"","loc":"module/stackops.html"},{"title":"RPN – RPN calculator in Fortran","text":"Uses funcs iso_fortran_env GLOBAL stackops evals program~~rpn~~UsesGraph program~rpn RPN iso_fortran_env iso_fortran_env program~rpn->iso_fortran_env module~funcs funcs program~rpn->module~funcs module~stackops stackops program~rpn->module~stackops module~evals evals program~rpn->module~evals module~global GLOBAL program~rpn->module~global module~funcs->iso_fortran_env module~bessel bessel module~funcs->module~bessel module~stats stats module~funcs->module~stats assert assert module~funcs->assert module~fgamma fgamma module~funcs->module~fgamma module~hyper hyper module~funcs->module~hyper module~trig trig module~funcs->module~trig module~rat rat module~funcs->module~rat module~stackops->iso_fortran_env module~stackops->module~funcs module~stackops->module~global module~stackops->assert module~evals->module~funcs module~evals->module~stackops module~evals->module~global module~evals->assert module~help help module~evals->module~help module~global->assert module~bessel->assert module~rjk rjk module~bessel->module~rjk module~i1 i1 module~bessel->module~i1 module~k0 k0 module~bessel->module~k0 module~rjb rjb module~bessel->module~rjb module~i0 i0 module~bessel->module~i0 module~k1 k1 module~bessel->module~k1 module~rjy rjy module~bessel->module~rjy module~rji rji module~bessel->module~rji module~stats->assert module~help->iso_fortran_env module~fgamma->assert module~hyper->iso_fortran_env module~hyper->module~global module~hyper->assert module~hyper->module~rat ieee_arithmetic ieee_arithmetic module~hyper->ieee_arithmetic module~trig->assert module~rat->iso_fortran_env module~rat->assert var panprogramrpnUsesGraph = svgPanZoom('#programrpnUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~rpn~~CallsGraph program~rpn RPN interface~push_stack push_stack program~rpn->interface~push_stack stack stack program~rpn->stack iscomplex iscomplex program~rpn->iscomplex rdstack rdstack program~rpn->rdstack isreal isreal program~rpn->isreal proc~eval EVAL program~rpn->proc~eval isrational isrational program~rpn->isrational interface~printx printx program~rpn->interface~printx rnstack rnstack program~rpn->rnstack proc~toupper toUpper program~rpn->proc~toupper proc~init_stack init_stack program~rpn->proc~init_stack cstack cstack program~rpn->cstack proc~cpush_stack CPUSH_STACK interface~push_stack->proc~cpush_stack proc~rpush_stack RPUSH_STACK interface~push_stack->proc~rpush_stack proc~push_stack_r PUSH_STACK_r interface~push_stack->proc~push_stack_r proc~eval->interface~push_stack proc~eval->stack proc~eval->rdstack proc~eval->proc~eval proc~eval->interface~printx proc~eval->rnstack proc~eval->cstack proc~csinhc CSINHC proc~eval->proc~csinhc acoth acoth proc~eval->acoth acovers acovers proc~eval->acovers isfrac isfrac proc~eval->isfrac hav hav proc~eval->hav interface~cuberoot cuberoot proc~eval->interface~cuberoot proc~add add proc~eval->proc~add exsec exsec proc~eval->exsec jinc jinc proc~eval->jinc cexsec cexsec proc~eval->cexsec proc~sinhc SINHC proc~eval->proc~sinhc ribesl ribesl proc~eval->ribesl proc~hms2h HMS2H proc~eval->proc~hms2h acot2 acot2 proc~eval->acot2 hatan hatan proc~eval->hatan cgamma cgamma proc~eval->cgamma proc~tanhc TANHC proc~eval->proc~tanhc proc~multiply multiply proc~eval->proc~multiply interface~tanc tanc proc~eval->interface~tanc isclose isclose proc~eval->isclose cacovers cacovers proc~eval->cacovers gcd gcd proc~eval->gcd proc~rdrop_stack RDROP_STACK proc~eval->proc~rdrop_stack vers vers proc~eval->vers aexsec aexsec proc~eval->aexsec crd crd proc~eval->crd beta beta proc~eval->beta csc csc proc~eval->csc proc~clog10 CLOG10 proc~eval->proc~clog10 radd radd proc~eval->radd rmul rmul proc~eval->rmul proc~rnint RNINT proc~eval->proc~rnint switch_rat_to_real switch_rat_to_real proc~eval->switch_rat_to_real besi1 besi1 proc~eval->besi1 linreg linreg proc~eval->linreg rnreg rnreg proc~eval->rnreg rsub rsub proc~eval->rsub rybesl rybesl proc~eval->rybesl rdiv rdiv proc~eval->rdiv rkbesl rkbesl proc~eval->rkbesl isint isint proc~eval->isint proc~rint RINT proc~eval->proc~rint asec asec proc~eval->asec covers covers proc~eval->covers cot cot proc~eval->cot acsc acsc proc~eval->acsc cnr cnr proc~eval->cnr ccovers ccovers proc~eval->ccovers proc~bsj bsj proc~eval->proc~bsj psi psi proc~eval->psi besi0 besi0 proc~eval->besi0 proc~cmod CMOD proc~eval->proc~cmod sec sec proc~eval->sec sech sech proc~eval->sech proc~drop_stack DROP_STACK proc~eval->proc~drop_stack cacrd cacrd proc~eval->cacrd reg reg proc~eval->reg besk1 besk1 proc~eval->besk1 proc~cint CINT proc~eval->proc~cint proc~print_help print_help proc~eval->proc~print_help hacos hacos proc~eval->hacos lcm lcm proc~eval->lcm creg creg proc~eval->creg proc~rfrac RFRAC proc~eval->proc~rfrac proc~ctanhc CTANHC proc~eval->proc~ctanhc interface~sinc sinc proc~eval->interface~sinc acrd acrd proc~eval->acrd cbeta cbeta proc~eval->cbeta besk0 besk0 proc~eval->besk0 proc~kepler KEPLER proc~eval->proc~kepler cvers cvers proc~eval->cvers proc~rmod RMOD proc~eval->proc~rmod proc~subtract subtract proc~eval->proc~subtract caexsec caexsec proc~eval->caexsec asech asech proc~eval->asech proc~regops regops proc~eval->proc~regops proc~reduce REDUCE proc~eval->proc~reduce coth coth proc~eval->coth dec_to_frac dec_to_frac proc~eval->dec_to_frac clinreg clinreg proc~eval->clinreg rlinreg rlinreg proc~eval->rlinreg acot acot proc~eval->acot rbeta rbeta proc~eval->rbeta proc~riemannzeta RIEMANNZETA proc~eval->proc~riemannzeta proc~cdrop_stack CDROP_STACK proc~eval->proc~cdrop_stack hasin hasin proc~eval->hasin interface~frac frac proc~eval->interface~frac proc~power power proc~eval->proc~power avers avers proc~eval->avers csch csch proc~eval->csch acsch acsch proc~eval->acsch proc~h2hmsd H2HMSD proc~eval->proc~h2hmsd proc~divide divide proc~eval->proc~divide ahav ahav proc~eval->ahav proc~bsy0 bsy0 proc~eval->proc~bsy0 rdreg rdreg proc~eval->rdreg pnr pnr proc~eval->pnr cavers cavers proc~eval->cavers proc~printx_r PRINTX_r interface~printx->proc~printx_r proc~cprintx CPRINTX interface~printx->proc~cprintx proc~rprintx RPRINTX interface~printx->proc~rprintx proc~csinhc->isclose proc~cuberoot_c CUBEROOT_c interface~cuberoot->proc~cuberoot_c proc~cuberoot_r CUBEROOT_r interface~cuberoot->proc~cuberoot_r proc~add->stack proc~add->rdstack proc~add->rnstack proc~add->cstack proc~add->proc~rdrop_stack proc~add->radd proc~add->proc~drop_stack proc~add->proc~cdrop_stack proc~sinhc->isclose proc~multiply->stack proc~multiply->rdstack proc~multiply->rnstack proc~multiply->cstack proc~multiply->proc~rdrop_stack proc~multiply->rmul proc~multiply->proc~drop_stack proc~multiply->proc~cdrop_stack proc~tanc_c TANC_c interface~tanc->proc~tanc_c proc~tanc_r TANC_r interface~tanc->proc~tanc_r proc~rdrop_stack->rdstack proc~rdrop_stack->rnstack proc~ratnorm RATNORM proc~rnint->proc~ratnorm proc~rsub RSUB proc~rnint->proc~rsub proc~radd RADD proc~rnint->proc~radd proc~printx_r->isclose proc~rint->proc~ratnorm proc~bsj->proc~drop_stack proc~bsj->interface~frac rjbesl rjbesl proc~bsj->rjbesl proc~cprintx->isclose proc~cmod->proc~cint proc~drop_stack->stack proc~rfrac->proc~rint proc~rfrac->proc~ratnorm proc~rfrac->proc~rsub proc~cpush_stack->cstack proc~rpush_stack->rdstack proc~rpush_stack->rnstack proc~sinc_c SINC_c interface~sinc->proc~sinc_c proc~sinc_r SINC_r interface~sinc->proc~sinc_r proc~push_stack_r->stack proc~kepler->proc~reduce proc~rmod->proc~rint proc~rmod->proc~ratnorm proc~rdiv RDIV proc~rmod->proc~rdiv proc~rmod->proc~rsub proc~rmul RMUL proc~rmod->proc~rmul proc~subtract->stack proc~subtract->rdstack proc~subtract->rnstack proc~subtract->cstack proc~subtract->proc~rdrop_stack proc~subtract->rsub proc~subtract->proc~drop_stack proc~subtract->proc~cdrop_stack proc~regops->interface~push_stack proc~regops->stack proc~regops->rdstack proc~regops->rnstack proc~regops->cstack proc~regops->rnreg proc~regops->reg proc~regops->creg proc~regops->rdreg frac_to_mixed frac_to_mixed proc~rprintx->frac_to_mixed proc~cdrop_stack->cstack proc~frac_r FRAC_r interface~frac->proc~frac_r proc~frac_c FRAC_c interface~frac->proc~frac_c proc~power->stack proc~power->rdstack proc~power->rnstack proc~power->cstack proc~power->proc~rdrop_stack proc~power->switch_rat_to_real proc~power->proc~drop_stack proc~power->proc~cdrop_stack proc~divide->stack proc~divide->rdstack proc~divide->rnstack proc~divide->cstack proc~divide->isclose proc~divide->proc~rdrop_stack proc~divide->rdiv proc~divide->proc~drop_stack proc~divide->proc~cdrop_stack proc~tanc_c->isclose proc~gcd GCD proc~ratnorm->proc~gcd proc~sinc_c->isclose proc~rdiv->proc~ratnorm proc~rsub->proc~ratnorm proc~rmul->proc~ratnorm proc~radd->proc~ratnorm proc~tanc_r->isclose proc~sinc_r->isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables PI TWOPI IDX IERR DEL PTR RN RD X CX LINE SUBSTR NUMSTR NUM_FLAG Variables Type Attributes Name Initial real(kind=wp), parameter :: PI = 4._wp*atan(1._wp) real(kind=wp), parameter :: TWOPI = 2*pi integer :: IDX integer :: IERR integer :: DEL integer :: PTR integer :: RN integer :: RD real(kind=wp) :: X complex(kind=wp) :: CX character(len=300) :: LINE character(len=300) :: SUBSTR character(len=100) :: NUMSTR logical :: NUM_FLAG = .false.","tags":"","loc":"program/rpn.html"}]}